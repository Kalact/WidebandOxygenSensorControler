   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 120               		.data
 121               	.LC1:
 122 0000 7261 6D70 		.string	"ramp temp\n"
 122      2074 656D 
 122      700A 00
 123               		.section	.text.startup,"ax",@progbits
 125               	.global	main
 127               	main:
   1:main.c        **** 
   2:main.c        **** /////////////---------------------------------///////////////////
   3:main.c        **** // 
   4:main.c        **** // www.waltech.com
   5:main.c        **** //
   6:main.c        **** /////////////---------------------------------/////////////////
   7:main.c        **** /*
   8:main.c        ****  * ramp disabled
   9:main.c        ****  * set for vref of 1.5v
  10:main.c        ****  * vref is monitored on adc1
  11:main.c        ****  * ramp to stoic
  12:main.c        ****  */
  13:main.c        **** 
  14:main.c        **** //Includes here:
  15:main.c        **** 
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <stdlib.h>
  18:main.c        **** #include <string.h>
  19:main.c        **** #include <util/delay.h>
  20:main.c        **** #include <avr/pgmspace.h>
  21:main.c        **** #include "pid.h"
  22:main.c        **** #include "stdint.h"
  23:main.c        **** #include "initilize_hardware.h"
  24:main.c        **** #include "dataout.h"
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** ////////calibration settings://///////////
  28:main.c        **** //offset for lamda value, uses to calibrate (lambda*100) = 100  at stoic.  Checking against NB sens
  29:main.c        **** //POSOFFSET is added, NEGOFFSET is subtracted.
  30:main.c        **** #define POSOFFSET 0
  31:main.c        **** #define NEGOFFSET 0
  32:main.c        **** 
  33:main.c        **** /*Lambda*100 to DAC (0-255)
  34:main.c        **** * 
  35:main.c        **** *	formula for output voltage:
  36:main.c        **** *	Vout = [(L-Lmin)/(Lmax-Lmin)]*5
  37:main.c        **** *
  38:main.c        **** * example to provide lambda range from 0.64 to 1.36:
  39:main.c        **** *	 LAMBDA_MIN	64UL
  40:main.c        **** *	 LAMBDA_MAX 136UL
  41:main.c        **** * Set two values below: 
  42:main.c        **** */
  43:main.c        **** #define LAMBDA_MIN	64UL// set to desired value for 0v output (Lambda*100)
  44:main.c        **** #define LAMBDA_MAX 136UL//set to desired value for 5v output	(Lambda*100
  45:main.c        **** ////////end calibration settings/////////////
  46:main.c        **** 
  47:main.c        **** #define NUM_BOXES_NORM 2//for boxcar averaging.  Set to 1 for no averaging
  48:main.c        **** #define NUM_BOXES_STOIC 25//for near stoic oscillation mode
  49:main.c        **** 
  50:main.c        **** #define MAX_BOXES 25 //max boxes stored.
  51:main.c        **** 
  52:main.c        **** #define DAC_FACTOR 2550000UL/(LAMBDA_MAX-LAMBDA_MIN)//don't change: just a calculation pre-compile
  53:main.c        **** 
  54:main.c        **** //#define MAXPUMP_I 196 // maximum current value for pump (leanest). 
  55:main.c        **** #define MAXPUMP_I 329 // maximum current value for pump (leanest). 
  56:main.c        **** //see initilize_hardware.h for PWMPUMP_FREQ, if timer OCR1A = PWMPUMP_FREQ, DAC is maxed (5v)
  57:main.c        **** #define ZERO_CURRENT  97
  58:main.c        **** //#define MINPUMP_I 50 // minimum current value for pump. 
  59:main.c        ****  #define MINPUMP_I 0 // minimum current value for pump.
  60:main.c        **** //NOTE (based on manual pump power settings)
  61:main.c        **** // Above max, virt gnd is pushed up. 
  62:main.c        **** // Nothing happens below min.
  63:main.c        **** // 0 current is at 116// now 97 (r4=8.2k ZERO_CURRENT
  64:main.c        **** 
  65:main.c        **** //#define TARGET_NERNST 832 // lambda=1 value for nurnst, target for pump pid 
  66:main.c        **** #define TARGET_NERNST 821 // lambda=1 value for nurnst, target for pump pid
  67:main.c        **** #define TARGET_TEMP 237 
  68:main.c        **** #define P_temp    350//was 450
  69:main.c        **** #define I_temp    100//5
  70:main.c        **** #define D_temp    0//1
  71:main.c        **** 
  72:main.c        **** //#define P_pump    15
  73:main.c        **** //#define I_pump    74
  74:main.c        **** //#define D_pump    2
  75:main.c        **** 
  76:main.c        **** #define P_pump    5//
  77:main.c        **** #define I_pump    2
  78:main.c        **** #define D_pump    0
  79:main.c        **** 
  80:main.c        **** 
  81:main.c        **** //#define F_CPU 4000000UL
  82:main.c        **** //(in makefile)
  83:main.c        **** #define BAUD 9600UL
  84:main.c        **** #define UBRRVAL (F_CPU/(BAUD*16)-1)
  85:main.c        **** 
  86:main.c        **** 
  87:main.c        **** //test
  88:main.c        **** //for manual ip ramp:
  89:main.c        **** uint32_t IpCount = 0;
  90:main.c        **** uint16_t ipramp = 0;
  91:main.c        **** 
  92:main.c        **** //for slope determination of nurnst:
  93:main.c        **** #define NURNSTPOINTS 3 //number of points to track
  94:main.c        **** uint16_t nurnst_data[NURNSTPOINTS];
  95:main.c        **** 
  96:main.c        **** volatile uint16_t box_data[MAX_BOXES];
  97:main.c        **** //in pid.h, changed scalevalue to 1 since parampeters are now integers: K * 128
  98:main.c        **** 
  99:main.c        **** uint8_t heat_power;//global value fed to timer0 for heater pwm
 100:main.c        **** uint16_t ADC_data;//read the ADC into this
 101:main.c        **** 
 102:main.c        **** volatile uint16_t nurnst = 0;// value read from adc2 for the nernst cell w/o DC
 103:main.c        **** volatile uint16_t pump = 0;//measured voltage at pump
 104:main.c        **** uint16_t DC_val = 0;//value read from adc2 for the nernst cell w/DC
 105:main.c        **** 
 106:main.c        **** //int16_t IpumpVolts=0;//difference from above proportional to current flowing to pump.
 107:main.c        **** uint16_t measured_temperature;//measured temperature value. also known as Ri
 108:main.c        **** uint32_t zero_to_5_WB;//value applied to timer2 to make DAC output
 109:main.c        **** 
 110:main.c        **** uint8_t ramp_flag=0;// flag gets set once the startup temperature ramp is done
 111:main.c        **** uint8_t its_off;//flag to keep track of the heater pwm state
 112:main.c        **** volatile uint8_t ADC_flag;//keeps track in the ADC interrupt 
 113:main.c        **** volatile uint8_t charspot=0;//keeps track of the position of the numbers going into the string
 114:main.c        **** 
 115:main.c        **** volatile int8_t nspike = 0;//flag for nurnst spike detected
 116:main.c        **** volatile uint8_t near_stoic_flag = 1; //assume near stoic first
 117:main.c        **** volatile uint8_t cycle_counter = 0;
 118:main.c        **** volatile uint8_t cycles_no_flip = 0;//to time speed of nurnst oscillations near stoic
 119:main.c        **** volatile uint8_t flip = 0;//flag indicating transison of nurnst
 120:main.c        **** 
 121:main.c        **** ////////////////////////////////////////////////////////////////////////
 122:main.c        **** //for PID:
 123:main.c        **** uint8_t pidCounter; //True when PID control loop should run one time
 124:main.c        **** struct PID_DATA pidData_temp; //termperature PID structure of vars
 125:main.c        **** struct PID_DATA pidData_pump; //pump PID structure of vars
 126:main.c        **** ////////////////////////////////////////////////////////////////////////
 127:main.c        **** 
 128:main.c        **** 
 129:main.c        **** 
 130:main.c        **** /////function prototypes/////
 131:main.c        **** uint16_t readadc(void);
 132:main.c        **** 
 133:main.c        **** void do_things(void);
 134:main.c        **** void two(void);
 135:main.c        **** void three(void);
 136:main.c        **** void four(void);
 137:main.c        **** void six_1(void);
 138:main.c        **** void six_2(void);
 139:main.c        **** void six_3(void);
 140:main.c        **** void seven(void);
 141:main.c        **** void eight(void);
 142:main.c        **** 
 143:main.c        **** 
 144:main.c        **** void PID_heater(void);
 145:main.c        **** void PID_pump(uint16_t nurnst_val);
 146:main.c        **** int8_t nurnst_slope_tracker(uint16_t nurnstval);
 147:main.c        **** uint16_t boxcaravg(uint16_t new, uint8_t history);
 148:main.c        **** 
 149:main.c        **** 
 150:main.c        **** 
 151:main.c        **** ////Interrupt Service Routines
 152:main.c        **** ISR(ADC_vect)
 153:main.c        **** {
 154:main.c        **** ADC_data = readadc();
 155:main.c        **** 
 156:main.c        **** if (ADC_flag == 7)//
 157:main.c        **** {
 158:main.c        **** 	four();
 159:main.c        **** }	
 160:main.c        **** else if (ADC_flag == 2)
 161:main.c        **** {
 162:main.c        **** 	six_1();
 163:main.c        **** }
 164:main.c        **** else if (ADC_flag == 8)
 165:main.c        **** {
 166:main.c        **** 	six_2();
 167:main.c        **** }
 168:main.c        **** else if (ADC_flag == 9)
 169:main.c        **** {
 170:main.c        **** 	six_3();
 171:main.c        **** }	
 172:main.c        **** 
 173:main.c        **** else if (ADC_flag == 3)//nurnst
 174:main.c        **** {
 175:main.c        **** 	seven();
 176:main.c        **** }
 177:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 178:main.c        **** {
 179:main.c        **** 	eight();
 180:main.c        **** }
 181:main.c        **** 	else
 182:main.c        **** 	
 183:main.c        **** 	{
 184:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 185:main.c        **** 	}
 186:main.c        **** }
 187:main.c        **** ISR(TIMER0_OVF_vect)
 188:main.c        **** {		
 189:main.c        **** 	if (its_off==1)//pulse is off
 190:main.c        **** 	 {
 191:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 192:main.c        **** 		 its_off = 0;
 193:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 194:main.c        **** 		 if (newtimerval < 128)
 195:main.c        **** 		 {
 196:main.c        **** 			do_things();
 197:main.c        **** 		 }
 198:main.c        **** 		 TCNT0 = newtimerval;	 
 199:main.c        **** 	 }
 200:main.c        **** 	 else//pulse is on
 201:main.c        **** 	 {
 202:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 203:main.c        **** 		 its_off = 1; 
 204:main.c        **** 		 uint8_t newtimerval= (heat_power);
 205:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 206:main.c        **** 		 if (newtimerval < 128)
 207:main.c        **** 		 {
 208:main.c        **** 			do_things();
 209:main.c        **** 		 }
 210:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 211:main.c        **** 	 }
 212:main.c        **** 
 213:main.c        **** }
 214:main.c        **** 
 215:main.c        **** //////////////////////////////vvvvvvvvvvvvvvv MAIN  vvvvvvvvvvvvvvvvvvvvv//////////////////////////
 216:main.c        **** int main()
 217:main.c        **** {
 129               	.LM0:
 130               	.LFBB1:
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
 218:main.c        **** //set up all the pins as inputs and outputs
 219:main.c        **** /* 
 220:main.c        ****  * 	PC5 //outputs for R2R DAC/not used
 221:main.c        ****  * 	PC4
 222:main.c        ****  * 	PC3
 223:main.c        ****  *  PB5  
 224:main.c        ****  *  PB4
 225:main.c        ****  * 	PB0
 226:main.c        ****  * 
 227:main.c        ****  *  PD4  LED
 228:main.c        ****  * 
 229:main.c        ****  * Nernst DC connection: PB2
 230:main.c        ****  * nch mosfet for heater: PD5
 231:main.c        ****  * 
 232:main.c        ****  * PB1 = pump power OC1A timer out
 233:main.c        ****  * PB3 = output voltage OC2 timer output
 234:main.c        ****  *   //ADC:
 235:main.c        ****  * nernst V: 	adc2
 236:main.c        ****  * pump			adc0
 237:main.c        ****  *
 238:main.c        ****  */ 
 239:main.c        **** DDRC |= _BV(5)| _BV(4) | _BV(3);//six bit dac
 136               	.LM1:
 137 0000 84B3      		in r24,52-32
 138 0002 8863      		ori r24,lo8(56)
 139 0004 84BB      		out 52-32,r24
 240:main.c        **** DDRB |= _BV(5)| _BV(4) | _BV(0);//six bit dac
 141               	.LM2:
 142 0006 87B3      		in r24,55-32
 143 0008 8163      		ori r24,lo8(49)
 144 000a 87BB      		out 55-32,r24
 241:main.c        **** DDRD |= _BV(4);//LED
 146               	.LM3:
 147 000c 8C9A      		sbi 49-32,4
 242:main.c        **** 
 243:main.c        **** DDRD |= ( _BV(5));// mosfet for heater
 149               	.LM4:
 150 000e 8D9A      		sbi 49-32,5
 244:main.c        **** 
 245:main.c        **** ////setup uart:////
 246:main.c        **** cli();//  disable interrupts until things are set up
 152               	.LM5:
 153               	/* #APP */
 154               	 ;  246 "main.c" 1
 155 0010 F894      		cli
 156               	 ;  0 "" 2
 247:main.c        **** 	//init uart
 248:main.c        ****     /* set baud rate */
 249:main.c        ****    	UBRRH = (UBRRVAL >> 8);
 158               	.LM6:
 159               	/* #NOAPP */
 160 0012 10BC      		out 64-32,__zero_reg__
 250:main.c        ****    	UBRRL = (UBRRVAL & 0xff);
 162               	.LM7:
 163 0014 89E1      		ldi r24,lo8(25)
 164 0016 89B9      		out 41-32,r24
 251:main.c        ****     /* set frame format: 8 bit, no parity, 1 bit */
 252:main.c        ****     UCSRC |=  (1 << URSEL | 1 << UCSZ1 | 1 << UCSZ0);
 166               	.LM8:
 167 0018 80B5      		in r24,64-32
 168 001a 8668      		ori r24,lo8(-122)
 169 001c 80BD      		out 64-32,r24
 253:main.c        ****     UCSRB |= (1 << RXEN | 1 << TXEN | 1 << RXCIE);//enable receive, transmit, and receive complete 
 171               	.LM9:
 172 001e 8AB1      		in r24,42-32
 173 0020 8869      		ori r24,lo8(-104)
 174 0022 8AB9      		out 42-32,r24
 254:main.c        **** 
 255:main.c        **** //disable uart input, avoid Rx buffer overrun:
 256:main.c        **** UCSRB &= ~(1 << RXEN);
 176               	.LM10:
 177 0024 5498      		cbi 42-32,4
 257:main.c        **** UCSRB &= ~(1 << RXCIE);
 179               	.LM11:
 180 0026 5798      		cbi 42-32,7
 258:main.c        **** 
 259:main.c        **** setup_timer1();// pump control current dac on OC1A  
 182               	.LM12:
 183 0028 00D0      		rcall setup_timer1
 260:main.c        **** setup_timer2();//output 0-5v on OC2  
 185               	.LM13:
 186 002a 00D0      		rcall setup_timer2
 261:main.c        **** 	
 262:main.c        **** pid_Init(P_temp, I_temp, D_temp, &pidData_temp);//set up PID structure for temperature
 188               	.LM14:
 189 002c 8EE5      		ldi r24,lo8(350)
 190 002e 91E0      		ldi r25,hi8(350)
 191 0030 64E6      		ldi r22,lo8(100)
 192 0032 70E0      		ldi r23,hi8(100)
 193 0034 40E0      		ldi r20,lo8(0)
 194 0036 50E0      		ldi r21,hi8(0)
 195 0038 20E0      		ldi r18,lo8(pidData_temp)
 196 003a 30E0      		ldi r19,hi8(pidData_temp)
 197 003c 00D0      		rcall pid_Init
 263:main.c        **** pid_Init(P_pump, I_pump, D_pump, &pidData_pump);//set up PID structure for nernst
 199               	.LM15:
 200 003e 85E0      		ldi r24,lo8(5)
 201 0040 90E0      		ldi r25,hi8(5)
 202 0042 62E0      		ldi r22,lo8(2)
 203 0044 70E0      		ldi r23,hi8(2)
 204 0046 40E0      		ldi r20,lo8(0)
 205 0048 50E0      		ldi r21,hi8(0)
 206 004a 20E0      		ldi r18,lo8(pidData_pump)
 207 004c 30E0      		ldi r19,hi8(pidData_pump)
 208 004e 00D0      		rcall pid_Init
 264:main.c        **** sei();//enable interrupts
 210               	.LM16:
 211               	/* #APP */
 212               	 ;  264 "main.c" 1
 213 0050 7894      		sei
 214               	 ;  0 "" 2
 265:main.c        **** adc_init();
 216               	.LM17:
 217               	/* #NOAPP */
 218 0052 00D0      		rcall adc_init
 266:main.c        **** // ramp up heat:
 267:main.c        **** heat_power = 130;//initial time
 220               	.LM18:
 221 0054 82E8      		ldi r24,lo8(-126)
 222 0056 8093 0000 		sts heat_power,r24
 268:main.c        **** timer0init();
 224               	.LM19:
 225 005a 00D0      		rcall timer0init
 269:main.c        **** PORTD |= _BV(4);//LED on
 227               	.LM20:
 228 005c 949A      		sbi 50-32,4
 270:main.c        **** uart_putst("ramp temp\n");
 230               	.LM21:
 231 005e 80E0      		ldi r24,lo8(.LC1)
 232 0060 90E0      		ldi r25,hi8(.LC1)
 233 0062 00D0      		rcall uart_putst
 271:main.c        **** while (heat_power<200)
 235               	.LM22:
 236 0064 00C0      		rjmp .L2
 237               	.L3:
 272:main.c        **** {
 273:main.c        **** heat_power++;
 239               	.LM23:
 240 0066 8F5F      		subi r24,lo8(-(1))
 241 0068 8093 0000 		sts heat_power,r24
 242               	.LBB15:
 243               	.LBB16:
 245               	.Ltext1:
   1:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 247               	.LM24:
 248 006c 2FEB      		 ldi r18,lo8(119999)
 249 006e 34ED      	    ldi r19,hi8(119999)
 250 0070 41E0      	    ldi r20,hlo8(119999)
 251 0072 2150      	    1:subi r18,1
 252 0074 3040      	    sbci r19,0
 253 0076 4040      	    sbci r20,0
 254 0078 01F4      	    brne 1b
 255 007a 00C0      		rjmp .
 256 007c 0000      		nop
 257               	.LBE16:
 258               	.LBE15:
 260               	.Ltext2:
 274:main.c        **** _delay_ms(150);
 275:main.c        **** uart_put16dec(heat_power);
 262               	.LM25:
 263 007e 90E0      		ldi r25,lo8(0)
 264 0080 00D0      		rcall uart_put16dec
 276:main.c        **** uart_putch(',');
 266               	.LM26:
 267 0082 8CE2      		ldi r24,lo8(44)
 268 0084 00D0      		rcall uart_putch
 277:main.c        **** uart_putch(' ');
 270               	.LM27:
 271 0086 80E2      		ldi r24,lo8(32)
 272 0088 00D0      		rcall uart_putch
 273               	.L2:
 271:main.c        **** while (heat_power<200)
 275               	.LM28:
 276 008a 8091 0000 		lds r24,heat_power
 277 008e 883C      		cpi r24,lo8(-56)
 278 0090 00F0      		brlo .L3
 278:main.c        **** }
 279:main.c        **** uart_putch('\n');
 280               	.LM29:
 281 0092 8AE0      		ldi r24,lo8(10)
 282 0094 00D0      		rcall uart_putch
 280:main.c        **** ramp_flag=1;
 284               	.LM30:
 285 0096 81E0      		ldi r24,lo8(1)
 286 0098 8093 0000 		sts ramp_flag,r24
 287               	.L4:
 288 009c 00C0      		rjmp .L4
 290               	.Lscope1:
 291               		.text
 293               	.global	do_things
 295               	do_things:
 281:main.c        **** ///////////////////////
 282:main.c        **** while(1)
 283:main.c        **** 	{
 284:main.c        **** //most stuff handled in timer0 interrupt
 285:main.c        **** //Suggested: use a state machine, just read ADC data in the interrupt, and poll a flag to see if it
 286:main.c        **** 	}
 287:main.c        **** return 0;
 288:main.c        **** }
 289:main.c        **** //// end of main
 290:main.c        **** ///////////////////////////////////////////////////////// 
 291:main.c        **** //////vvvvvvvvvvvvvv functions vvvvvvvvvvvvvvvvv/////////
 292:main.c        **** /////////////////////////////////////////////////////////
 293:main.c        **** 
 294:main.c        **** void do_things(void)//do first adc
 295:main.c        **** {  
 297               	.LM31:
 298               	.LFBB2:
 299               	/* prologue: function */
 300               	/* frame size = 0 */
 301               	/* stack size = 0 */
 302               	.L__stack_usage = 0
 296:main.c        **** 	if (ramp_flag == 1)// startup temp ramp is finished 
 304               	.LM32:
 305 0000 8091 0000 		lds r24,ramp_flag
 306 0004 8130      		cpi r24,lo8(1)
 307 0006 01F4      		brne .L5
 297:main.c        **** 	{
 298:main.c        **** 		cycle_counter++;
 309               	.LM33:
 310 0008 8091 0000 		lds r24,cycle_counter
 311 000c 8F5F      		subi r24,lo8(-(1))
 312 000e 8093 0000 		sts cycle_counter,r24
 299:main.c        **** 		if (cycle_counter >3)
 314               	.LM34:
 315 0012 8091 0000 		lds r24,cycle_counter
 316 0016 8430      		cpi r24,lo8(4)
 317 0018 00F0      		brlo .L5
 318               	.LBB21:
 319               	.LBB22:
 300:main.c        **** 		{
 301:main.c        **** 			cycle_counter = 0;//reset
 321               	.LM35:
 322 001a 1092 0000 		sts cycle_counter,__zero_reg__
 323               	.LBB23:
 324               	.LBB24:
 326               	.Ltext3:
 165:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 328               	.LM36:
 329 001e 82E4      		 ldi r24,lo8(66)
 330 0020 8A95      	    1:dec r24
 331 0022 01F4      	    brne 1b
 332 0024 00C0      		rjmp .
 333               	.LBE24:
 334               	.LBE23:
 336               	.Ltext4:
 302:main.c        **** 			_delay_us(50);//maybe let things settle?
 303:main.c        **** 			ADC_flag = 7;//sets to run function after conversion
 338               	.LM37:
 339 0026 87E0      		ldi r24,lo8(7)
 340 0028 8093 0000 		sts ADC_flag,r24
 304:main.c        **** 			ADMUX =(192 + 1);//V refrence plus mux 
 342               	.LM38:
 343 002c 81EC      		ldi r24,lo8(-63)
 344 002e 87B9      		out 39-32,r24
 305:main.c        **** 			//use 192 for internal 2.5v ref//use 64 for avcc as vref			
 306:main.c        **** 			ADCSRA |= _BV(ADSC);// starts  conversion
 346               	.LM39:
 347 0030 369A      		sbi 38-32,6
 348               	.L5:
 349 0032 0895      		ret
 350               	.LBE22:
 351               	.LBE21:
 353               	.Lscope2:
 355               	.global	__vector_9
 357               	__vector_9:
 188:main.c        **** {		
 359               	.LM40:
 360               	.LFBB3:
 361 0034 1F92      		push r1
 362 0036 0F92      		push r0
 363 0038 0FB6      		in r0,__SREG__
 364 003a 0F92      		push r0
 365 003c 1124      		clr __zero_reg__
 366 003e 2F93      		push r18
 367 0040 3F93      		push r19
 368 0042 4F93      		push r20
 369 0044 5F93      		push r21
 370 0046 6F93      		push r22
 371 0048 7F93      		push r23
 372 004a 8F93      		push r24
 373 004c 9F93      		push r25
 374 004e AF93      		push r26
 375 0050 BF93      		push r27
 376 0052 CF93      		push r28
 377 0054 EF93      		push r30
 378 0056 FF93      		push r31
 379               	/* prologue: Signal */
 380               	/* frame size = 0 */
 381               	/* stack size = 16 */
 382               	.L__stack_usage = 16
 189:main.c        **** 	if (its_off==1)//pulse is off
 384               	.LM41:
 385 0058 8091 0000 		lds r24,its_off
 386 005c 8130      		cpi r24,lo8(1)
 387 005e 01F4      		brne .L8
 388               	.LBB25:
 191:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 390               	.LM42:
 391 0060 959A      		sbi 50-32,5
 192:main.c        **** 		 its_off = 0;
 393               	.LM43:
 394 0062 1092 0000 		sts its_off,__zero_reg__
 193:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 396               	.LM44:
 397 0066 C091 0000 		lds r28,heat_power
 398 006a C095      		com r28
 399 006c 00C0      		rjmp .L14
 400               	.L8:
 401               	.LBE25:
 402               	.LBB26:
 202:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 404               	.LM45:
 405 006e 9598      		cbi 50-32,5
 203:main.c        **** 		 its_off = 1; 
 407               	.LM46:
 408 0070 81E0      		ldi r24,lo8(1)
 409 0072 8093 0000 		sts its_off,r24
 204:main.c        **** 		 uint8_t newtimerval= (heat_power);
 411               	.LM47:
 412 0076 C091 0000 		lds r28,heat_power
 205:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 414               	.LM48:
 415 007a C2BF      		out 82-32,r28
 416               	.L14:
 206:main.c        **** 		 if (newtimerval < 128)
 418               	.LM49:
 419 007c C7FF      		sbrs r28,7
 208:main.c        **** 			do_things();
 421               	.LM50:
 422 007e 00D0      		rcall do_things
 423               	.L11:
 210:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 425               	.LM51:
 426 0080 C2BF      		out 82-32,r28
 427               	/* epilogue start */
 428               	.LBE26:
 213:main.c        **** }
 430               	.LM52:
 431 0082 FF91      		pop r31
 432 0084 EF91      		pop r30
 433 0086 CF91      		pop r28
 434 0088 BF91      		pop r27
 435 008a AF91      		pop r26
 436 008c 9F91      		pop r25
 437 008e 8F91      		pop r24
 438 0090 7F91      		pop r23
 439 0092 6F91      		pop r22
 440 0094 5F91      		pop r21
 441 0096 4F91      		pop r20
 442 0098 3F91      		pop r19
 443 009a 2F91      		pop r18
 444 009c 0F90      		pop r0
 445 009e 0FBE      		out __SREG__,r0
 446 00a0 0F90      		pop r0
 447 00a2 1F90      		pop r1
 448 00a4 1895      		reti
 456               	.Lscope3:
 458               	.global	four
 460               	four:
 307:main.c        **** 		}
 308:main.c        **** 	}	
 309:main.c        **** }
 310:main.c        **** void four(void)//record aux adc 1, mux for pump current
 311:main.c        **** { 
 462               	.LM53:
 463               	.LFBB4:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 312:main.c        **** 	charspot = put_in_string(ADC_data,'\0',charspot);//puts data in big string and sends back new char
 469               	.LM54:
 470 00a6 4091 0000 		lds r20,charspot
 471 00aa 8091 0000 		lds r24,ADC_data
 472 00ae 9091 0000 		lds r25,ADC_data+1
 473 00b2 60E0      		ldi r22,lo8(0)
 474 00b4 00D0      		rcall put_in_string
 475 00b6 8093 0000 		sts charspot,r24
 313:main.c        **** 	ADC_flag = 2;
 477               	.LM55:
 478 00ba 82E0      		ldi r24,lo8(2)
 479 00bc 8093 0000 		sts ADC_flag,r24
 314:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 481               	.LM56:
 482 00c0 80EC      		ldi r24,lo8(-64)
 483 00c2 87B9      		out 39-32,r24
 315:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 485               	.LM57:
 486 00c4 369A      		sbi 38-32,6
 487               	/* epilogue start */
 316:main.c        **** }	
 489               	.LM58:
 490 00c6 0895      		ret
 492               	.Lscope4:
 494               	.global	six_1
 496               	six_1:
 317:main.c        **** 
 318:main.c        **** void six_1(void)//measures pump current 1/3 sample
 319:main.c        **** {	
 498               	.LM59:
 499               	.LFBB5:
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 320:main.c        **** 	pump = ADC_data;
 505               	.LM60:
 506 00c8 8091 0000 		lds r24,ADC_data
 507 00cc 9091 0000 		lds r25,ADC_data+1
 508 00d0 9093 0000 		sts pump+1,r25
 509 00d4 8093 0000 		sts pump,r24
 321:main.c        **** 	ADC_flag = 8;	
 511               	.LM61:
 512 00d8 88E0      		ldi r24,lo8(8)
 513 00da 8093 0000 		sts ADC_flag,r24
 322:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 515               	.LM62:
 516 00de 369A      		sbi 38-32,6
 517               	/* epilogue start */
 323:main.c        **** }
 519               	.LM63:
 520 00e0 0895      		ret
 522               	.Lscope5:
 524               	.global	six_2
 526               	six_2:
 324:main.c        **** 
 325:main.c        **** void six_2(void)//measures pump current 2/3
 326:main.c        **** {	
 528               	.LM64:
 529               	.LFBB6:
 530               	/* prologue: function */
 531               	/* frame size = 0 */
 532               	/* stack size = 0 */
 533               	.L__stack_usage = 0
 327:main.c        **** 	pump = pump + ADC_data;
 535               	.LM65:
 536 00e2 8091 0000 		lds r24,pump
 537 00e6 9091 0000 		lds r25,pump+1
 538 00ea 2091 0000 		lds r18,ADC_data
 539 00ee 3091 0000 		lds r19,ADC_data+1
 540 00f2 820F      		add r24,r18
 541 00f4 931F      		adc r25,r19
 542 00f6 9093 0000 		sts pump+1,r25
 543 00fa 8093 0000 		sts pump,r24
 328:main.c        **** 	ADC_flag = 9;	
 545               	.LM66:
 546 00fe 89E0      		ldi r24,lo8(9)
 547 0100 8093 0000 		sts ADC_flag,r24
 329:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 549               	.LM67:
 550 0104 369A      		sbi 38-32,6
 551               	/* epilogue start */
 330:main.c        **** }
 553               	.LM68:
 554 0106 0895      		ret
 556               	.Lscope6:
 558               	.global	six_3
 560               	six_3:
 331:main.c        **** 
 332:main.c        **** void six_3(void)//measures pump current 3/3
 333:main.c        **** {	
 562               	.LM69:
 563               	.LFBB7:
 564               	/* prologue: function */
 565               	/* frame size = 0 */
 566               	/* stack size = 0 */
 567               	.L__stack_usage = 0
 334:main.c        **** 	pump = pump + ADC_data;
 569               	.LM70:
 570 0108 8091 0000 		lds r24,pump
 571 010c 9091 0000 		lds r25,pump+1
 572 0110 2091 0000 		lds r18,ADC_data
 573 0114 3091 0000 		lds r19,ADC_data+1
 574 0118 820F      		add r24,r18
 575 011a 931F      		adc r25,r19
 576 011c 9093 0000 		sts pump+1,r25
 577 0120 8093 0000 		sts pump,r24
 335:main.c        **** 	pump = pump/3;
 579               	.LM71:
 580 0124 8091 0000 		lds r24,pump
 581 0128 9091 0000 		lds r25,pump+1
 582 012c 63E0      		ldi r22,lo8(3)
 583 012e 70E0      		ldi r23,hi8(3)
 584 0130 00D0      		rcall __udivmodhi4
 585 0132 7093 0000 		sts pump+1,r23
 586 0136 6093 0000 		sts pump,r22
 336:main.c        **** 	//charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char s
 337:main.c        **** 	ADC_flag = 3;	
 588               	.LM72:
 589 013a 83E0      		ldi r24,lo8(3)
 590 013c 8093 0000 		sts ADC_flag,r24
 338:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 592               	.LM73:
 593 0140 82EC      		ldi r24,lo8(-62)
 594 0142 87B9      		out 39-32,r24
 339:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 596               	.LM74:
 597 0144 369A      		sbi 38-32,6
 598               	/* epilogue start */
 340:main.c        **** }
 600               	.LM75:
 601 0146 0895      		ret
 603               	.Lscope7:
 605               	.global	readadc
 607               	readadc:
 341:main.c        **** 
 342:main.c        **** void seven(void)//measure nurnst 
 343:main.c        **** {
 344:main.c        **** 	nurnst = ADC_data;
 345:main.c        **** 	charspot = put_in_string(nurnst,'\0',charspot);//puts data in big string
 346:main.c        **** 	//nspike = nurnst_slope_tracker(nurnst);
 347:main.c        **** 	//charspot = put_in_string(near_stoic_flag,'\0',charspot);//puts data in big string
 348:main.c        **** 	PID_pump(nurnst);//run PID on pump and update pump pwm.
 349:main.c        **** 	ADC_flag = 4;
 350:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 351:main.c        **** 	DDRB |= _BV(2);// dc for temperature measurment
 352:main.c        **** 	_delay_us(20);
 353:main.c        **** 	PORTB |= _BV(2);//DC on
 354:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 355:main.c        **** }
 356:main.c        **** 
 357:main.c        **** void eight(void)
 358:main.c        **** {
 359:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 360:main.c        **** 	_delay_us(20);
 361:main.c        **** 	DDRB &=~ _BV(2);//hiZ
 362:main.c        **** 	DC_val = ADC_data;
 363:main.c        **** //	charspot = put_in_string(DC_val,'d',charspot);//puts data in big string
 364:main.c        **** 	ADC_flag = 0;	
 365:main.c        **** 	////do calculations and PIDs
 366:main.c        **** 	measured_temperature = (DC_val - nurnst);
 367:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 368:main.c        **** 		{
 369:main.c        **** 		measured_temperature = (255 - measured_temperature);
 370:main.c        **** 		}
 371:main.c        **** 	else
 372:main.c        **** 		{
 373:main.c        **** 		measured_temperature =0;
 374:main.c        **** 		}
 375:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 376:main.c        **** 		{
 377:main.c        **** 		PORTD &=~ _BV(4);//LED off
 378:main.c        **** 		}
 379:main.c        **** 	else
 380:main.c        **** 		{
 381:main.c        **** 		PORTD |= _BV(4);//LED on
 382:main.c        **** 		}
 383:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 384:main.c        **** 	
 385:main.c        **** 	//pump current filtering:
 386:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 387:main.c        **** 	if (near_stoic_flag == 1)
 388:main.c        **** 	{
 389:main.c        **** 		pump = boxcaravg(pump,100);//average pump current 100 points
 390:main.c        **** 	}
 391:main.c        **** 	else
 392:main.c        **** 	{
 393:main.c        **** 		pump = boxcaravg(pump,3);//average pump current 3 points
 394:main.c        **** 	}
 395:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 396:main.c        **** 	
 397:main.c        **** 	//calculate lambda output from Look Up Table:
 398:main.c        **** 	struct two_col{
 399:main.c        **** 		uint16_t x;
 400:main.c        **** 		uint16_t y;
 401:main.c        **** 	}; 
 402:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 403:main.c        **** 		{1,0},
 404:main.c        **** 		{480,68},
 405:main.c        **** 		{570,80},
 406:main.c        **** 		{610,85},
 407:main.c        **** 		{650,90},
 408:main.c        **** 		{690,100},
 409:main.c        **** 		{700,110},
 410:main.c        **** 		{750,143},
 411:main.c        **** 		{795,170},
 412:main.c        **** 		{810,242},
 413:main.c        **** 		{845,20200},
 414:main.c        **** 		{1024,26000},
 415:main.c        **** 		};
 416:main.c        **** 	uint8_t n = 12;//number of rows in table	
 417:main.c        **** 	uint32_t lambda=0;
 418:main.c        **** 	//out of range check:
 419:main.c        **** 	if (pump<lambda_curve[0].x)//smaller than the lowest value in LOT
 420:main.c        **** 	{lambda = lambda_curve[0].y;}
 421:main.c        **** 	else if (pump>lambda_curve[n-1].x)//larger than the highest value in the LOT
 422:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 423:main.c        **** 	//lookup in table, interpolate
 424:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 425:main.c        **** 	{
 426:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 427:main.c        **** 		{
 428:main.c        **** 			uint16_t diffx = pump - lambda_curve[i].x; //difference between the pump value and the x value i
 429:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 430:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 431:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 432:main.c        **** 		}
 433:main.c        **** 	}
 434:main.c        **** 	lambda = lambda + POSOFFSET;
 435:main.c        **** 	lambda = lambda - NEGOFFSET;
 436:main.c        **** 	
 437:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 438:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 439:main.c        **** 	{
 440:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 441:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 442:main.c        **** 	}
 443:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 444:main.c        **** 	else {zero_to_5_WB = 0;}
 445:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 446:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 447:main.c        **** 	
 448:main.c        **** 
 449:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 450:main.c        **** //	charspot = put_in_string(heat_power,'h',charspot);//puts data in big string
 451:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 452:main.c        **** }
 453:main.c        **** 	
 454:main.c        **** uint16_t readadc(void)
 455:main.c        **** {
 609               	.LM76:
 610               	.LFBB8:
 611               	/* prologue: function */
 612               	/* frame size = 0 */
 613               	/* stack size = 0 */
 614               	.L__stack_usage = 0
 456:main.c        **** 	uint8_t adcDataL = ADCL;
 616               	.LM77:
 617 0148 84B1      		in r24,36-32
 457:main.c        ****     uint8_t adcDataH = ADCH;
 619               	.LM78:
 620 014a 95B1      		in r25,37-32
 458:main.c        ****     uint16_t adcData = 0;
 459:main.c        ****     adcData = adcData | adcDataH;
 460:main.c        ****     adcData = adcData << 8;//left shift 8 spots
 622               	.LM79:
 623 014c 392F      		mov r19,r25
 624 014e 20E0      		ldi r18,lo8(0)
 461:main.c        ****     adcData = adcData | adcDataL;
 626               	.LM80:
 627 0150 90E0      		ldi r25,lo8(0)
 628 0152 822B      		or r24,r18
 629 0154 932B      		or r25,r19
 630               	/* epilogue start */
 462:main.c        ****     return adcData;
 463:main.c        **** }
 632               	.LM81:
 633 0156 0895      		ret
 639               	.Lscope8:
 641               	.global	PID_heater
 643               	PID_heater:
 464:main.c        **** 
 465:main.c        **** void PID_heater(void)
 466:main.c        **** {
 645               	.LM82:
 646               	.LFBB9:
 647               	/* prologue: function */
 648               	/* frame size = 0 */
 649               	/* stack size = 0 */
 650               	.L__stack_usage = 0
 467:main.c        **** 	int32_t calculated = pid_Controller(TARGET_TEMP, measured_temperature, &pidData_temp);  // for tem
 652               	.LM83:
 653 0158 6091 0000 		lds r22,measured_temperature
 654 015c 7091 0000 		lds r23,measured_temperature+1
 655 0160 8DEE      		ldi r24,lo8(237)
 656 0162 90E0      		ldi r25,hi8(237)
 657 0164 40E0      		ldi r20,lo8(pidData_temp)
 658 0166 50E0      		ldi r21,hi8(pidData_temp)
 659 0168 00D0      		rcall pid_Controller
 660 016a AA27      		clr r26
 661 016c 97FD      		sbrc r25,7
 662 016e A095      		com r26
 663 0170 BA2F      		mov r27,r26
 468:main.c        **** 
 469:main.c        **** 	if ((calculated) > 255 )
 665               	.LM84:
 666 0172 8F3F      		cpi r24,lo8(255)
 667 0174 9105      		cpc r25,__zero_reg__
 668 0176 A105      		cpc r26,__zero_reg__
 669 0178 B105      		cpc r27,__zero_reg__
 670 017a 01F0      		breq .L21
 671 017c 04F0      		brlt .L21
 470:main.c        **** 	{
 471:main.c        **** 		heat_power = 255 ;
 673               	.LM85:
 674 017e 8FEF      		ldi r24,lo8(-1)
 675 0180 00C0      		rjmp .L23
 676               	.L21:
 472:main.c        **** 	}
 473:main.c        **** 	else if ((calculated) < 0 )
 678               	.LM86:
 679 0182 B7FF      		sbrs r27,7
 680 0184 00C0      		rjmp .L23
 474:main.c        **** 	{
 475:main.c        **** 		heat_power = 0 ;
 682               	.LM87:
 683 0186 1092 0000 		sts heat_power,__zero_reg__
 684 018a 0895      		ret
 685               	.L23:
 476:main.c        **** 	}
 477:main.c        **** 	else
 478:main.c        **** 	{
 479:main.c        **** 		heat_power =(calculated);
 687               	.LM88:
 688 018c 8093 0000 		sts heat_power,r24
 689 0190 0895      		ret
 694               	.Lscope9:
 697               	.global	PID_pump
 699               	PID_pump:
 480:main.c        **** 	}
 481:main.c        **** 
 482:main.c        **** }
 483:main.c        **** 
 484:main.c        **** void PID_pump(uint16_t nurnst_val)
 485:main.c        **** {
 701               	.LM89:
 702               	.LFBB10:
 703               	/* prologue: function */
 704               	/* frame size = 0 */
 705               	/* stack size = 0 */
 706               	.L__stack_usage = 0
 486:main.c        **** 	int32_t pumpV =  ( pid_Controller(TARGET_NERNST, nurnst, &pidData_pump) );  // PID
 708               	.LM90:
 709 0192 6091 0000 		lds r22,nurnst
 710 0196 7091 0000 		lds r23,nurnst+1
 711 019a 85E3      		ldi r24,lo8(821)
 712 019c 93E0      		ldi r25,hi8(821)
 713 019e 40E0      		ldi r20,lo8(pidData_pump)
 714 01a0 50E0      		ldi r21,hi8(pidData_pump)
 715 01a2 00D0      		rcall pid_Controller
 716 01a4 AA27      		clr r26
 717 01a6 97FD      		sbrc r25,7
 718 01a8 A095      		com r26
 719 01aa BA2F      		mov r27,r26
 487:main.c        **** 	pumpV = pumpV + ZERO_CURRENT;// is zero current.
 721               	.LM91:
 722 01ac 8F59      		subi r24,lo8(-(97))
 723 01ae 9F4F      		sbci r25,hi8(-(97))
 724 01b0 AF4F      		sbci r26,hlo8(-(97))
 725 01b2 BF4F      		sbci r27,hhi8(-(97))
 488:main.c        **** /*	
 489:main.c        **** 	///check if needs to enter near stoic region://///////
 490:main.c        **** 	#define HI_NEAR 160// settings for pump V
 491:main.c        **** 	#define LO_NEAR 88
 492:main.c        **** 	#define ADD_LIMIT 0
 493:main.c        **** 	#define MAX_FLIP_COUNTS 6
 494:main.c        **** //	if( (pumpV < (HI_NEAR+ADD_LIMIT))  &&  (pumpV>(LO_NEAR-ADD_LIMIT))  &&  (near_stoic_flag ==2)&&(
 495:main.c        **** //	{//pumpV is now below HI_NEAR+ADD_LIMIT, was lean, heading to rich fast.
 496:main.c        **** 	if( (pumpV < (HI_NEAR+ADD_LIMIT))  &&  (pumpV>(LO_NEAR-ADD_LIMIT))  )
 497:main.c        **** 	{//pumpV is now below HI_NEAR+ADD_LIMIT, was lean, 
 498:main.c        **** 		near_stoic_flag =1;//now in near stoic region
 499:main.c        **** 		pumpV = LO_NEAR;	//set pump to close to lower limit of near stoic
 500:main.c        **** 		cycles_no_flip = 0;//start counter
 501:main.c        **** 		flip = 0; // set to rich side
 502:main.c        **** 	}
 503:main.c        **** //	if( (pumpV>(LO_NEAR-ADD_LIMIT))  &&  (pumpV<(HI_NEAR+ADD_LIMIT)) && (near_stoic_flag ==0)&&(nspi
 504:main.c        **** //	{//pumpV is now above LOW_NEAR-ADD_LIMIT,      below hi limit       was rich, heading to lean fa
 505:main.c        **** 	if( (pumpV>(LO_NEAR-ADD_LIMIT))  &&  (pumpV<(HI_NEAR+ADD_LIMIT)) )
 506:main.c        **** 	{//pumpV is now above LOW_NEAR-ADD_LIMIT,      below hi limit   
 507:main.c        **** 		near_stoic_flag =1;//now in near stoic region
 508:main.c        **** 		pumpV = HI_NEAR;	//set pump to close to lower limit of near stoic
 509:main.c        **** 		cycles_no_flip = 0;//start counter
 510:main.c        **** 		flip = 1; // lean side
 511:main.c        **** 	}
 512:main.c        **** 	
 513:main.c        **** 	///if it is in near stoic region
 514:main.c        **** 	if (near_stoic_flag ==1)
 515:main.c        **** 	{
 516:main.c        **** 		//check for flip. If flipped: toggle pumpV and reset flip counter.
 517:main.c        **** 		if(  (pumpV ==LO_NEAR)  &&  (flip == 0) && (nurnst < TARGET_NERNST ) )
 518:main.c        **** 			 //pumping O2 in		 was rich	    now lean
 519:main.c        **** 		{
 520:main.c        **** 			pumpV = HI_NEAR;//change pump
 521:main.c        **** 			cycles_no_flip = 0;//restart counter
 522:main.c        **** 		}
 523:main.c        **** 		
 524:main.c        **** 		if(  (pumpV ==HI_NEAR)  &&  (flip == 1) && (nurnst > TARGET_NERNST) )
 525:main.c        **** 			 //pumping O2 out		 was lean	    now rich
 526:main.c        **** 		{
 527:main.c        **** 			pumpV = LO_NEAR;//change pump
 528:main.c        **** 			cycles_no_flip = 0;//restart counter
 529:main.c        **** 		}	
 530:main.c        **** 		else{cycles_no_flip++;}//no flip, increment no_flip counter
 531:main.c        **** 		
 532:main.c        **** 		if (cycles_no_flip >MAX_FLIP_COUNTS)//if flip counter too high, release from near stoic in proper
 533:main.c        **** 		{
 534:main.c        **** 			cycles_no_flip = 0;
 535:main.c        **** 			if(pumpV == HI_NEAR) 
 536:main.c        **** 			{ 
 537:main.c        **** 				pumpV = HI_NEAR+ADD_LIMIT;
 538:main.c        **** 				near_stoic_flag = 2; 
 539:main.c        **** 			}
 540:main.c        **** 			else //pumpV == LO_NEAR
 541:main.c        **** 			{ 
 542:main.c        **** 				pumpV = LO_NEAR-ADD_LIMIT;
 543:main.c        **** 				near_stoic_flag = 0;
 544:main.c        **** 			}
 545:main.c        **** 			//set near_stoic flag to 0 or 2 (0=rich, 2=lean)
 546:main.c        **** 		}
 547:main.c        **** 	}
 548:main.c        **** */	
 549:main.c        **** //apply calculated to pump dac timer
 550:main.c        **** if ((pumpV) > MAXPUMP_I)
 727               	.LM92:
 728 01b4 8A34      		cpi r24,lo8(330)
 729 01b6 21E0      		ldi r18,hi8(330)
 730 01b8 9207      		cpc r25,r18
 731 01ba 20E0      		ldi r18,hlo8(330)
 732 01bc A207      		cpc r26,r18
 733 01be 20E0      		ldi r18,hhi8(330)
 734 01c0 B207      		cpc r27,r18
 735 01c2 04F0      		brlt .L25
 551:main.c        **** 	{
 552:main.c        **** 		OCR1A = MAXPUMP_I;
 737               	.LM93:
 738 01c4 89E4      		ldi r24,lo8(329)
 739 01c6 91E0      		ldi r25,hi8(329)
 740 01c8 00C0      		rjmp .L27
 741               	.L25:
 553:main.c        **** 	}
 554:main.c        **** else if ((pumpV) < MINPUMP_I)
 743               	.LM94:
 744 01ca B7FF      		sbrs r27,7
 745 01cc 00C0      		rjmp .L27
 555:main.c        **** 	{
 556:main.c        **** 		OCR1A = MINPUMP_I;
 747               	.LM95:
 748 01ce 1BBC      		out 74+1-32,__zero_reg__
 749 01d0 1ABC      		out 74-32,__zero_reg__
 750 01d2 00C0      		rjmp .L26
 751               	.L27:
 557:main.c        **** 	}
 558:main.c        **** 	else
 559:main.c        **** 	{
 560:main.c        **** 		OCR1A =(pumpV);
 753               	.LM96:
 754 01d4 9BBD      		out 74+1-32,r25
 755 01d6 8ABD      		out 74-32,r24
 756               	.L26:
 561:main.c        **** 	}
 562:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string	
 758               	.LM97:
 759 01d8 8AB5      		in r24,74-32
 760 01da 9BB5      		in r25,74+1-32
 761 01dc 4091 0000 		lds r20,charspot
 762 01e0 60E0      		ldi r22,lo8(0)
 763 01e2 00D0      		rcall put_in_string
 764 01e4 8093 0000 		sts charspot,r24
 765               	/* epilogue start */
 563:main.c        **** }
 767               	.LM98:
 768 01e8 0895      		ret
 770               	.Lscope10:
 772               	.global	seven
 774               	seven:
 343:main.c        **** {
 776               	.LM99:
 777               	.LFBB11:
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 0 */
 781               	.L__stack_usage = 0
 344:main.c        **** 	nurnst = ADC_data;
 783               	.LM100:
 784 01ea 8091 0000 		lds r24,ADC_data
 785 01ee 9091 0000 		lds r25,ADC_data+1
 786 01f2 9093 0000 		sts nurnst+1,r25
 787 01f6 8093 0000 		sts nurnst,r24
 345:main.c        **** 	charspot = put_in_string(nurnst,'\0',charspot);//puts data in big string
 789               	.LM101:
 790 01fa 8091 0000 		lds r24,nurnst
 791 01fe 9091 0000 		lds r25,nurnst+1
 792 0202 4091 0000 		lds r20,charspot
 793 0206 60E0      		ldi r22,lo8(0)
 794 0208 00D0      		rcall put_in_string
 795 020a 8093 0000 		sts charspot,r24
 348:main.c        **** 	PID_pump(nurnst);//run PID on pump and update pump pwm.
 797               	.LM102:
 798 020e 8091 0000 		lds r24,nurnst
 799 0212 9091 0000 		lds r25,nurnst+1
 800 0216 00D0      		rcall PID_pump
 349:main.c        **** 	ADC_flag = 4;
 802               	.LM103:
 803 0218 84E0      		ldi r24,lo8(4)
 804 021a 8093 0000 		sts ADC_flag,r24
 350:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 806               	.LM104:
 807 021e 82EC      		ldi r24,lo8(-62)
 808 0220 87B9      		out 39-32,r24
 351:main.c        **** 	DDRB |= _BV(2);// dc for temperature measurment
 810               	.LM105:
 811 0222 BA9A      		sbi 55-32,2
 812               	.LBB27:
 813               	.LBB28:
 815               	.Ltext5:
 817               	.LM106:
 818 0224 8AE1      		 ldi r24,lo8(26)
 819 0226 8A95      	    1:dec r24
 820 0228 01F4      	    brne 1b
 821 022a 00C0      		rjmp .
 822               	.LBE28:
 823               	.LBE27:
 825               	.Ltext6:
 353:main.c        **** 	PORTB |= _BV(2);//DC on
 827               	.LM107:
 828 022c C29A      		sbi 56-32,2
 354:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 830               	.LM108:
 831 022e 369A      		sbi 38-32,6
 832               	/* epilogue start */
 355:main.c        **** }
 834               	.LM109:
 835 0230 0895      		ret
 837               	.Lscope11:
 840               	.global	nurnst_slope_tracker
 842               	nurnst_slope_tracker:
 564:main.c        **** 
 565:main.c        **** int8_t nurnst_slope_tracker(uint16_t nurnstval)		
 566:main.c        **** {
 844               	.LM110:
 845               	.LFBB12:
 846 0232 CF93      		push r28
 847 0234 DF93      		push r29
 848               	/* prologue: function */
 849               	/* frame size = 0 */
 850               	/* stack size = 2 */
 851               	.L__stack_usage = 2
 852               	.LBB29:
 567:main.c        **** 	//running array: shift points, in latest value
 568:main.c        **** 	for (uint8_t i = 0; i<(NURNSTPOINTS-1); i++)//shift points
 569:main.c        **** 	{
 570:main.c        **** 		nurnst_data[i]=nurnst_data[i+1];
 854               	.LM111:
 855 0236 2091 0000 		lds r18,nurnst_data+2
 856 023a 3091 0000 		lds r19,nurnst_data+2+1
 857 023e 3093 0000 		sts nurnst_data+1,r19
 858 0242 2093 0000 		sts nurnst_data,r18
 859 0246 2091 0000 		lds r18,nurnst_data+4
 860 024a 3091 0000 		lds r19,nurnst_data+4+1
 861 024e 3093 0000 		sts nurnst_data+2+1,r19
 862 0252 2093 0000 		sts nurnst_data+2,r18
 863               	.LBE29:
 571:main.c        **** 	}
 572:main.c        **** 	nurnst_data[NURNSTPOINTS-1] = nurnstval;//put in latest value
 865               	.LM112:
 866 0256 9093 0000 		sts nurnst_data+4+1,r25
 867 025a 8093 0000 		sts nurnst_data+4,r24
 868 025e C0E0      		ldi r28,lo8(nurnst_data)
 869 0260 D0E0      		ldi r29,hi8(nurnst_data)
 870 0262 40E0      		ldi r20,lo8(0)
 871 0264 50E0      		ldi r21,hi8(0)
 573:main.c        **** 	//calculate sums for least squares:
 574:main.c        **** 	int8_t SUMx = 0; 
 575:main.c        **** 	int16_t SUMy =0;
 576:main.c        **** 	int16_t SUMxy = 0; 
 577:main.c        **** 	int16_t SUMxx  = 0;
 873               	.LM113:
 874 0266 A0E0      		ldi r26,lo8(0)
 875 0268 B0E0      		ldi r27,hi8(0)
 576:main.c        **** 	int16_t SUMxy = 0; 
 877               	.LM114:
 878 026a E0E0      		ldi r30,lo8(0)
 879 026c F0E0      		ldi r31,hi8(0)
 575:main.c        **** 	int16_t SUMy =0;
 881               	.LM115:
 882 026e 60E0      		ldi r22,lo8(0)
 883 0270 70E0      		ldi r23,hi8(0)
 884               	.L30:
 885               	.LBB30:
 578:main.c        **** 	for (uint8_t i = 0; i<(NURNSTPOINTS); i++)//SUMx
 579:main.c        **** 	{
 580:main.c        **** 		SUMx = SUMx+i;
 581:main.c        **** 		SUMy = SUMy+nurnst_data[i];
 887               	.LM116:
 888 0272 8991      		ld r24,Y+
 889 0274 9991      		ld r25,Y+
 890 0276 680F      		add r22,r24
 891 0278 791F      		adc r23,r25
 582:main.c        **** 		SUMxy = SUMxy+(i*nurnst_data[i]);
 893               	.LM117:
 894 027a 849F      		mul r24,r20
 895 027c 9001      		movw r18,r0
 896 027e 859F      		mul r24,r21
 897 0280 300D      		add r19,r0
 898 0282 949F      		mul r25,r20
 899 0284 300D      		add r19,r0
 900 0286 1124      		clr r1
 901 0288 E20F      		add r30,r18
 902 028a F31F      		adc r31,r19
 583:main.c        **** 		SUMxx = SUMxx+(i*i);
 904               	.LM118:
 905 028c 449F      		mul r20,r20
 906 028e C001      		movw r24,r0
 907 0290 459F      		mul r20,r21
 908 0292 900D      		add r25,r0
 909 0294 549F      		mul r21,r20
 910 0296 900D      		add r25,r0
 911 0298 1124      		clr r1
 912 029a A80F      		add r26,r24
 913 029c B91F      		adc r27,r25
 914 029e 4F5F      		subi r20,lo8(-(1))
 915 02a0 5F4F      		sbci r21,hi8(-(1))
 578:main.c        **** 	for (uint8_t i = 0; i<(NURNSTPOINTS); i++)//SUMx
 917               	.LM119:
 918 02a2 4330      		cpi r20,3
 919 02a4 5105      		cpc r21,__zero_reg__
 920 02a6 01F4      		brne .L30
 921               	.LBE30:
 584:main.c        **** 	}
 585:main.c        **** 	int16_t slope = ((SUMx*SUMy)- NURNSTPOINTS*SUMxy) / ( (SUMx*SUMx) - NURNSTPOINTS*SUMxx);
 923               	.LM120:
 924 02a8 CB01      		movw r24,r22
 925 02aa 880F      		lsl r24
 926 02ac 991F      		rol r25
 927 02ae 860F      		add r24,r22
 928 02b0 971F      		adc r25,r23
 929 02b2 9F01      		movw r18,r30
 930 02b4 220F      		lsl r18
 931 02b6 331F      		rol r19
 932 02b8 2E0F      		add r18,r30
 933 02ba 3F1F      		adc r19,r31
 934 02bc 821B      		sub r24,r18
 935 02be 930B      		sbc r25,r19
 936 02c0 BD01      		movw r22,r26
 937 02c2 660F      		lsl r22
 938 02c4 771F      		rol r23
 939 02c6 6A0F      		add r22,r26
 940 02c8 7B1F      		adc r23,r27
 941 02ca 7095      		com r23
 942 02cc 6195      		neg r22
 943 02ce 7F4F      		sbci r23,lo8(-1)
 944 02d0 675F      		subi r22,lo8(-(9))
 945 02d2 7F4F      		sbci r23,hi8(-(9))
 946 02d4 00D0      		rcall __divmodhi4
 947 02d6 862F      		mov r24,r22
 948               	/* epilogue start */
 586:main.c        **** 	return (slope);	
 587:main.c        **** }
 950               	.LM121:
 951 02d8 DF91      		pop r29
 952 02da CF91      		pop r28
 953 02dc 0895      		ret
 960               	.Lscope12:
 964               	.global	boxcaravg
 966               	boxcaravg:
 588:main.c        **** 
 589:main.c        **** uint16_t boxcaravg(uint16_t new, uint8_t history)
 590:main.c        **** {
 968               	.LM122:
 969               	.LFBB13:
 970 02de 0F93      		push r16
 971 02e0 1F93      		push r17
 972               	/* prologue: function */
 973               	/* frame size = 0 */
 974               	/* stack size = 2 */
 975               	.L__stack_usage = 2
 976 02e2 9C01      		movw r18,r24
 978               	.LM123:
 979 02e4 80E0      		ldi r24,lo8(0)
 980 02e6 90E0      		ldi r25,hi8(0)
 981               	.L33:
 982               	.LBB31:
 591:main.c        **** 	for (uint8_t i = 0; i<(MAX_BOXES-1); i++)//shift boxcars
 592:main.c        **** 		{box_data[i]=box_data[i+1];}
 984               	.LM124:
 985 02e8 FC01      		movw r30,r24
 589:main.c        **** uint16_t boxcaravg(uint16_t new, uint8_t history)
 987               	.LM125:
 988 02ea 0196      		adiw r24,1
 990               	.LM126:
 991 02ec DC01      		movw r26,r24
 992 02ee AA0F      		lsl r26
 993 02f0 BB1F      		rol r27
 994 02f2 A050      		subi r26,lo8(-(box_data))
 995 02f4 B040      		sbci r27,hi8(-(box_data))
 996 02f6 4D91      		ld r20,X+
 997 02f8 5C91      		ld r21,X
 998 02fa 1197      		sbiw r26,1
 999 02fc EE0F      		lsl r30
 1000 02fe FF1F      		rol r31
 1001 0300 E050      		subi r30,lo8(-(box_data))
 1002 0302 F040      		sbci r31,hi8(-(box_data))
 1003 0304 5183      		std Z+1,r21
 1004 0306 4083      		st Z,r20
 591:main.c        **** 	for (uint8_t i = 0; i<(MAX_BOXES-1); i++)//shift boxcars
 1006               	.LM127:
 1007 0308 8831      		cpi r24,24
 1008 030a 9105      		cpc r25,__zero_reg__
 1009 030c 01F4      		brne .L33
 1010               	.LBE31:
 593:main.c        **** 	box_data[MAX_BOXES-1] = new;//put in latest value
 1012               	.LM128:
 1013 030e E0E0      		ldi r30,lo8(box_data)
 1014 0310 F0E0      		ldi r31,hi8(box_data)
 1015 0312 31AB      		std Z+49,r19
 1016 0314 20AB      		std Z+48,r18
 1017               	.LBB32:
 594:main.c        **** 	//add up 'history' number of boxcars:
 595:main.c        **** 	uint32_t avrg_data_tot = 0; 
 596:main.c        **** 	for (uint8_t i = MAX_BOXES-history ; i<MAX_BOXES; i++)
 1019               	.LM129:
 1020 0316 49E1      		ldi r20,lo8(25)
 1021 0318 461B      		sub r20,r22
 595:main.c        **** 	uint32_t avrg_data_tot = 0; 
 1023               	.LM130:
 1024 031a 80E0      		ldi r24,lo8(0)
 1025 031c 90E0      		ldi r25,hi8(0)
 1026 031e DC01      		movw r26,r24
 1028               	.LM131:
 1029 0320 00C0      		rjmp .L34
 1030               	.L35:
 597:main.c        **** 	{
 598:main.c        **** 	avrg_data_tot = avrg_data_tot+box_data[i];
 1032               	.LM132:
 1033 0322 E42F      		mov r30,r20
 1034 0324 F0E0      		ldi r31,lo8(0)
 1035 0326 EE0F      		lsl r30
 1036 0328 FF1F      		rol r31
 1037 032a E050      		subi r30,lo8(-(box_data))
 1038 032c F040      		sbci r31,hi8(-(box_data))
 1039 032e 0081      		ld r16,Z
 1040 0330 1181      		ldd r17,Z+1
 1041 0332 20E0      		ldi r18,lo8(0)
 1042 0334 30E0      		ldi r19,hi8(0)
 1043 0336 800F      		add r24,r16
 1044 0338 911F      		adc r25,r17
 1045 033a A21F      		adc r26,r18
 1046 033c B31F      		adc r27,r19
 596:main.c        **** 	for (uint8_t i = MAX_BOXES-history ; i<MAX_BOXES; i++)
 1048               	.LM133:
 1049 033e 4F5F      		subi r20,lo8(-(1))
 1050               	.L34:
 596:main.c        **** 	for (uint8_t i = MAX_BOXES-history ; i<MAX_BOXES; i++)
 1052               	.LM134:
 1053 0340 4931      		cpi r20,lo8(25)
 1054 0342 00F0      		brlo .L35
 1055               	.LBE32:
 599:main.c        **** 	}
 600:main.c        **** 	return(avrg_data_tot/history);//return averaged value
 1057               	.LM135:
 1058 0344 262F      		mov r18,r22
 1059 0346 30E0      		ldi r19,lo8(0)
 1060 0348 40E0      		ldi r20,lo8(0)
 1061 034a 50E0      		ldi r21,hi8(0)
 1062 034c BC01      		movw r22,r24
 1063 034e CD01      		movw r24,r26
 1064 0350 00D0      		rcall __udivmodsi4
 601:main.c        **** }...
 1066               	.LM136:
 1067 0352 C901      		movw r24,r18
 1068               	/* epilogue start */
 1069 0354 1F91      		pop r17
 1070 0356 0F91      		pop r16
 1071 0358 0895      		ret
 1079               	.Lscope13:
 1080               		.data
 1081               	.LC0:
 1082 000b 0100      		.word	1
 1083 000d 0000      		.word	0
 1084 000f E001      		.word	480
 1085 0011 4400      		.word	68
 1086 0013 3A02      		.word	570
 1087 0015 5000      		.word	80
 1088 0017 6202      		.word	610
 1089 0019 5500      		.word	85
 1090 001b 8A02      		.word	650
 1091 001d 5A00      		.word	90
 1092 001f B202      		.word	690
 1093 0021 6400      		.word	100
 1094 0023 BC02      		.word	700
 1095 0025 6E00      		.word	110
 1096 0027 EE02      		.word	750
 1097 0029 8F00      		.word	143
 1098 002b 1B03      		.word	795
 1099 002d AA00      		.word	170
 1100 002f 2A03      		.word	810
 1101 0031 F200      		.word	242
 1102 0033 4D03      		.word	845
 1103 0035 E84E      		.word	20200
 1104 0037 0004      		.word	1024
 1105 0039 9065      		.word	26000
 1106               		.text
 1108               	.global	eight
 1110               	eight:
 358:main.c        **** {
 1112               	.LM137:
 1113               	.LFBB14:
 1114 035a AF92      		push r10
 1115 035c BF92      		push r11
 1116 035e CF92      		push r12
 1117 0360 DF92      		push r13
 1118 0362 EF92      		push r14
 1119 0364 FF92      		push r15
 1120 0366 1F93      		push r17
 1121 0368 CF93      		push r28
 1122 036a DF93      		push r29
 1123 036c CDB7      		in r28,__SP_L__
 1124 036e DEB7      		in r29,__SP_H__
 1125 0370 E097      		sbiw r28,48
 1126 0372 0FB6      		in __tmp_reg__,__SREG__
 1127 0374 F894      		cli
 1128 0376 DEBF      		out __SP_H__,r29
 1129 0378 0FBE      		out __SREG__,__tmp_reg__
 1130 037a CDBF      		out __SP_L__,r28
 1131               	/* prologue: function */
 1132               	/* frame size = 48 */
 1133               	/* stack size = 57 */
 1134               	.L__stack_usage = 57
 359:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 1136               	.LM138:
 1137 037c C298      		cbi 56-32,2
 1138               	.LBB33:
 1139               	.LBB34:
 1141               	.Ltext7:
 1143               	.LM139:
 1144 037e 2AE1      		 ldi r18,lo8(26)
 1145 0380 2A95      	    1:dec r18
 1146 0382 01F4      	    brne 1b
 1147 0384 00C0      		rjmp .
 1148               	.LBE34:
 1149               	.LBE33:
 1151               	.Ltext8:
 361:main.c        **** 	DDRB &=~ _BV(2);//hiZ
 1153               	.LM140:
 1154 0386 BA98      		cbi 55-32,2
 362:main.c        **** 	DC_val = ADC_data;
 1156               	.LM141:
 1157 0388 2091 0000 		lds r18,ADC_data
 1158 038c 3091 0000 		lds r19,ADC_data+1
 1159 0390 3093 0000 		sts DC_val+1,r19
 1160 0394 2093 0000 		sts DC_val,r18
 364:main.c        **** 	ADC_flag = 0;	
 1162               	.LM142:
 1163 0398 1092 0000 		sts ADC_flag,__zero_reg__
 366:main.c        **** 	measured_temperature = (DC_val - nurnst);
 1165               	.LM143:
 1166 039c 8091 0000 		lds r24,nurnst
 1167 03a0 9091 0000 		lds r25,nurnst+1
 1168 03a4 281B      		sub r18,r24
 1169 03a6 390B      		sbc r19,r25
 367:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 1171               	.LM144:
 1172 03a8 2F3F      		cpi r18,255
 1173 03aa 3105      		cpc r19,__zero_reg__
 1174 03ac 01F0      		breq .+2
 1175 03ae 00F4      		brsh .L38
 369:main.c        **** 		measured_temperature = (255 - measured_temperature);
 1177               	.LM145:
 1178 03b0 8FEF      		ldi r24,lo8(255)
 1179 03b2 90E0      		ldi r25,hi8(255)
 1180 03b4 821B      		sub r24,r18
 1181 03b6 930B      		sbc r25,r19
 1182 03b8 9093 0000 		sts measured_temperature+1,r25
 1183 03bc 8093 0000 		sts measured_temperature,r24
 1184 03c0 00C0      		rjmp .L39
 1185               	.L38:
 373:main.c        **** 		measured_temperature =0;
 1187               	.LM146:
 1188 03c2 1092 0000 		sts measured_temperature+1,__zero_reg__
 1189 03c6 1092 0000 		sts measured_temperature,__zero_reg__
 1190               	.L39:
 375:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 1192               	.LM147:
 1193 03ca 8091 0000 		lds r24,measured_temperature
 1194 03ce 9091 0000 		lds r25,measured_temperature+1
 1195 03d2 9C01      		movw r18,r24
 1196 03d4 295E      		subi r18,lo8(-(-233))
 1197 03d6 3040      		sbci r19,hi8(-(-233))
 1198 03d8 2930      		cpi r18,9
 1199 03da 3105      		cpc r19,__zero_reg__
 1200 03dc 00F4      		brsh .L40
 377:main.c        **** 		PORTD &=~ _BV(4);//LED off
 1202               	.LM148:
 1203 03de 9498      		cbi 50-32,4
 1204 03e0 00C0      		rjmp .L41
 1205               	.L40:
 381:main.c        **** 		PORTD |= _BV(4);//LED on
 1207               	.LM149:
 1208 03e2 949A      		sbi 50-32,4
 1209               	.L41:
 383:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 1211               	.LM150:
 1212 03e4 4091 0000 		lds r20,charspot
 1213 03e8 60E0      		ldi r22,lo8(0)
 1214 03ea 00D0      		rcall put_in_string
 1215 03ec 8093 0000 		sts charspot,r24
 386:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 1217               	.LM151:
 1218 03f0 8091 0000 		lds r24,pump
 1219 03f4 9091 0000 		lds r25,pump+1
 1220 03f8 4091 0000 		lds r20,charspot
 1221 03fc 60E0      		ldi r22,lo8(0)
 1222 03fe 00D0      		rcall put_in_string
 1223 0400 8093 0000 		sts charspot,r24
 387:main.c        **** 	if (near_stoic_flag == 1)
 1225               	.LM152:
 1226 0404 8091 0000 		lds r24,near_stoic_flag
 1227 0408 8130      		cpi r24,lo8(1)
 1228 040a 01F4      		brne .L42
 389:main.c        **** 		pump = boxcaravg(pump,100);//average pump current 100 points
 1230               	.LM153:
 1231 040c 8091 0000 		lds r24,pump
 1232 0410 9091 0000 		lds r25,pump+1
 1233 0414 64E6      		ldi r22,lo8(100)
 1234 0416 00C0      		rjmp .L55
 1235               	.L42:
 393:main.c        **** 		pump = boxcaravg(pump,3);//average pump current 3 points
 1237               	.LM154:
 1238 0418 8091 0000 		lds r24,pump
 1239 041c 9091 0000 		lds r25,pump+1
 1240 0420 63E0      		ldi r22,lo8(3)
 1241               	.L55:
 1242 0422 00D0      		rcall boxcaravg
 1243 0424 9093 0000 		sts pump+1,r25
 1244 0428 8093 0000 		sts pump,r24
 395:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 1246               	.LM155:
 1247 042c 8091 0000 		lds r24,pump
 1248 0430 9091 0000 		lds r25,pump+1
 1249 0434 4091 0000 		lds r20,charspot
 1250 0438 60E0      		ldi r22,lo8(0)
 1251 043a 00D0      		rcall put_in_string
 1252 043c 8093 0000 		sts charspot,r24
 402:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 1254               	.LM156:
 1255 0440 DE01      		movw r26,r28
 1256 0442 1196      		adiw r26,1
 1257 0444 E0E0      		ldi r30,lo8(.LC0)
 1258 0446 F0E0      		ldi r31,hi8(.LC0)
 1259 0448 80E3      		ldi r24,lo8(48)
 1260               	.L44:
 1261 044a 0190      		ld r0,Z+
 1262 044c 0D92      		st X+,r0
 1263 044e 8150      		subi r24,lo8(-(-1))
 1264 0450 01F4      		brne .L44
 419:main.c        **** 	if (pump<lambda_curve[0].x)//smaller than the lowest value in LOT
 1266               	.LM157:
 1267 0452 2091 0000 		lds r18,pump
 1268 0456 3091 0000 		lds r19,pump+1
 1269 045a 8981      		ldd r24,Y+1
 1270 045c 9A81      		ldd r25,Y+2
 1271 045e 2817      		cp r18,r24
 1272 0460 3907      		cpc r19,r25
 1273 0462 00F4      		brsh .L45
 420:main.c        **** 	{lambda = lambda_curve[0].y;}
 1275               	.LM158:
 1276 0464 CB80      		ldd r12,Y+3
 1277 0466 DC80      		ldd r13,Y+4
 1278 0468 00C0      		rjmp .L56
 1279               	.L53:
 417:main.c        **** 	uint32_t lambda=0;
 1281               	.LM159:
 1282 046a CC24      		clr r12
 1283 046c DD24      		clr r13
 1284 046e 7601      		movw r14,r12
 1285               	.L47:
 417:main.c        **** 	uint32_t lambda=0;
 1287               	.LM160:
 1288 0470 10E0      		ldi r17,lo8(0)
 1289 0472 00C0      		rjmp .L46
 1290               	.L45:
 421:main.c        **** 	else if (pump>lambda_curve[n-1].x)//larger than the highest value in the LOT
 1292               	.LM161:
 1293 0474 2091 0000 		lds r18,pump
 1294 0478 3091 0000 		lds r19,pump+1
 1295 047c 8DA5      		ldd r24,Y+45
 1296 047e 9EA5      		ldd r25,Y+46
 1297 0480 8217      		cp r24,r18
 1298 0482 9307      		cpc r25,r19
 1299 0484 00F4      		brsh .L53
 422:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 1301               	.LM162:
 1302 0486 CFA4      		ldd r12,Y+47
 1303 0488 D8A8      		ldd r13,Y+48
 1304               	.L56:
 1305 048a EE24      		clr r14
 1306 048c FF24      		clr r15
 1307 048e 00C0      		rjmp .L47
 1308               	.L49:
 1309               	.LBB35:
 426:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 1311               	.LM163:
 1312 0490 DC01      		movw r26,r24
 1313 0492 AA0F      		lsl r26
 1314 0494 BB1F      		rol r27
 1315 0496 AA0F      		lsl r26
 1316 0498 BB1F      		rol r27
 1317 049a 21E0      		ldi r18,lo8(1)
 1318 049c 30E0      		ldi r19,hi8(1)
 1319 049e 2C0F      		add r18,r28
 1320 04a0 3D1F      		adc r19,r29
 1321 04a2 A20F      		add r26,r18
 1322 04a4 B31F      		adc r27,r19
 1323 04a6 6D91      		ld r22,X+
 1324 04a8 7C91      		ld r23,X
 1325 04aa 1197      		sbiw r26,1
 1326 04ac 2091 0000 		lds r18,pump
 1327 04b0 3091 0000 		lds r19,pump+1
 1328 04b4 2617      		cp r18,r22
 1329 04b6 3707      		cpc r19,r23
 1330 04b8 00F0      		brlo .L48
 426:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 1332               	.LM164:
 1333 04ba FC01      		movw r30,r24
 1334 04bc 3196      		adiw r30,1
 1335 04be EE0F      		lsl r30
 1336 04c0 FF1F      		rol r31
 1337 04c2 EE0F      		lsl r30
 1338 04c4 FF1F      		rol r31
 1339 04c6 81E0      		ldi r24,lo8(1)
 1340 04c8 90E0      		ldi r25,hi8(1)
 1341 04ca 8C0F      		add r24,r28
 1342 04cc 9D1F      		adc r25,r29
 1343 04ce E80F      		add r30,r24
 1344 04d0 F91F      		adc r31,r25
 1345 04d2 A080      		ld r10,Z
 1346 04d4 B180      		ldd r11,Z+1
 1347 04d6 8091 0000 		lds r24,pump
 1348 04da 9091 0000 		lds r25,pump+1
 1349 04de A816      		cp r10,r24
 1350 04e0 B906      		cpc r11,r25
 1351 04e2 00F0      		brlo .L48
 1352               	.LBB36:
 428:main.c        **** 			uint16_t diffx = pump - lambda_curve[i].x; //difference between the pump value and the x value i
 1354               	.LM165:
 1355 04e4 2091 0000 		lds r18,pump
 1356 04e8 3091 0000 		lds r19,pump+1
 430:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 1358               	.LM166:
 1359 04ec 1296      		adiw r26,2
 1360 04ee ED90      		ld r14,X+
 1361 04f0 FC90      		ld r15,X
 1362 04f2 1397      		sbiw r26,2+1
 1363 04f4 8281      		ldd r24,Z+2
 1364 04f6 9381      		ldd r25,Z+3
 1365 04f8 8E19      		sub r24,r14
 1366 04fa 9F09      		sbc r25,r15
 428:main.c        **** 			uint16_t diffx = pump - lambda_curve[i].x; //difference between the pump value and the x value i
 1368               	.LM167:
 1369 04fc 261B      		sub r18,r22
 1370 04fe 370B      		sbc r19,r23
 431:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1372               	.LM168:
 1373 0500 829F      		mul r24,r18
 1374 0502 A001      		movw r20,r0
 1375 0504 839F      		mul r24,r19
 1376 0506 500D      		add r21,r0
 1377 0508 929F      		mul r25,r18
 1378 050a 500D      		add r21,r0
 1379 050c 1124      		clr r1
 429:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 1381               	.LM169:
 1382 050e 9501      		movw r18,r10
 1383 0510 261B      		sub r18,r22
 1384 0512 370B      		sbc r19,r23
 1385 0514 B901      		movw r22,r18
 431:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1387               	.LM170:
 1388 0516 CA01      		movw r24,r20
 1389 0518 00D0      		rcall __udivmodhi4
 1390 051a 6E0D      		add r22,r14
 1391 051c 7F1D      		adc r23,r15
 1392 051e 6B01      		movw r12,r22
 1393 0520 EE24      		clr r14
 1394 0522 FF24      		clr r15
 1395               	.L48:
 1396               	.LBE36:
 424:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1398               	.LM171:
 1399 0524 1F5F      		subi r17,lo8(-(1))
 1400               	.L46:
 424:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1402               	.LM172:
 1403 0526 812F      		mov r24,r17
 1404 0528 90E0      		ldi r25,lo8(0)
 1405 052a 1B30      		cpi r17,lo8(11)
 1406 052c 01F0      		breq .+2
 1407 052e 00C0      		rjmp .L49
 1408               	.LBE35:
 437:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 1410               	.LM173:
 1411 0530 4091 0000 		lds r20,charspot
 1412 0534 C601      		movw r24,r12
 1413 0536 60E0      		ldi r22,lo8(0)
 1414 0538 00D0      		rcall put_in_string
 1415 053a 8093 0000 		sts charspot,r24
 438:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 1417               	.LM174:
 1418 053e D701      		movw r26,r14
 1419 0540 C601      		movw r24,r12
 1420 0542 8054      		subi r24,lo8(-(-64))
 1421 0544 9040      		sbci r25,hi8(-(-64))
 1422 0546 A040      		sbci r26,hlo8(-(-64))
 1423 0548 B040      		sbci r27,hhi8(-(-64))
 1424 054a 8934      		cpi r24,lo8(73)
 1425 054c 9105      		cpc r25,__zero_reg__
 1426 054e A105      		cpc r26,__zero_reg__
 1427 0550 B105      		cpc r27,__zero_reg__
 1428 0552 00F4      		brsh .L50
 1429               	.LBB37:
 440:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 1431               	.LM175:
 1432 0554 C701      		movw r24,r14
 1433 0556 B601      		movw r22,r12
 1434 0558 20EF      		ldi r18,lo8(2550000)
 1435 055a 38EE      		ldi r19,hi8(2550000)
 1436 055c 46E2      		ldi r20,hlo8(2550000)
 1437 055e 50E0      		ldi r21,hhi8(2550000)
 1438 0560 00D0      		rcall __mulsi3
 1439 0562 6050      		subi r22,lo8(-(-163200000))
 1440 0564 7C43      		sbci r23,hi8(-(-163200000))
 1441 0566 8A4B      		sbci r24,hlo8(-(-163200000))
 1442 0568 9940      		sbci r25,hhi8(-(-163200000))
 1443 056a 28E4      		ldi r18,lo8(72)
 1444 056c 30E0      		ldi r19,hi8(72)
 1445 056e 40E0      		ldi r20,hlo8(72)
 1446 0570 50E0      		ldi r21,hhi8(72)
 1447 0572 00D0      		rcall __udivmodsi4
 441:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 1449               	.LM176:
 1450 0574 CA01      		movw r24,r20
 1451 0576 B901      		movw r22,r18
 1452 0578 20E1      		ldi r18,lo8(10000)
 1453 057a 37E2      		ldi r19,hi8(10000)
 1454 057c 40E0      		ldi r20,hlo8(10000)
 1455 057e 50E0      		ldi r21,hhi8(10000)
 1456 0580 00D0      		rcall __udivmodsi4
 1457 0582 2093 0000 		sts zero_to_5_WB,r18
 1458 0586 3093 0000 		sts zero_to_5_WB+1,r19
 1459 058a 4093 0000 		sts zero_to_5_WB+2,r20
 1460 058e 5093 0000 		sts zero_to_5_WB+3,r21
 1461 0592 00C0      		rjmp .L51
 1462               	.L50:
 1463               	.LBE37:
 443:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1465               	.LM177:
 1466 0594 39E8      		ldi r19,lo8(137)
 1467 0596 C316      		cp r12,r19
 1468 0598 D104      		cpc r13,__zero_reg__
 1469 059a E104      		cpc r14,__zero_reg__
 1470 059c F104      		cpc r15,__zero_reg__
 1471 059e 00F0      		brlo .L52
 443:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1473               	.LM178:
 1474 05a0 8FEF      		ldi r24,lo8(255)
 1475 05a2 90E0      		ldi r25,hi8(255)
 1476 05a4 A0E0      		ldi r26,hlo8(255)
 1477 05a6 B0E0      		ldi r27,hhi8(255)
 1478 05a8 8093 0000 		sts zero_to_5_WB,r24
 1479 05ac 9093 0000 		sts zero_to_5_WB+1,r25
 1480 05b0 A093 0000 		sts zero_to_5_WB+2,r26
 1481 05b4 B093 0000 		sts zero_to_5_WB+3,r27
 1482 05b8 00C0      		rjmp .L51
 1483               	.L52:
 444:main.c        **** 	else {zero_to_5_WB = 0;}
 1485               	.LM179:
 1486 05ba 1092 0000 		sts zero_to_5_WB,__zero_reg__
 1487 05be 1092 0000 		sts zero_to_5_WB+1,__zero_reg__
 1488 05c2 1092 0000 		sts zero_to_5_WB+2,__zero_reg__
 1489 05c6 1092 0000 		sts zero_to_5_WB+3,__zero_reg__
 1490               	.L51:
 445:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 1492               	.LM180:
 1493 05ca 8091 0000 		lds r24,zero_to_5_WB
 1494 05ce 83BD      		out 67-32,r24
 446:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 1496               	.LM181:
 1497 05d0 4091 0000 		lds r20,charspot
 1498 05d4 8091 0000 		lds r24,zero_to_5_WB
 1499 05d8 9091 0000 		lds r25,zero_to_5_WB+1
 1500 05dc 60E0      		ldi r22,lo8(0)
 1501 05de 00D0      		rcall put_in_string
 1502 05e0 8093 0000 		sts charspot,r24
 449:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 1504               	.LM182:
 1505 05e4 00D0      		rcall PID_heater
 451:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 1507               	.LM183:
 1508 05e6 8091 0000 		lds r24,charspot
 1509 05ea 00D0      		rcall spitout
 1510 05ec 8093 0000 		sts charspot,r24
 1511               	/* epilogue start */
 452:main.c        **** }
 1513               	.LM184:
 1514 05f0 E096      		adiw r28,48
 1515 05f2 0FB6      		in __tmp_reg__,__SREG__
 1516 05f4 F894      		cli
 1517 05f6 DEBF      		out __SP_H__,r29
 1518 05f8 0FBE      		out __SREG__,__tmp_reg__
 1519 05fa CDBF      		out __SP_L__,r28
 1520 05fc DF91      		pop r29
 1521 05fe CF91      		pop r28
 1522 0600 1F91      		pop r17
 1523 0602 FF90      		pop r15
 1524 0604 EF90      		pop r14
 1525 0606 DF90      		pop r13
 1526 0608 CF90      		pop r12
 1527 060a BF90      		pop r11
 1528 060c AF90      		pop r10
 1529 060e 0895      		ret
 1538               	.Lscope14:
 1540               	.global	__vector_14
 1542               	__vector_14:
 153:main.c        **** {
 1544               	.LM185:
 1545               	.LFBB15:
 1546 0610 1F92      		push r1
 1547 0612 0F92      		push r0
 1548 0614 0FB6      		in r0,__SREG__
 1549 0616 0F92      		push r0
 1550 0618 1124      		clr __zero_reg__
 1551 061a 2F93      		push r18
 1552 061c 3F93      		push r19
 1553 061e 4F93      		push r20
 1554 0620 5F93      		push r21
 1555 0622 6F93      		push r22
 1556 0624 7F93      		push r23
 1557 0626 8F93      		push r24
 1558 0628 9F93      		push r25
 1559 062a AF93      		push r26
 1560 062c BF93      		push r27
 1561 062e EF93      		push r30
 1562 0630 FF93      		push r31
 1563               	/* prologue: Signal */
 1564               	/* frame size = 0 */
 1565               	/* stack size = 15 */
 1566               	.L__stack_usage = 15
 154:main.c        **** ADC_data = readadc();
 1568               	.LM186:
 1569 0632 00D0      		rcall readadc
 1570 0634 9093 0000 		sts ADC_data+1,r25
 1571 0638 8093 0000 		sts ADC_data,r24
 156:main.c        **** if (ADC_flag == 7)//
 1573               	.LM187:
 1574 063c 8091 0000 		lds r24,ADC_flag
 1575 0640 8730      		cpi r24,lo8(7)
 1576 0642 01F4      		brne .L58
 158:main.c        **** 	four();
 1578               	.LM188:
 1579 0644 00D0      		rcall four
 1580 0646 00C0      		rjmp .L57
 1581               	.L58:
 160:main.c        **** else if (ADC_flag == 2)
 1583               	.LM189:
 1584 0648 8091 0000 		lds r24,ADC_flag
 1585 064c 8230      		cpi r24,lo8(2)
 1586 064e 01F4      		brne .L60
 162:main.c        **** 	six_1();
 1588               	.LM190:
 1589 0650 00D0      		rcall six_1
 1590 0652 00C0      		rjmp .L57
 1591               	.L60:
 164:main.c        **** else if (ADC_flag == 8)
 1593               	.LM191:
 1594 0654 8091 0000 		lds r24,ADC_flag
 1595 0658 8830      		cpi r24,lo8(8)
 1596 065a 01F4      		brne .L61
 166:main.c        **** 	six_2();
 1598               	.LM192:
 1599 065c 00D0      		rcall six_2
 1600 065e 00C0      		rjmp .L57
 1601               	.L61:
 168:main.c        **** else if (ADC_flag == 9)
 1603               	.LM193:
 1604 0660 8091 0000 		lds r24,ADC_flag
 1605 0664 8930      		cpi r24,lo8(9)
 1606 0666 01F4      		brne .L62
 170:main.c        **** 	six_3();
 1608               	.LM194:
 1609 0668 00D0      		rcall six_3
 1610 066a 00C0      		rjmp .L57
 1611               	.L62:
 173:main.c        **** else if (ADC_flag == 3)//nurnst
 1613               	.LM195:
 1614 066c 8091 0000 		lds r24,ADC_flag
 1615 0670 8330      		cpi r24,lo8(3)
 1616 0672 01F4      		brne .L63
 175:main.c        **** 	seven();
 1618               	.LM196:
 1619 0674 00D0      		rcall seven
 1620 0676 00C0      		rjmp .L57
 1621               	.L63:
 177:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 1623               	.LM197:
 1624 0678 8091 0000 		lds r24,ADC_flag
 1625 067c 8430      		cpi r24,lo8(4)
 1626 067e 01F4      		brne .L64
 179:main.c        **** 	eight();
 1628               	.LM198:
 1629 0680 00D0      		rcall eight
 1630 0682 00C0      		rjmp .L57
 1631               	.L64:
 184:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 1633               	.LM199:
 1634 0684 00D0      		rcall readadc
 1635 0686 9093 0000 		sts ADC_data+1,r25
 1636 068a 8093 0000 		sts ADC_data,r24
 1637               	.L57:
 1638               	/* epilogue start */
 186:main.c        **** }
 1640               	.LM200:
 1641 068e FF91      		pop r31
 1642 0690 EF91      		pop r30
 1643 0692 BF91      		pop r27
 1644 0694 AF91      		pop r26
 1645 0696 9F91      		pop r25
 1646 0698 8F91      		pop r24
 1647 069a 7F91      		pop r23
 1648 069c 6F91      		pop r22
 1649 069e 5F91      		pop r21
 1650 06a0 4F91      		pop r20
 1651 06a2 3F91      		pop r19
 1652 06a4 2F91      		pop r18
 1653 06a6 0F90      		pop r0
 1654 06a8 0FBE      		out __SREG__,r0
 1655 06aa 0F90      		pop r0
 1656 06ac 1F90      		pop r1
 1657 06ae 1895      		reti
 1659               	.Lscope15:
 1660               		.comm pidData_pump,18,1
 1661               		.comm pidData_temp,18,1
 1662               		.comm pidCounter,1,1
 1663               	.global	flip
 1664               	.global	flip
 1665               		.section .bss
 1668               	flip:
 1669 0000 00        		.skip 1,0
 1670               	.global	cycles_no_flip
 1671               	.global	cycles_no_flip
 1674               	cycles_no_flip:
 1675 0001 00        		.skip 1,0
 1676               	.global	cycle_counter
 1677               	.global	cycle_counter
 1680               	cycle_counter:
 1681 0002 00        		.skip 1,0
 1682               	.global	near_stoic_flag
 1683               		.data
 1686               	near_stoic_flag:
 1687 003b 01        		.byte	1
 1688               	.global	nspike
 1689               	.global	nspike
 1690               		.section .bss
 1693               	nspike:
 1694 0003 00        		.skip 1,0
 1695               	.global	charspot
 1696               	.global	charspot
 1699               	charspot:
 1700 0004 00        		.skip 1,0
 1701               		.comm ADC_flag,1,1
 1702               		.comm its_off,1,1
 1703               	.global	ramp_flag
 1704               	.global	ramp_flag
 1707               	ramp_flag:
 1708 0005 00        		.skip 1,0
 1709               		.comm zero_to_5_WB,4,1
 1710               		.comm measured_temperature,2,1
 1711               	.global	DC_val
 1712               	.global	DC_val
 1715               	DC_val:
 1716 0006 0000      		.skip 2,0
 1717               	.global	pump
 1718               	.global	pump
 1721               	pump:
 1722 0008 0000      		.skip 2,0
 1723               	.global	nurnst
 1724               	.global	nurnst
 1727               	nurnst:
 1728 000a 0000      		.skip 2,0
 1729               		.comm ADC_data,2,1
 1730               		.comm heat_power,1,1
 1731               		.comm box_data,50,1
 1732               		.comm nurnst_data,6,1
 1733               	.global	ipramp
 1734               	.global	ipramp
 1737               	ipramp:
 1738 000c 0000      		.skip 2,0
 1739               	.global	IpCount
 1740               	.global	IpCount
 1743               	IpCount:
 1744 000e 0000 0000 		.skip 4,0
 1745               		.comm serialout,50,1
 1770               		.text
 1772               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cclMlbJV.s:2      *ABS*:0000003f __SREG__
     /tmp/cclMlbJV.s:3      *ABS*:0000003e __SP_H__
     /tmp/cclMlbJV.s:4      *ABS*:0000003d __SP_L__
     /tmp/cclMlbJV.s:5      *ABS*:00000034 __CCP__
     /tmp/cclMlbJV.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cclMlbJV.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cclMlbJV.s:127    .text.startup:00000000 main
                            *COM*:00000012 pidData_temp
                            *COM*:00000012 pidData_pump
                            *COM*:00000001 heat_power
     /tmp/cclMlbJV.s:1707   .bss:00000005 ramp_flag
     /tmp/cclMlbJV.s:295    .text:00000000 do_things
     /tmp/cclMlbJV.s:1680   .bss:00000002 cycle_counter
                            *COM*:00000001 ADC_flag
     /tmp/cclMlbJV.s:357    .text:00000034 __vector_9
                            *COM*:00000001 its_off
     /tmp/cclMlbJV.s:460    .text:000000a6 four
     /tmp/cclMlbJV.s:1699   .bss:00000004 charspot
                            *COM*:00000002 ADC_data
     /tmp/cclMlbJV.s:496    .text:000000c8 six_1
     /tmp/cclMlbJV.s:1721   .bss:00000008 pump
     /tmp/cclMlbJV.s:526    .text:000000e2 six_2
     /tmp/cclMlbJV.s:560    .text:00000108 six_3
     /tmp/cclMlbJV.s:607    .text:00000148 readadc
     /tmp/cclMlbJV.s:643    .text:00000158 PID_heater
                            *COM*:00000002 measured_temperature
     /tmp/cclMlbJV.s:699    .text:00000192 PID_pump
     /tmp/cclMlbJV.s:1727   .bss:0000000a nurnst
     /tmp/cclMlbJV.s:774    .text:000001ea seven
     /tmp/cclMlbJV.s:842    .text:00000232 nurnst_slope_tracker
                            *COM*:00000006 nurnst_data
     /tmp/cclMlbJV.s:966    .text:000002de boxcaravg
                            *COM*:00000032 box_data
     /tmp/cclMlbJV.s:1110   .text:0000035a eight
     /tmp/cclMlbJV.s:1715   .bss:00000006 DC_val
     /tmp/cclMlbJV.s:1686   .data:0000003b near_stoic_flag
                            *COM*:00000004 zero_to_5_WB
     /tmp/cclMlbJV.s:1542   .text:00000610 __vector_14
                            *COM*:00000001 pidCounter
     /tmp/cclMlbJV.s:1668   .bss:00000000 flip
     /tmp/cclMlbJV.s:1674   .bss:00000001 cycles_no_flip
     /tmp/cclMlbJV.s:1693   .bss:00000003 nspike
     /tmp/cclMlbJV.s:1737   .bss:0000000c ipramp
     /tmp/cclMlbJV.s:1743   .bss:0000000e IpCount
                            *COM*:00000032 serialout

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
setup_timer1
setup_timer2
pid_Init
adc_init
timer0init
uart_putst
uart_put16dec
uart_putch
put_in_string
__udivmodhi4
pid_Controller
__divmodhi4
__udivmodsi4
__mulsi3
spitout
