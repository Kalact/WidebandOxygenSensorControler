   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 120               		.data
 121               	.LC1:
 122 0000 7261 6D70 		.string	"ramp temp\n"
 122      2074 656D 
 122      700A 00
 123               		.section	.text.startup,"ax",@progbits
 125               	.global	main
 127               	main:
   1:main.c        **** 
   2:main.c        **** /////////////---------------------------------///////////////////
   3:main.c        **** // 
   4:main.c        **** // www.waltech.com
   5:main.c        **** //
   6:main.c        **** /////////////---------------------------------/////////////////
   7:main.c        **** /*
   8:main.c        ****  * ramp disabled
   9:main.c        ****  * set for vref of 1.5v
  10:main.c        ****  * vref is monitored on adc1
  11:main.c        ****  * ramp to stoic
  12:main.c        ****  */
  13:main.c        **** 
  14:main.c        **** //Includes here:
  15:main.c        **** 
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <stdlib.h>
  18:main.c        **** #include <string.h>
  19:main.c        **** #include <util/delay.h>
  20:main.c        **** #include <avr/pgmspace.h>
  21:main.c        **** #include "pid.h"
  22:main.c        **** #include "stdint.h"
  23:main.c        **** #include "initilize_hardware.h"
  24:main.c        **** #include "dataout.h"
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** ////////calibration settings://///////////
  28:main.c        **** //offset for lamda value, uses to calibrate (lambda*100) = 100  at stoic.  Checking against NB sens
  29:main.c        **** //POSOFFSET is added, NEGOFFSET is subtracted.
  30:main.c        **** #define POSOFFSET 0
  31:main.c        **** #define NEGOFFSET 0
  32:main.c        **** 
  33:main.c        **** /*Lambda*100 to DAC (0-255)
  34:main.c        **** * 
  35:main.c        **** *	formula for output voltage:
  36:main.c        **** *	Vout = [(L-Lmin)/(Lmax-Lmin)]*5
  37:main.c        **** *
  38:main.c        **** * example to provide lambda range from 0.64 to 1.36:
  39:main.c        **** *	 LAMBDA_MIN	64UL
  40:main.c        **** *	 LAMBDA_MAX 136UL
  41:main.c        **** * Set two values below: 
  42:main.c        **** */
  43:main.c        **** #define LAMBDA_MIN	64UL// set to desired value for 0v output (Lambda*100)
  44:main.c        **** #define LAMBDA_MAX 136UL//set to desired value for 5v output	(Lambda*100
  45:main.c        **** ////////end calibration settings/////////////
  46:main.c        **** 
  47:main.c        **** 
  48:main.c        **** #define MAX_BOXES 25 //max boxes stored.
  49:main.c        **** 
  50:main.c        **** #define DAC_FACTOR 2550000UL/(LAMBDA_MAX-LAMBDA_MIN)//don't change: just a calculation pre-compile
  51:main.c        **** 
  52:main.c        **** //#define MAXPUMP_I 196 // maximum current value for pump (leanest). 
  53:main.c        **** #define MAXPUMP_I 329 // maximum current value for pump (leanest). 
  54:main.c        **** //see initilize_hardware.h for PWMPUMP_FREQ, if timer OCR1A = PWMPUMP_FREQ, DAC is maxed (5v)
  55:main.c        **** #define ZERO_CURRENT  97
  56:main.c        **** //#define MINPUMP_I 50 // minimum current value for pump. 
  57:main.c        ****  #define MINPUMP_I 0 // minimum current value for pump.
  58:main.c        **** //NOTE (based on manual pump power settings)
  59:main.c        **** // Above max, virt gnd is pushed up. 
  60:main.c        **** // Nothing happens below min.
  61:main.c        **** // 0 current is at 116// now 97 (r4=8.2k ZERO_CURRENT
  62:main.c        **** 
  63:main.c        **** //#define TARGET_NERNST 832 // lambda=1 value for nurnst, target for pump pid 
  64:main.c        **** #define TARGET_NERNST 821 // lambda=1 value for nurnst, target for pump pid
  65:main.c        **** #define TARGET_TEMP 237 
  66:main.c        **** #define P_temp    350//was 450
  67:main.c        **** #define I_temp    100//5
  68:main.c        **** #define D_temp    0//1
  69:main.c        **** 
  70:main.c        **** //#define P_pump    15
  71:main.c        **** //#define I_pump    74
  72:main.c        **** //#define D_pump    2
  73:main.c        **** 
  74:main.c        **** #define P_pump    5//
  75:main.c        **** #define I_pump    2
  76:main.c        **** #define D_pump    0
  77:main.c        **** 
  78:main.c        **** 
  79:main.c        **** //#define F_CPU 4000000UL
  80:main.c        **** //(in makefile)
  81:main.c        **** #define BAUD 9600UL
  82:main.c        **** #define UBRRVAL (F_CPU/(BAUD*16)-1)
  83:main.c        **** 
  84:main.c        **** 
  85:main.c        **** //test
  86:main.c        **** //for manual ip ramp:
  87:main.c        **** uint32_t IpCount = 0;
  88:main.c        **** uint16_t ipramp = 0;
  89:main.c        **** 
  90:main.c        **** //for slope determination of nurnst:
  91:main.c        **** #define NURNSTPOINTS 3 //number of points to track
  92:main.c        **** volatile uint16_t nurnst_data[NURNSTPOINTS+1];
  93:main.c        **** 
  94:main.c        **** //for slope determination of nurnst:
  95:main.c        **** #define IPPOINTS 3 //number of points to track
  96:main.c        **** volatile uint16_t Ip_data[IPPOINTS+1];
  97:main.c        **** 
  98:main.c        **** 
  99:main.c        **** //in pid.h, changed scalevalue to 1 since parampeters are now integers: K * 128
 100:main.c        **** 
 101:main.c        **** uint8_t heat_power;//global value fed to timer0 for heater pwm
 102:main.c        **** uint16_t ADC_data;//read the ADC into this
 103:main.c        **** 
 104:main.c        **** volatile uint16_t nurnst = 0;// value read from adc2 for the nernst cell w/o DC
 105:main.c        **** volatile uint16_t pump = 0;//measured voltage at pump
 106:main.c        **** uint16_t DC_val = 0;//value read from adc2 for the nernst cell w/DC
 107:main.c        **** 
 108:main.c        **** //int16_t IpumpVolts=0;//difference from above proportional to current flowing to pump.
 109:main.c        **** uint16_t measured_temperature;//measured temperature value. also known as Ri
 110:main.c        **** uint32_t zero_to_5_WB;//value applied to timer2 to make DAC output
 111:main.c        **** 
 112:main.c        **** uint8_t ramp_flag=0;// flag gets set once the startup temperature ramp is done
 113:main.c        **** uint8_t its_off;//flag to keep track of the heater pwm state
 114:main.c        **** volatile uint8_t ADC_flag;//keeps track in the ADC interrupt 
 115:main.c        **** volatile uint8_t charspot=0;//keeps track of the position of the numbers going into the string
 116:main.c        **** volatile uint8_t cycle_counter = 0;//counts main lops for sampling
 117:main.c        **** volatile uint8_t nurnst_spike = 0;//flag for nurnst spike detected
 118:main.c        **** volatile int16_t nurnst_slope = 0;
 119:main.c        **** volatile int16_t ip_slope = 0;
 120:main.c        **** volatile uint8_t timeinspike = 0;//how many samples it stayed in the spike filter mode.
 121:main.c        **** 
 122:main.c        **** ////////////////////////////////////////////////////////////////////////
 123:main.c        **** //for PID:
 124:main.c        **** uint8_t pidCounter; //True when PID control loop should run one time
 125:main.c        **** struct PID_DATA pidData_temp; //termperature PID structure of vars
 126:main.c        **** struct PID_DATA pidData_pump; //pump PID structure of vars
 127:main.c        **** ////////////////////////////////////////////////////////////////////////
 128:main.c        **** 
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** /////function prototypes/////
 132:main.c        **** uint16_t readadc(void);
 133:main.c        **** 
 134:main.c        **** void do_things(void);
 135:main.c        **** void two(void);
 136:main.c        **** void three(void);
 137:main.c        **** void four(void);
 138:main.c        **** void six_1(void);
 139:main.c        **** void six_2(void);
 140:main.c        **** void six_3(void);
 141:main.c        **** void seven(void);
 142:main.c        **** void eight(void);
 143:main.c        **** 
 144:main.c        **** 
 145:main.c        **** void PID_heater(void);
 146:main.c        **** void PID_pump(uint16_t nurnst_val);
 147:main.c        **** void data_nurnst_update(uint16_t newval);		
 148:main.c        **** void data_nurnst_backup(void);		
 149:main.c        **** uint16_t data_nurnst_extrap(void);		
 150:main.c        **** void data_ip_update(uint16_t newval);		
 151:main.c        **** void data_ip_backup(void);		
 152:main.c        **** uint16_t data_ip_extrap(void);
 153:main.c        **** 
 154:main.c        **** 
 155:main.c        **** 
 156:main.c        **** ////Interrupt Service Routines
 157:main.c        **** ISR(ADC_vect)
 158:main.c        **** {
 159:main.c        **** ADC_data = readadc();
 160:main.c        **** 
 161:main.c        **** if (ADC_flag == 7)//
 162:main.c        **** {
 163:main.c        **** 	four();
 164:main.c        **** }	
 165:main.c        **** else if (ADC_flag == 2)
 166:main.c        **** {
 167:main.c        **** 	six_1();
 168:main.c        **** }
 169:main.c        **** else if (ADC_flag == 8)
 170:main.c        **** {
 171:main.c        **** 	six_2();
 172:main.c        **** }
 173:main.c        **** else if (ADC_flag == 9)
 174:main.c        **** {
 175:main.c        **** 	six_3();
 176:main.c        **** }	
 177:main.c        **** 
 178:main.c        **** else if (ADC_flag == 3)//nurnst
 179:main.c        **** {
 180:main.c        **** 	seven();
 181:main.c        **** }
 182:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 183:main.c        **** {
 184:main.c        **** 	eight();
 185:main.c        **** }
 186:main.c        **** 	else
 187:main.c        **** 	
 188:main.c        **** 	{
 189:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 190:main.c        **** 	}
 191:main.c        **** }
 192:main.c        **** ISR(TIMER0_OVF_vect)
 193:main.c        **** {		
 194:main.c        **** 	if (its_off==1)//pulse is off
 195:main.c        **** 	 {
 196:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 197:main.c        **** 		 its_off = 0;
 198:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 199:main.c        **** 		 if (newtimerval < 128)
 200:main.c        **** 		 {
 201:main.c        **** 			do_things();
 202:main.c        **** 		 }
 203:main.c        **** 		 TCNT0 = newtimerval;	 
 204:main.c        **** 	 }
 205:main.c        **** 	 else//pulse is on
 206:main.c        **** 	 {
 207:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 208:main.c        **** 		 its_off = 1; 
 209:main.c        **** 		 uint8_t newtimerval= (heat_power);
 210:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 211:main.c        **** 		 if (newtimerval < 128)
 212:main.c        **** 		 {
 213:main.c        **** 			do_things();
 214:main.c        **** 		 }
 215:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 216:main.c        **** 	 }
 217:main.c        **** 
 218:main.c        **** }
 219:main.c        **** 
 220:main.c        **** //////////////////////////////vvvvvvvvvvvvvvv MAIN  vvvvvvvvvvvvvvvvvvvvv//////////////////////////
 221:main.c        **** int main()
 222:main.c        **** {
 129               	.LM0:
 130               	.LFBB1:
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
 223:main.c        **** //set up all the pins as inputs and outputs
 224:main.c        **** /* 
 225:main.c        ****  * 	PC5 //outputs for R2R DAC/not used
 226:main.c        ****  * 	PC4
 227:main.c        ****  * 	PC3
 228:main.c        ****  *  PB5  
 229:main.c        ****  *  PB4
 230:main.c        ****  * 	PB0
 231:main.c        ****  * 
 232:main.c        ****  *  PD4  LED
 233:main.c        ****  * 
 234:main.c        ****  * Nernst DC connection: PB2
 235:main.c        ****  * nch mosfet for heater: PD5
 236:main.c        ****  * 
 237:main.c        ****  * PB1 = pump power OC1A timer out
 238:main.c        ****  * PB3 = output voltage OC2 timer output
 239:main.c        ****  *   //ADC:
 240:main.c        ****  * nernst V: 	adc2
 241:main.c        ****  * pump			adc0
 242:main.c        ****  *
 243:main.c        ****  */ 
 244:main.c        **** DDRC |= _BV(5)| _BV(4) | _BV(3);//six bit dac
 136               	.LM1:
 137 0000 84B3      		in r24,52-32
 138 0002 8863      		ori r24,lo8(56)
 139 0004 84BB      		out 52-32,r24
 245:main.c        **** DDRB |= _BV(5)| _BV(4) | _BV(0);//six bit dac
 141               	.LM2:
 142 0006 87B3      		in r24,55-32
 143 0008 8163      		ori r24,lo8(49)
 144 000a 87BB      		out 55-32,r24
 246:main.c        **** DDRD |= _BV(4);//LED
 146               	.LM3:
 147 000c 8C9A      		sbi 49-32,4
 247:main.c        **** 
 248:main.c        **** DDRD |= ( _BV(5));// mosfet for heater
 149               	.LM4:
 150 000e 8D9A      		sbi 49-32,5
 249:main.c        **** 
 250:main.c        **** ////setup uart:////
 251:main.c        **** cli();//  disable interrupts until things are set up
 152               	.LM5:
 153               	/* #APP */
 154               	 ;  251 "main.c" 1
 155 0010 F894      		cli
 156               	 ;  0 "" 2
 252:main.c        **** 	//init uart
 253:main.c        ****     /* set baud rate */
 254:main.c        ****    	UBRRH = (UBRRVAL >> 8);
 158               	.LM6:
 159               	/* #NOAPP */
 160 0012 10BC      		out 64-32,__zero_reg__
 255:main.c        ****    	UBRRL = (UBRRVAL & 0xff);
 162               	.LM7:
 163 0014 89E1      		ldi r24,lo8(25)
 164 0016 89B9      		out 41-32,r24
 256:main.c        ****     /* set frame format: 8 bit, no parity, 1 bit */
 257:main.c        ****     UCSRC |=  (1 << URSEL | 1 << UCSZ1 | 1 << UCSZ0);
 166               	.LM8:
 167 0018 80B5      		in r24,64-32
 168 001a 8668      		ori r24,lo8(-122)
 169 001c 80BD      		out 64-32,r24
 258:main.c        ****     UCSRB |= (1 << RXEN | 1 << TXEN | 1 << RXCIE);//enable receive, transmit, and receive complete 
 171               	.LM9:
 172 001e 8AB1      		in r24,42-32
 173 0020 8869      		ori r24,lo8(-104)
 174 0022 8AB9      		out 42-32,r24
 259:main.c        **** 
 260:main.c        **** //disable uart input, avoid Rx buffer overrun:
 261:main.c        **** UCSRB &= ~(1 << RXEN);
 176               	.LM10:
 177 0024 5498      		cbi 42-32,4
 262:main.c        **** UCSRB &= ~(1 << RXCIE);
 179               	.LM11:
 180 0026 5798      		cbi 42-32,7
 263:main.c        **** 
 264:main.c        **** setup_timer1();// pump control current dac on OC1A  
 182               	.LM12:
 183 0028 00D0      		rcall setup_timer1
 265:main.c        **** setup_timer2();//output 0-5v on OC2  
 185               	.LM13:
 186 002a 00D0      		rcall setup_timer2
 266:main.c        **** 	
 267:main.c        **** pid_Init(P_temp, I_temp, D_temp, &pidData_temp);//set up PID structure for temperature
 188               	.LM14:
 189 002c 8EE5      		ldi r24,lo8(350)
 190 002e 91E0      		ldi r25,hi8(350)
 191 0030 64E6      		ldi r22,lo8(100)
 192 0032 70E0      		ldi r23,hi8(100)
 193 0034 40E0      		ldi r20,lo8(0)
 194 0036 50E0      		ldi r21,hi8(0)
 195 0038 20E0      		ldi r18,lo8(pidData_temp)
 196 003a 30E0      		ldi r19,hi8(pidData_temp)
 197 003c 00D0      		rcall pid_Init
 268:main.c        **** pid_Init(P_pump, I_pump, D_pump, &pidData_pump);//set up PID structure for nernst
 199               	.LM15:
 200 003e 85E0      		ldi r24,lo8(5)
 201 0040 90E0      		ldi r25,hi8(5)
 202 0042 62E0      		ldi r22,lo8(2)
 203 0044 70E0      		ldi r23,hi8(2)
 204 0046 40E0      		ldi r20,lo8(0)
 205 0048 50E0      		ldi r21,hi8(0)
 206 004a 20E0      		ldi r18,lo8(pidData_pump)
 207 004c 30E0      		ldi r19,hi8(pidData_pump)
 208 004e 00D0      		rcall pid_Init
 269:main.c        **** sei();//enable interrupts
 210               	.LM16:
 211               	/* #APP */
 212               	 ;  269 "main.c" 1
 213 0050 7894      		sei
 214               	 ;  0 "" 2
 270:main.c        **** adc_init();
 216               	.LM17:
 217               	/* #NOAPP */
 218 0052 00D0      		rcall adc_init
 271:main.c        **** // ramp up heat:
 272:main.c        **** heat_power = 130;//initial time
 220               	.LM18:
 221 0054 82E8      		ldi r24,lo8(-126)
 222 0056 8093 0000 		sts heat_power,r24
 273:main.c        **** timer0init();
 224               	.LM19:
 225 005a 00D0      		rcall timer0init
 274:main.c        **** PORTD |= _BV(4);//LED on
 227               	.LM20:
 228 005c 949A      		sbi 50-32,4
 275:main.c        **** uart_putst("ramp temp\n");
 230               	.LM21:
 231 005e 80E0      		ldi r24,lo8(.LC1)
 232 0060 90E0      		ldi r25,hi8(.LC1)
 233 0062 00D0      		rcall uart_putst
 276:main.c        **** while (heat_power<200)
 235               	.LM22:
 236 0064 00C0      		rjmp .L2
 237               	.L3:
 277:main.c        **** {
 278:main.c        **** heat_power++;
 239               	.LM23:
 240 0066 8F5F      		subi r24,lo8(-(1))
 241 0068 8093 0000 		sts heat_power,r24
 242               	.LBB15:
 243               	.LBB16:
 245               	.Ltext1:
   1:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 247               	.LM24:
 248 006c 2FEB      		 ldi r18,lo8(119999)
 249 006e 34ED      	    ldi r19,hi8(119999)
 250 0070 41E0      	    ldi r20,hlo8(119999)
 251 0072 2150      	    1:subi r18,1
 252 0074 3040      	    sbci r19,0
 253 0076 4040      	    sbci r20,0
 254 0078 01F4      	    brne 1b
 255 007a 00C0      		rjmp .
 256 007c 0000      		nop
 257               	.LBE16:
 258               	.LBE15:
 260               	.Ltext2:
 279:main.c        **** _delay_ms(150);
 280:main.c        **** uart_put16dec(heat_power);
 262               	.LM25:
 263 007e 90E0      		ldi r25,lo8(0)
 264 0080 00D0      		rcall uart_put16dec
 281:main.c        **** uart_putch(',');
 266               	.LM26:
 267 0082 8CE2      		ldi r24,lo8(44)
 268 0084 00D0      		rcall uart_putch
 282:main.c        **** uart_putch(' ');
 270               	.LM27:
 271 0086 80E2      		ldi r24,lo8(32)
 272 0088 00D0      		rcall uart_putch
 273               	.L2:
 276:main.c        **** while (heat_power<200)
 275               	.LM28:
 276 008a 8091 0000 		lds r24,heat_power
 277 008e 883C      		cpi r24,lo8(-56)
 278 0090 00F0      		brlo .L3
 283:main.c        **** }
 284:main.c        **** uart_putch('\n');
 280               	.LM29:
 281 0092 8AE0      		ldi r24,lo8(10)
 282 0094 00D0      		rcall uart_putch
 285:main.c        **** ramp_flag=1;
 284               	.LM30:
 285 0096 81E0      		ldi r24,lo8(1)
 286 0098 8093 0000 		sts ramp_flag,r24
 287               	.L4:
 288 009c 00C0      		rjmp .L4
 290               	.Lscope1:
 291               		.text
 293               	.global	do_things
 295               	do_things:
 286:main.c        **** ///////////////////////
 287:main.c        **** while(1)
 288:main.c        **** 	{
 289:main.c        **** //most stuff handled in timer0 interrupt
 290:main.c        **** //Suggested: use a state machine, just read ADC data in the interrupt, and poll a flag to see if it
 291:main.c        **** 	}
 292:main.c        **** return 0;
 293:main.c        **** }
 294:main.c        **** //// end of main
 295:main.c        **** ///////////////////////////////////////////////////////// 
 296:main.c        **** //////vvvvvvvvvvvvvv functions vvvvvvvvvvvvvvvvv/////////
 297:main.c        **** /////////////////////////////////////////////////////////
 298:main.c        **** 
 299:main.c        **** void do_things(void)//do first adc
 300:main.c        **** {  
 297               	.LM31:
 298               	.LFBB2:
 299               	/* prologue: function */
 300               	/* frame size = 0 */
 301               	/* stack size = 0 */
 302               	.L__stack_usage = 0
 301:main.c        **** 	if (ramp_flag == 1)// startup temp ramp is finished 
 304               	.LM32:
 305 0000 8091 0000 		lds r24,ramp_flag
 306 0004 8130      		cpi r24,lo8(1)
 307 0006 01F4      		brne .L5
 302:main.c        **** 	{
 303:main.c        **** 		cycle_counter++;
 309               	.LM33:
 310 0008 8091 0000 		lds r24,cycle_counter
 311 000c 8F5F      		subi r24,lo8(-(1))
 312 000e 8093 0000 		sts cycle_counter,r24
 304:main.c        **** 		if (cycle_counter >3)
 314               	.LM34:
 315 0012 8091 0000 		lds r24,cycle_counter
 316 0016 8430      		cpi r24,lo8(4)
 317 0018 00F0      		brlo .L5
 318               	.LBB21:
 319               	.LBB22:
 305:main.c        **** 		{
 306:main.c        **** 
 307:main.c        **** 			cycle_counter = 0;//reset
 321               	.LM35:
 322 001a 1092 0000 		sts cycle_counter,__zero_reg__
 323               	.LBB23:
 324               	.LBB24:
 326               	.Ltext3:
 165:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 328               	.LM36:
 329 001e 82E4      		 ldi r24,lo8(66)
 330 0020 8A95      	    1:dec r24
 331 0022 01F4      	    brne 1b
 332 0024 00C0      		rjmp .
 333               	.LBE24:
 334               	.LBE23:
 336               	.Ltext4:
 308:main.c        **** 			_delay_us(50);//maybe let things settle?
 309:main.c        **** 			ADC_flag = 7;//sets to run function after conversion
 338               	.LM37:
 339 0026 87E0      		ldi r24,lo8(7)
 340 0028 8093 0000 		sts ADC_flag,r24
 310:main.c        **** 			ADMUX =(192 + 1);//V refrence plus mux 
 342               	.LM38:
 343 002c 81EC      		ldi r24,lo8(-63)
 344 002e 87B9      		out 39-32,r24
 311:main.c        **** 			//use 192 for internal 2.5v ref//use 64 for avcc as vref			
 312:main.c        **** 			ADCSRA |= _BV(ADSC);// starts  conversion
 346               	.LM39:
 347 0030 369A      		sbi 38-32,6
 348               	.L5:
 349 0032 0895      		ret
 350               	.LBE22:
 351               	.LBE21:
 353               	.Lscope2:
 355               	.global	__vector_9
 357               	__vector_9:
 193:main.c        **** {		
 359               	.LM40:
 360               	.LFBB3:
 361 0034 1F92      		push r1
 362 0036 0F92      		push r0
 363 0038 0FB6      		in r0,__SREG__
 364 003a 0F92      		push r0
 365 003c 1124      		clr __zero_reg__
 366 003e 2F93      		push r18
 367 0040 3F93      		push r19
 368 0042 4F93      		push r20
 369 0044 5F93      		push r21
 370 0046 6F93      		push r22
 371 0048 7F93      		push r23
 372 004a 8F93      		push r24
 373 004c 9F93      		push r25
 374 004e AF93      		push r26
 375 0050 BF93      		push r27
 376 0052 CF93      		push r28
 377 0054 EF93      		push r30
 378 0056 FF93      		push r31
 379               	/* prologue: Signal */
 380               	/* frame size = 0 */
 381               	/* stack size = 16 */
 382               	.L__stack_usage = 16
 194:main.c        **** 	if (its_off==1)//pulse is off
 384               	.LM41:
 385 0058 8091 0000 		lds r24,its_off
 386 005c 8130      		cpi r24,lo8(1)
 387 005e 01F4      		brne .L8
 388               	.LBB25:
 196:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 390               	.LM42:
 391 0060 959A      		sbi 50-32,5
 197:main.c        **** 		 its_off = 0;
 393               	.LM43:
 394 0062 1092 0000 		sts its_off,__zero_reg__
 198:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 396               	.LM44:
 397 0066 C091 0000 		lds r28,heat_power
 398 006a C095      		com r28
 399 006c 00C0      		rjmp .L14
 400               	.L8:
 401               	.LBE25:
 402               	.LBB26:
 207:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 404               	.LM45:
 405 006e 9598      		cbi 50-32,5
 208:main.c        **** 		 its_off = 1; 
 407               	.LM46:
 408 0070 81E0      		ldi r24,lo8(1)
 409 0072 8093 0000 		sts its_off,r24
 209:main.c        **** 		 uint8_t newtimerval= (heat_power);
 411               	.LM47:
 412 0076 C091 0000 		lds r28,heat_power
 210:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 414               	.LM48:
 415 007a C2BF      		out 82-32,r28
 416               	.L14:
 211:main.c        **** 		 if (newtimerval < 128)
 418               	.LM49:
 419 007c C7FF      		sbrs r28,7
 213:main.c        **** 			do_things();
 421               	.LM50:
 422 007e 00D0      		rcall do_things
 423               	.L11:
 215:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 425               	.LM51:
 426 0080 C2BF      		out 82-32,r28
 427               	/* epilogue start */
 428               	.LBE26:
 218:main.c        **** }
 430               	.LM52:
 431 0082 FF91      		pop r31
 432 0084 EF91      		pop r30
 433 0086 CF91      		pop r28
 434 0088 BF91      		pop r27
 435 008a AF91      		pop r26
 436 008c 9F91      		pop r25
 437 008e 8F91      		pop r24
 438 0090 7F91      		pop r23
 439 0092 6F91      		pop r22
 440 0094 5F91      		pop r21
 441 0096 4F91      		pop r20
 442 0098 3F91      		pop r19
 443 009a 2F91      		pop r18
 444 009c 0F90      		pop r0
 445 009e 0FBE      		out __SREG__,r0
 446 00a0 0F90      		pop r0
 447 00a2 1F90      		pop r1
 448 00a4 1895      		reti
 456               	.Lscope3:
 458               	.global	four
 460               	four:
 313:main.c        **** 		}
 314:main.c        **** 	}	
 315:main.c        **** }
 316:main.c        **** void four(void)//record aux adc 1, mux for pump current
 317:main.c        **** { 
 462               	.LM53:
 463               	.LFBB4:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466               	/* stack size = 0 */
 467               	.L__stack_usage = 0
 318:main.c        **** 
 319:main.c        **** 	charspot = put_in_string(ADC_data,'\0',charspot);//puts data in big string and sends back new char
 469               	.LM54:
 470 00a6 4091 0000 		lds r20,charspot
 471 00aa 8091 0000 		lds r24,ADC_data
 472 00ae 9091 0000 		lds r25,ADC_data+1
 473 00b2 60E0      		ldi r22,lo8(0)
 474 00b4 00D0      		rcall put_in_string
 475 00b6 8093 0000 		sts charspot,r24
 320:main.c        **** 	ADC_flag = 2;
 477               	.LM55:
 478 00ba 82E0      		ldi r24,lo8(2)
 479 00bc 8093 0000 		sts ADC_flag,r24
 321:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 481               	.LM56:
 482 00c0 80EC      		ldi r24,lo8(-64)
 483 00c2 87B9      		out 39-32,r24
 322:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 485               	.LM57:
 486 00c4 369A      		sbi 38-32,6
 487               	/* epilogue start */
 323:main.c        **** }	
 489               	.LM58:
 490 00c6 0895      		ret
 492               	.Lscope4:
 494               	.global	six_1
 496               	six_1:
 324:main.c        **** 
 325:main.c        **** void six_1(void)//measures pump current 1/3 sample
 326:main.c        **** {	
 498               	.LM59:
 499               	.LFBB5:
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 327:main.c        **** 
 328:main.c        **** 	pump = ADC_data;
 505               	.LM60:
 506 00c8 8091 0000 		lds r24,ADC_data
 507 00cc 9091 0000 		lds r25,ADC_data+1
 508 00d0 9093 0000 		sts pump+1,r25
 509 00d4 8093 0000 		sts pump,r24
 329:main.c        **** 	ADC_flag = 8;	
 511               	.LM61:
 512 00d8 88E0      		ldi r24,lo8(8)
 513 00da 8093 0000 		sts ADC_flag,r24
 330:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 515               	.LM62:
 516 00de 369A      		sbi 38-32,6
 517               	/* epilogue start */
 331:main.c        **** }
 519               	.LM63:
 520 00e0 0895      		ret
 522               	.Lscope5:
 524               	.global	six_2
 526               	six_2:
 332:main.c        **** 
 333:main.c        **** void six_2(void)//measures pump current 2/3
 334:main.c        **** {	
 528               	.LM64:
 529               	.LFBB6:
 530               	/* prologue: function */
 531               	/* frame size = 0 */
 532               	/* stack size = 0 */
 533               	.L__stack_usage = 0
 335:main.c        **** 
 336:main.c        **** 	pump = pump + ADC_data;
 535               	.LM65:
 536 00e2 8091 0000 		lds r24,pump
 537 00e6 9091 0000 		lds r25,pump+1
 538 00ea 2091 0000 		lds r18,ADC_data
 539 00ee 3091 0000 		lds r19,ADC_data+1
 540 00f2 820F      		add r24,r18
 541 00f4 931F      		adc r25,r19
 542 00f6 9093 0000 		sts pump+1,r25
 543 00fa 8093 0000 		sts pump,r24
 337:main.c        **** 	ADC_flag = 9;	
 545               	.LM66:
 546 00fe 89E0      		ldi r24,lo8(9)
 547 0100 8093 0000 		sts ADC_flag,r24
 338:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 549               	.LM67:
 550 0104 369A      		sbi 38-32,6
 551               	/* epilogue start */
 339:main.c        **** }
 553               	.LM68:
 554 0106 0895      		ret
 556               	.Lscope6:
 558               	.global	six_3
 560               	six_3:
 340:main.c        **** 
 341:main.c        **** void six_3(void)//measures pump current 3/3
 342:main.c        **** {	
 562               	.LM69:
 563               	.LFBB7:
 564               	/* prologue: function */
 565               	/* frame size = 0 */
 566               	/* stack size = 0 */
 567               	.L__stack_usage = 0
 343:main.c        **** 
 344:main.c        **** 	pump = pump + ADC_data;
 569               	.LM70:
 570 0108 8091 0000 		lds r24,pump
 571 010c 9091 0000 		lds r25,pump+1
 572 0110 2091 0000 		lds r18,ADC_data
 573 0114 3091 0000 		lds r19,ADC_data+1
 574 0118 820F      		add r24,r18
 575 011a 931F      		adc r25,r19
 576 011c 9093 0000 		sts pump+1,r25
 577 0120 8093 0000 		sts pump,r24
 345:main.c        **** 	pump = pump/3;
 579               	.LM71:
 580 0124 8091 0000 		lds r24,pump
 581 0128 9091 0000 		lds r25,pump+1
 582 012c 63E0      		ldi r22,lo8(3)
 583 012e 70E0      		ldi r23,hi8(3)
 584 0130 00D0      		rcall __udivmodhi4
 585 0132 7093 0000 		sts pump+1,r23
 586 0136 6093 0000 		sts pump,r22
 346:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 588               	.LM72:
 589 013a 8091 0000 		lds r24,pump
 590 013e 9091 0000 		lds r25,pump+1
 591 0142 4091 0000 		lds r20,charspot
 592 0146 60E0      		ldi r22,lo8(0)
 593 0148 00D0      		rcall put_in_string
 594 014a 8093 0000 		sts charspot,r24
 347:main.c        **** 	ADC_flag = 3;	
 596               	.LM73:
 597 014e 83E0      		ldi r24,lo8(3)
 598 0150 8093 0000 		sts ADC_flag,r24
 348:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 600               	.LM74:
 601 0154 82EC      		ldi r24,lo8(-62)
 602 0156 87B9      		out 39-32,r24
 349:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 604               	.LM75:
 605 0158 369A      		sbi 38-32,6
 606               	/* epilogue start */
 350:main.c        **** }
 608               	.LM76:
 609 015a 0895      		ret
 611               	.Lscope7:
 613               	.global	seven
 615               	seven:
 351:main.c        **** 
 352:main.c        **** void seven(void)//measure nurnst 
 353:main.c        **** {
 617               	.LM77:
 618               	.LFBB8:
 619               	/* prologue: function */
 620               	/* frame size = 0 */
 621               	/* stack size = 0 */
 622               	.L__stack_usage = 0
 354:main.c        **** 
 355:main.c        **** 	nurnst = ADC_data;
 624               	.LM78:
 625 015c 8091 0000 		lds r24,ADC_data
 626 0160 9091 0000 		lds r25,ADC_data+1
 627 0164 9093 0000 		sts nurnst+1,r25
 628 0168 8093 0000 		sts nurnst,r24
 356:main.c        **** 	charspot = put_in_string(nurnst,'\0',charspot);//puts data in big string
 630               	.LM79:
 631 016c 8091 0000 		lds r24,nurnst
 632 0170 9091 0000 		lds r25,nurnst+1
 633 0174 4091 0000 		lds r20,charspot
 634 0178 60E0      		ldi r22,lo8(0)
 635 017a 00D0      		rcall put_in_string
 636 017c 8093 0000 		sts charspot,r24
 357:main.c        **** 	ADC_flag = 4;
 638               	.LM80:
 639 0180 84E0      		ldi r24,lo8(4)
 640 0182 8093 0000 		sts ADC_flag,r24
 358:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 642               	.LM81:
 643 0186 82EC      		ldi r24,lo8(-62)
 644 0188 87B9      		out 39-32,r24
 359:main.c        **** 	DDRB |= _BV(2);// dc for temperature measurment
 646               	.LM82:
 647 018a BA9A      		sbi 55-32,2
 648               	.LBB27:
 649               	.LBB28:
 651               	.Ltext5:
 653               	.LM83:
 654 018c 8AE1      		 ldi r24,lo8(26)
 655 018e 8A95      	    1:dec r24
 656 0190 01F4      	    brne 1b
 657 0192 00C0      		rjmp .
 658               	.LBE28:
 659               	.LBE27:
 661               	.Ltext6:
 360:main.c        **** 	_delay_us(20);
 361:main.c        **** 	PORTB |= _BV(2);//DC on
 663               	.LM84:
 664 0194 C29A      		sbi 56-32,2
 362:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 666               	.LM85:
 667 0196 369A      		sbi 38-32,6
 668               	/* epilogue start */
 363:main.c        **** }
 670               	.LM86:
 671 0198 0895      		ret
 673               	.Lscope8:
 675               	.global	readadc
 677               	readadc:
 364:main.c        **** 
 365:main.c        **** void eight(void)
 366:main.c        **** {
 367:main.c        **** 
 368:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 369:main.c        **** 	_delay_us(20);
 370:main.c        **** 	DDRB &=~ _BV(2);//hiZ
 371:main.c        **** 	DC_val = ADC_data;
 372:main.c        **** //	charspot = put_in_string(DC_val,'d',charspot);//puts data in big string
 373:main.c        **** 	ADC_flag = 0;	
 374:main.c        **** 	////do calculations and PIDs
 375:main.c        **** 	measured_temperature = (DC_val - nurnst);
 376:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 377:main.c        **** 		{
 378:main.c        **** 		measured_temperature = (255 - measured_temperature);
 379:main.c        **** 		}
 380:main.c        **** 	else
 381:main.c        **** 		{
 382:main.c        **** 		measured_temperature =0;
 383:main.c        **** 		}
 384:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 385:main.c        **** 		{
 386:main.c        **** 		PORTD &=~ _BV(4);//LED off
 387:main.c        **** 		}
 388:main.c        **** 	else
 389:main.c        **** 		{
 390:main.c        **** 		PORTD |= _BV(4);//LED on
 391:main.c        **** 		}
 392:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 393:main.c        **** 	charspot = put_in_string(nurnst_spike,'\0',charspot);//puts data in big string
 394:main.c        **** 	
 395:main.c        **** 	//Filtering:
 396:main.c        **** 
 397:main.c        **** 	data_ip_update(pump);
 398:main.c        **** 	data_nurnst_update(nurnst);
 399:main.c        **** 	
 400:main.c        **** 	uint16_t nurnst_calc = 0;
 401:main.c        **** 	uint16_t ip_calc = 0;
 402:main.c        **** 
 403:main.c        **** 	if( nurnst_spike == 0)// nurnst was not spiking
 404:main.c        **** 	{
 405:main.c        **** 		if( abs((nurnst_data[NURNSTPOINTS-2])-nurnst) > 30)//nurnst spiked 35 or more in one cycle
 406:main.c        **** 		{
 407:main.c        **** 			nurnst_spike = 1;
 408:main.c        **** 			//backup
 409:main.c        **** 			data_ip_backup();
 410:main.c        **** 			data_nurnst_backup();
 411:main.c        **** 			//create extrapolated values for nurnst and ip 
 412:main.c        **** 			nurnst_calc = data_nurnst_extrap();
 413:main.c        **** 			ip_calc = data_ip_extrap();
 414:main.c        **** 		}
 415:main.c        **** 		else{nurnst_calc = nurnst; ip_calc = pump;}//no spike, just pass values on.
 416:main.c        **** 	}
 417:main.c        **** 	else//nurnst is in a spike
 418:main.c        **** 	{
 419:main.c        **** 		timeinspike++;
 420:main.c        **** 		data_nurnst_backup();
 421:main.c        **** 		nurnst_calc = data_nurnst_extrap();
 422:main.c        **** 		if ( (abs(nurnst_calc-nurnst)<10)||(timeinspike>10) )//back in range or not a spike
 423:main.c        **** 		{
 424:main.c        **** 			nurnst_calc = nurnst; ip_calc = pump;
 425:main.c        **** 			data_nurnst_update(nurnst);//restor measured values
 426:main.c        **** 			nurnst_spike = 0;
 427:main.c        **** 			timeinspike = 0;
 428:main.c        **** 			nurnst_calc = nurnst; ip_calc = pump;//pass values on
 429:main.c        **** 		}
 430:main.c        **** 		else //or not in range, continue to use extrapolated
 431:main.c        **** 		{
 432:main.c        **** 			data_ip_backup();
 433:main.c        **** 			ip_calc = data_ip_extrap();
 434:main.c        **** 		}
 435:main.c        **** 	}
 436:main.c        **** 
 437:main.c        **** 	PID_pump(nurnst_calc);//run PID on pump and update pump pwm.
 438:main.c        **** 	
 439:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string
 440:main.c        **** 	charspot = put_in_string(nurnst_calc,'\0',charspot);//puts data in big string and sends back new c
 441:main.c        **** 	charspot = put_in_string(ip_calc,'\0',charspot);//puts data in big string and sends back new char 
 442:main.c        **** 			
 443:main.c        **** 
 444:main.c        **** 	//if no spiked flag:
 445:main.c        **** 		//check for nurnst spike (check nurnst_data and current value.  >35)
 446:main.c        **** 		//if spiked, 
 447:main.c        **** 			//calculate replacement nurnst value based on slope so far nurnst_calc(previous average plus slo
 448:main.c        **** 			//calculate replacement Ip same way.
 449:main.c        **** 			//set spiked flag.
 450:main.c        **** 		//if no spike , nurnst_calc = nurnst, ip_calc = pump
 451:main.c        **** 	//if spiked flag:
 452:main.c        **** 		//calculate nurnst_calc and ip_calc:   
 453:main.c        **** 		// If  nurnst_calk is with 10 of nurnst
 454:main.c        **** 			//go back to using real values. nurnst_calc = nurnst, ip_calc = pump
 455:main.c        **** 			//spiked flag 0
 456:main.c        **** 		//Nurnst still not back,
 457:main.c        **** 			//just keep using calculated values.
 458:main.c        **** 	//submit nurnst_calc and ip_calc to PID and slope.
 459:main.c        **** 	////////////count loops in spike: if too many, just go out of spike.n 
 460:main.c        **** 
 461:main.c        **** 	
 462:main.c        **** 	//calculate lambda output from Look Up Table:
 463:main.c        **** 	struct two_col{
 464:main.c        **** 		uint16_t x;
 465:main.c        **** 		uint16_t y;
 466:main.c        **** 	}; 
 467:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 468:main.c        **** 		{1,0},
 469:main.c        **** 		{480,68},
 470:main.c        **** 		{570,80},
 471:main.c        **** 		{610,85},
 472:main.c        **** 		{650,90},
 473:main.c        **** 		{690,100},
 474:main.c        **** 		{700,110},
 475:main.c        **** 		{750,143},
 476:main.c        **** 		{795,170},
 477:main.c        **** 		{810,242},
 478:main.c        **** 		{845,20200},
 479:main.c        **** 		{1024,26000},
 480:main.c        **** 		};
 481:main.c        **** 	uint8_t n = 12;//number of rows in table	
 482:main.c        **** 	uint32_t lambda=0;
 483:main.c        **** 	//out of range check:
 484:main.c        **** 	if (ip_calc<lambda_curve[0].x)//smaller than the lowest value in LOT
 485:main.c        **** 	{lambda = lambda_curve[0].y;}
 486:main.c        **** 	else if (ip_calc>lambda_curve[n-1].x)//larger than the highest value in the LOT
 487:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 488:main.c        **** 	//lookup in table, interpolate
 489:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 490:main.c        **** 	{
 491:main.c        **** 		if ( (lambda_curve[i].x <= ip_calc )&& (lambda_curve[i+1].x >= ip_calc) )
 492:main.c        **** 		{
 493:main.c        **** 			uint16_t diffx = ip_calc - lambda_curve[i].x; //difference between the pump value and the x valu
 494:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 495:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 496:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 497:main.c        **** 		}
 498:main.c        **** 	}
 499:main.c        **** 	lambda = lambda + POSOFFSET;
 500:main.c        **** 	lambda = lambda - NEGOFFSET;
 501:main.c        **** 	
 502:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 503:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 504:main.c        **** 	{
 505:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 506:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 507:main.c        **** 	}
 508:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 509:main.c        **** 	else {zero_to_5_WB = 0;}
 510:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 511:main.c        **** //	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts pass
 512:main.c        **** 	
 513:main.c        **** 
 514:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 515:main.c        **** //	charspot = put_in_string(heat_power,'h',charspot);//puts data in big string
 516:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 517:main.c        **** }
 518:main.c        **** 	
 519:main.c        **** uint16_t readadc(void)
 520:main.c        **** {
 679               	.LM87:
 680               	.LFBB9:
 681               	/* prologue: function */
 682               	/* frame size = 0 */
 683               	/* stack size = 0 */
 684               	.L__stack_usage = 0
 521:main.c        **** 	uint8_t adcDataL = ADCL;
 686               	.LM88:
 687 019a 84B1      		in r24,36-32
 522:main.c        ****     uint8_t adcDataH = ADCH;
 689               	.LM89:
 690 019c 95B1      		in r25,37-32
 523:main.c        ****     uint16_t adcData = 0;
 524:main.c        ****     adcData = adcData | adcDataH;
 525:main.c        ****     adcData = adcData << 8;//left shift 8 spots
 692               	.LM90:
 693 019e 392F      		mov r19,r25
 694 01a0 20E0      		ldi r18,lo8(0)
 526:main.c        ****     adcData = adcData | adcDataL;
 696               	.LM91:
 697 01a2 90E0      		ldi r25,lo8(0)
 698 01a4 822B      		or r24,r18
 699 01a6 932B      		or r25,r19
 700               	/* epilogue start */
 527:main.c        ****     return adcData;
 528:main.c        **** }
 702               	.LM92:
 703 01a8 0895      		ret
 709               	.Lscope9:
 711               	.global	PID_heater
 713               	PID_heater:
 529:main.c        **** 
 530:main.c        **** void PID_heater(void)
 531:main.c        **** {
 715               	.LM93:
 716               	.LFBB10:
 717               	/* prologue: function */
 718               	/* frame size = 0 */
 719               	/* stack size = 0 */
 720               	.L__stack_usage = 0
 532:main.c        **** 	int32_t calculated = pid_Controller(TARGET_TEMP, measured_temperature, &pidData_temp);  // for tem
 722               	.LM94:
 723 01aa 6091 0000 		lds r22,measured_temperature
 724 01ae 7091 0000 		lds r23,measured_temperature+1
 725 01b2 8DEE      		ldi r24,lo8(237)
 726 01b4 90E0      		ldi r25,hi8(237)
 727 01b6 40E0      		ldi r20,lo8(pidData_temp)
 728 01b8 50E0      		ldi r21,hi8(pidData_temp)
 729 01ba 00D0      		rcall pid_Controller
 730 01bc AA27      		clr r26
 731 01be 97FD      		sbrc r25,7
 732 01c0 A095      		com r26
 733 01c2 BA2F      		mov r27,r26
 533:main.c        **** 
 534:main.c        **** 	if ((calculated) > 255 )
 735               	.LM95:
 736 01c4 8F3F      		cpi r24,lo8(255)
 737 01c6 9105      		cpc r25,__zero_reg__
 738 01c8 A105      		cpc r26,__zero_reg__
 739 01ca B105      		cpc r27,__zero_reg__
 740 01cc 01F0      		breq .L22
 741 01ce 04F0      		brlt .L22
 535:main.c        **** 	{
 536:main.c        **** 		heat_power = 255 ;
 743               	.LM96:
 744 01d0 8FEF      		ldi r24,lo8(-1)
 745 01d2 00C0      		rjmp .L24
 746               	.L22:
 537:main.c        **** 	}
 538:main.c        **** 	else if ((calculated) < 0 )
 748               	.LM97:
 749 01d4 B7FF      		sbrs r27,7
 750 01d6 00C0      		rjmp .L24
 539:main.c        **** 	{
 540:main.c        **** 		heat_power = 0 ;
 752               	.LM98:
 753 01d8 1092 0000 		sts heat_power,__zero_reg__
 754 01dc 0895      		ret
 755               	.L24:
 541:main.c        **** 	}
 542:main.c        **** 	else
 543:main.c        **** 	{
 544:main.c        **** 		heat_power =(calculated);
 757               	.LM99:
 758 01de 8093 0000 		sts heat_power,r24
 759 01e2 0895      		ret
 764               	.Lscope10:
 767               	.global	PID_pump
 769               	PID_pump:
 545:main.c        **** 	}
 546:main.c        **** 
 547:main.c        **** }
 548:main.c        **** 
 549:main.c        **** void PID_pump(uint16_t nurnst_val)
 550:main.c        **** {
 771               	.LM100:
 772               	.LFBB11:
 773               	/* prologue: function */
 774               	/* frame size = 0 */
 775               	/* stack size = 0 */
 776               	.L__stack_usage = 0
 551:main.c        **** 	int32_t pumpV =  ( pid_Controller(TARGET_NERNST, nurnst, &pidData_pump) );  // PID
 778               	.LM101:
 779 01e4 6091 0000 		lds r22,nurnst
 780 01e8 7091 0000 		lds r23,nurnst+1
 781 01ec 85E3      		ldi r24,lo8(821)
 782 01ee 93E0      		ldi r25,hi8(821)
 783 01f0 40E0      		ldi r20,lo8(pidData_pump)
 784 01f2 50E0      		ldi r21,hi8(pidData_pump)
 785 01f4 00D0      		rcall pid_Controller
 786 01f6 AA27      		clr r26
 787 01f8 97FD      		sbrc r25,7
 788 01fa A095      		com r26
 789 01fc BA2F      		mov r27,r26
 552:main.c        **** 	pumpV = pumpV + ZERO_CURRENT;// is zero current.
 791               	.LM102:
 792 01fe 8F59      		subi r24,lo8(-(97))
 793 0200 9F4F      		sbci r25,hi8(-(97))
 794 0202 AF4F      		sbci r26,hlo8(-(97))
 795 0204 BF4F      		sbci r27,hhi8(-(97))
 553:main.c        **** //apply calculated to pump dac timer
 554:main.c        **** if ((pumpV) > MAXPUMP_I)
 797               	.LM103:
 798 0206 8A34      		cpi r24,lo8(330)
 799 0208 21E0      		ldi r18,hi8(330)
 800 020a 9207      		cpc r25,r18
 801 020c 20E0      		ldi r18,hlo8(330)
 802 020e A207      		cpc r26,r18
 803 0210 20E0      		ldi r18,hhi8(330)
 804 0212 B207      		cpc r27,r18
 805 0214 04F0      		brlt .L26
 555:main.c        **** 	{
 556:main.c        **** 		OCR1A = MAXPUMP_I;
 807               	.LM104:
 808 0216 89E4      		ldi r24,lo8(329)
 809 0218 91E0      		ldi r25,hi8(329)
 810 021a 00C0      		rjmp .L28
 811               	.L26:
 557:main.c        **** 	}
 558:main.c        **** else if ((pumpV) < MINPUMP_I)
 813               	.LM105:
 814 021c B7FF      		sbrs r27,7
 815 021e 00C0      		rjmp .L28
 559:main.c        **** 	{
 560:main.c        **** 		OCR1A = MINPUMP_I;
 817               	.LM106:
 818 0220 1BBC      		out 74+1-32,__zero_reg__
 819 0222 1ABC      		out 74-32,__zero_reg__
 820 0224 0895      		ret
 821               	.L28:
 561:main.c        **** 	}
 562:main.c        **** 	else
 563:main.c        **** 	{
 564:main.c        **** 		OCR1A =(pumpV);
 823               	.LM107:
 824 0226 9BBD      		out 74+1-32,r25
 825 0228 8ABD      		out 74-32,r24
 826 022a 0895      		ret
 828               	.Lscope11:
 831               	.global	data_nurnst_update
 833               	data_nurnst_update:
 565:main.c        **** 	}
 566:main.c        **** }
 567:main.c        **** 
 568:main.c        **** void data_nurnst_update(uint16_t newval)		
 569:main.c        **** {
 835               	.LM108:
 836               	.LFBB12:
 837               	/* prologue: function */
 838               	/* frame size = 0 */
 839               	/* stack size = 0 */
 840               	.L__stack_usage = 0
 841               	.LBB29:
 570:main.c        **** 	for (uint8_t i = 0; i<(NURNSTPOINTS); i++)//shift points
 571:main.c        **** 	{
 572:main.c        **** 		nurnst_data[i]=nurnst_data[i+1]; 
 843               	.LM109:
 844 022c 2091 0000 		lds r18,nurnst_data+2
 845 0230 3091 0000 		lds r19,nurnst_data+2+1
 846 0234 E0E0      		ldi r30,lo8(nurnst_data+2)
 847 0236 F0E0      		ldi r31,hi8(nurnst_data+2)
 848 0238 3293      		st -Z,r19
 849 023a 2293      		st -Z,r18
 850 023c 2481      		ldd r18,Z+4
 851 023e 3581      		ldd r19,Z+5
 852 0240 3093 0000 		sts nurnst_data+2+1,r19
 853 0244 2093 0000 		sts nurnst_data+2,r18
 854 0248 2681      		ldd r18,Z+6
 855 024a 3781      		ldd r19,Z+7
 856 024c 3583      		std Z+5,r19
 857 024e 2483      		std Z+4,r18
 858               	.LBE29:
 573:main.c        **** 	}
 574:main.c        **** 	nurnst_data[NURNSTPOINTS] = newval;//put in latest value
 860               	.LM110:
 861 0250 9783      		std Z+7,r25
 862 0252 8683      		std Z+6,r24
 863               	/* epilogue start */
 575:main.c        **** }
 865               	.LM111:
 866 0254 0895      		ret
 868               	.Lscope12:
 870               	.global	data_nurnst_backup
 872               	data_nurnst_backup:
 576:main.c        **** void data_nurnst_backup(void)		
 577:main.c        **** {
 874               	.LM112:
 875               	.LFBB13:
 876               	/* prologue: function */
 877               	/* frame size = 0 */
 878               	/* stack size = 0 */
 879               	.L__stack_usage = 0
 880               	.LBB30:
 578:main.c        **** 	for (uint8_t i = (NURNSTPOINTS); i>0; i--)//shift points backwards
 579:main.c        **** 	{
 580:main.c        **** 		nurnst_data[i]=nurnst_data[i-1];
 882               	.LM113:
 883 0256 80E0      		ldi r24,lo8(nurnst_data+4)
 884 0258 90E0      		ldi r25,hi8(nurnst_data+4)
 885 025a 2091 0000 		lds r18,nurnst_data+4
 886 025e 3091 0000 		lds r19,nurnst_data+4+1
 887 0262 3093 0000 		sts nurnst_data+6+1,r19
 888 0266 2093 0000 		sts nurnst_data+6,r18
 889 026a FC01      		movw r30,r24
 890 026c 3297      		sbiw r30,2
 891 026e 2081      		ld r18,Z
 892 0270 3181      		ldd r19,Z+1
 893 0272 3093 0000 		sts nurnst_data+4+1,r19
 894 0276 2093 0000 		sts nurnst_data+4,r18
 895 027a 0497      		sbiw r24,4
 896 027c DC01      		movw r26,r24
 897 027e 8D91      		ld r24,X+
 898 0280 9C91      		ld r25,X
 899 0282 1197      		sbiw r26,1
 900 0284 9183      		std Z+1,r25
 901 0286 8083      		st Z,r24
 902               	/* epilogue start */
 903               	.LBE30:
 581:main.c        **** 	}
 582:main.c        **** }
 905               	.LM114:
 906 0288 0895      		ret
 908               	.Lscope13:
 910               	.global	data_nurnst_extrap
 912               	data_nurnst_extrap:
 583:main.c        **** uint16_t data_nurnst_extrap(void)//extrapolates 1 point		
 584:main.c        **** {//calculate sums for least squares:
 914               	.LM115:
 915               	.LFBB14:
 916 028a 0F93      		push r16
 917 028c 1F93      		push r17
 918 028e CF93      		push r28
 919 0290 DF93      		push r29
 920               	/* prologue: function */
 921               	/* frame size = 0 */
 922               	/* stack size = 4 */
 923               	.L__stack_usage = 4
 925               	.LM116:
 926 0292 41E0      		ldi r20,lo8(1)
 927 0294 50E0      		ldi r21,hi8(1)
 585:main.c        **** 	int8_t SUMx = 0; 
 586:main.c        **** 	int16_t SUMy =0;
 587:main.c        **** 	int16_t SUMxy = 0; 
 588:main.c        **** 	int16_t SUMxx  = 0;
 589:main.c        **** 	uint16_t average = 0;
 929               	.LM117:
 930 0296 00E0      		ldi r16,lo8(0)
 931 0298 10E0      		ldi r17,hi8(0)
 588:main.c        **** 	int16_t SUMxx  = 0;
 933               	.LM118:
 934 029a C0E0      		ldi r28,lo8(0)
 935 029c D0E0      		ldi r29,hi8(0)
 587:main.c        **** 	int16_t SUMxy = 0; 
 937               	.LM119:
 938 029e A0E0      		ldi r26,lo8(0)
 939 02a0 B0E0      		ldi r27,hi8(0)
 586:main.c        **** 	int16_t SUMy =0;
 941               	.LM120:
 942 02a2 60E0      		ldi r22,lo8(0)
 943 02a4 70E0      		ldi r23,hi8(0)
 944               	.L32:
 945               	.LBB31:
 590:main.c        **** 	for (uint8_t i = 1; i<(NURNSTPOINTS+1); i++)//SUMx
 591:main.c        **** 	{
 592:main.c        **** 		SUMx = SUMx+i;
 593:main.c        **** 		SUMy = SUMy+nurnst_data[i];
 947               	.LM121:
 948 02a6 FA01      		movw r30,r20
 949 02a8 EE0F      		lsl r30
 950 02aa FF1F      		rol r31
 951 02ac E050      		subi r30,lo8(-(nurnst_data))
 952 02ae F040      		sbci r31,hi8(-(nurnst_data))
 953 02b0 8081      		ld r24,Z
 954 02b2 9181      		ldd r25,Z+1
 955 02b4 680F      		add r22,r24
 956 02b6 791F      		adc r23,r25
 594:main.c        **** 		SUMxy = SUMxy+(i*nurnst_data[i]);
 958               	.LM122:
 959 02b8 8081      		ld r24,Z
 960 02ba 9181      		ldd r25,Z+1
 961 02bc 849F      		mul r24,r20
 962 02be 9001      		movw r18,r0
 963 02c0 859F      		mul r24,r21
 964 02c2 300D      		add r19,r0
 965 02c4 949F      		mul r25,r20
 966 02c6 300D      		add r19,r0
 967 02c8 1124      		clr r1
 968 02ca A20F      		add r26,r18
 969 02cc B31F      		adc r27,r19
 595:main.c        **** 		SUMxx = SUMxx+(i*i);
 971               	.LM123:
 972 02ce 449F      		mul r20,r20
 973 02d0 C001      		movw r24,r0
 974 02d2 459F      		mul r20,r21
 975 02d4 900D      		add r25,r0
 976 02d6 549F      		mul r21,r20
 977 02d8 900D      		add r25,r0
 978 02da 1124      		clr r1
 979 02dc C80F      		add r28,r24
 980 02de D91F      		adc r29,r25
 596:main.c        **** 		average = average+nurnst_data[i];
 982               	.LM124:
 983 02e0 8081      		ld r24,Z
 984 02e2 9181      		ldd r25,Z+1
 985 02e4 080F      		add r16,r24
 986 02e6 191F      		adc r17,r25
 987 02e8 4F5F      		subi r20,lo8(-(1))
 988 02ea 5F4F      		sbci r21,hi8(-(1))
 590:main.c        **** 	for (uint8_t i = 1; i<(NURNSTPOINTS+1); i++)//SUMx
 990               	.LM125:
 991 02ec 4430      		cpi r20,4
 992 02ee 5105      		cpc r21,__zero_reg__
 993 02f0 01F4      		brne .L32
 994               	.LBE31:
 597:main.c        **** 		
 598:main.c        **** 	}
 599:main.c        **** 	int16_t slope = ((SUMx*SUMy)- NURNSTPOINTS*SUMxy) / ( (SUMx*SUMx) - NURNSTPOINTS*SUMxx);
 996               	.LM126:
 997 02f2 9B01      		movw r18,r22
 998 02f4 220F      		lsl r18
 999 02f6 331F      		rol r19
 1000 02f8 260F      		add r18,r22
 1001 02fa 371F      		adc r19,r23
 1002 02fc 220F      		lsl r18
 1003 02fe 331F      		rol r19
 1004 0300 CD01      		movw r24,r26
 1005 0302 880F      		lsl r24
 1006 0304 991F      		rol r25
 1007 0306 8A0F      		add r24,r26
 1008 0308 9B1F      		adc r25,r27
 1009 030a 281B      		sub r18,r24
 1010 030c 390B      		sbc r19,r25
 1011 030e BE01      		movw r22,r28
 1012 0310 660F      		lsl r22
 1013 0312 771F      		rol r23
 1014 0314 6C0F      		add r22,r28
 1015 0316 7D1F      		adc r23,r29
 1016 0318 7095      		com r23
 1017 031a 6195      		neg r22
 1018 031c 7F4F      		sbci r23,lo8(-1)
 1019 031e 6C5D      		subi r22,lo8(-(36))
 1020 0320 7F4F      		sbci r23,hi8(-(36))
 1021 0322 C901      		movw r24,r18
 1022 0324 00D0      		rcall __divmodhi4
 1023 0326 9B01      		movw r18,r22
 600:main.c        **** 	average = average/NURNSTPOINTS;// average
 1025               	.LM127:
 1026 0328 C801      		movw r24,r16
 1027 032a 63E0      		ldi r22,lo8(3)
 1028 032c 70E0      		ldi r23,hi8(3)
 1029 032e 00D0      		rcall __udivmodhi4
 601:main.c        **** //	uint16_t rise = ((NURNSTPOINTS+2)*(abs(slope)))/2;
 602:main.c        **** //	uint16_t newpoint = 0;
 603:main.c        **** //	if (slope<0){newpoint = average-rise;}
 604:main.c        **** //	else {newpoint = average+rise;}
 605:main.c        **** 	
 606:main.c        **** 	return(average+slope);
 1031               	.LM128:
 1032 0330 260F      		add r18,r22
 1033 0332 371F      		adc r19,r23
 607:main.c        **** }
 1035               	.LM129:
 1036 0334 C901      		movw r24,r18
 1037               	/* epilogue start */
 1038 0336 DF91      		pop r29
 1039 0338 CF91      		pop r28
 1040 033a 1F91      		pop r17
 1041 033c 0F91      		pop r16
 1042 033e 0895      		ret
 1049               	.Lscope14:
 1052               	.global	data_ip_update
 1054               	data_ip_update:
 608:main.c        **** 
 609:main.c        **** void data_ip_update(uint16_t newval)		
 610:main.c        **** {
 1056               	.LM130:
 1057               	.LFBB15:
 1058               	/* prologue: function */
 1059               	/* frame size = 0 */
 1060               	/* stack size = 0 */
 1061               	.L__stack_usage = 0
 1062               	.LBB32:
 611:main.c        **** 	for (uint8_t i = 0; i<(IPPOINTS); i++)//shift points
 612:main.c        **** 	{
 613:main.c        **** 		Ip_data[i]=Ip_data[i+1];
 1064               	.LM131:
 1065 0340 2091 0000 		lds r18,Ip_data+2
 1066 0344 3091 0000 		lds r19,Ip_data+2+1
 1067 0348 E0E0      		ldi r30,lo8(Ip_data+2)
 1068 034a F0E0      		ldi r31,hi8(Ip_data+2)
 1069 034c 3293      		st -Z,r19
 1070 034e 2293      		st -Z,r18
 1071 0350 2481      		ldd r18,Z+4
 1072 0352 3581      		ldd r19,Z+5
 1073 0354 3093 0000 		sts Ip_data+2+1,r19
 1074 0358 2093 0000 		sts Ip_data+2,r18
 1075 035c 2681      		ldd r18,Z+6
 1076 035e 3781      		ldd r19,Z+7
 1077 0360 3583      		std Z+5,r19
 1078 0362 2483      		std Z+4,r18
 1079               	.LBE32:
 614:main.c        **** 	}
 615:main.c        **** 	Ip_data[IPPOINTS] = newval;//put in latest value
 1081               	.LM132:
 1082 0364 9783      		std Z+7,r25
 1083 0366 8683      		std Z+6,r24
 1084               	/* epilogue start */
 616:main.c        **** }
 1086               	.LM133:
 1087 0368 0895      		ret
 1089               	.Lscope15:
 1091               	.global	data_ip_backup
 1093               	data_ip_backup:
 617:main.c        **** void data_ip_backup(void)		
 618:main.c        **** {
 1095               	.LM134:
 1096               	.LFBB16:
 1097               	/* prologue: function */
 1098               	/* frame size = 0 */
 1099               	/* stack size = 0 */
 1100               	.L__stack_usage = 0
 1101               	.LBB33:
 619:main.c        **** 	for (uint8_t i = (IPPOINTS); i>0; i--)//shift points backwards
 620:main.c        **** 	{
 621:main.c        **** 		Ip_data[i]=Ip_data[i-1];
 1103               	.LM135:
 1104 036a 80E0      		ldi r24,lo8(Ip_data+4)
 1105 036c 90E0      		ldi r25,hi8(Ip_data+4)
 1106 036e 2091 0000 		lds r18,Ip_data+4
 1107 0372 3091 0000 		lds r19,Ip_data+4+1
 1108 0376 3093 0000 		sts Ip_data+6+1,r19
 1109 037a 2093 0000 		sts Ip_data+6,r18
 1110 037e FC01      		movw r30,r24
 1111 0380 3297      		sbiw r30,2
 1112 0382 2081      		ld r18,Z
 1113 0384 3181      		ldd r19,Z+1
 1114 0386 3093 0000 		sts Ip_data+4+1,r19
 1115 038a 2093 0000 		sts Ip_data+4,r18
 1116 038e 0497      		sbiw r24,4
 1117 0390 DC01      		movw r26,r24
 1118 0392 8D91      		ld r24,X+
 1119 0394 9C91      		ld r25,X
 1120 0396 1197      		sbiw r26,1
 1121 0398 9183      		std Z+1,r25
 1122 039a 8083      		st Z,r24
 1123               	/* epilogue start */
 1124               	.LBE33:
 622:main.c        **** 	}
 623:main.c        **** }
 1126               	.LM136:
 1127 039c 0895      		ret
 1129               	.Lscope16:
 1131               	.global	data_ip_extrap
 1133               	data_ip_extrap:
 624:main.c        **** uint16_t data_ip_extrap(void)//extrapolates 1 point		
 625:main.c        **** {
 1135               	.LM137:
 1136               	.LFBB17:
 1137 039e 0F93      		push r16
 1138 03a0 1F93      		push r17
 1139 03a2 CF93      		push r28
 1140 03a4 DF93      		push r29
 1141               	/* prologue: function */
 1142               	/* frame size = 0 */
 1143               	/* stack size = 4 */
 1144               	.L__stack_usage = 4
 1146               	.LM138:
 1147 03a6 41E0      		ldi r20,lo8(1)
 1148 03a8 50E0      		ldi r21,hi8(1)
 626:main.c        **** 	//calculate sums for least squares:
 627:main.c        **** 	int8_t SUMx = 0; 
 628:main.c        **** 	int16_t SUMy =0;
 629:main.c        **** 	int16_t SUMxy = 0; 
 630:main.c        **** 	int16_t SUMxx  = 0;
 631:main.c        **** 	uint16_t average = 0;
 1150               	.LM139:
 1151 03aa 00E0      		ldi r16,lo8(0)
 1152 03ac 10E0      		ldi r17,hi8(0)
 630:main.c        **** 	int16_t SUMxx  = 0;
 1154               	.LM140:
 1155 03ae C0E0      		ldi r28,lo8(0)
 1156 03b0 D0E0      		ldi r29,hi8(0)
 629:main.c        **** 	int16_t SUMxy = 0; 
 1158               	.LM141:
 1159 03b2 A0E0      		ldi r26,lo8(0)
 1160 03b4 B0E0      		ldi r27,hi8(0)
 628:main.c        **** 	int16_t SUMy =0;
 1162               	.LM142:
 1163 03b6 60E0      		ldi r22,lo8(0)
 1164 03b8 70E0      		ldi r23,hi8(0)
 1165               	.L37:
 1166               	.LBB34:
 632:main.c        **** 	for (uint8_t i = 1; i<(IPPOINTS+1); i++)//SUMx
 633:main.c        **** 	{
 634:main.c        **** 		SUMx = SUMx+i;
 635:main.c        **** 		SUMy = SUMy+Ip_data[i];
 1168               	.LM143:
 1169 03ba FA01      		movw r30,r20
 1170 03bc EE0F      		lsl r30
 1171 03be FF1F      		rol r31
 1172 03c0 E050      		subi r30,lo8(-(Ip_data))
 1173 03c2 F040      		sbci r31,hi8(-(Ip_data))
 1174 03c4 8081      		ld r24,Z
 1175 03c6 9181      		ldd r25,Z+1
 1176 03c8 680F      		add r22,r24
 1177 03ca 791F      		adc r23,r25
 636:main.c        **** 		SUMxy = SUMxy+(i*Ip_data[i]);
 1179               	.LM144:
 1180 03cc 8081      		ld r24,Z
 1181 03ce 9181      		ldd r25,Z+1
 1182 03d0 849F      		mul r24,r20
 1183 03d2 9001      		movw r18,r0
 1184 03d4 859F      		mul r24,r21
 1185 03d6 300D      		add r19,r0
 1186 03d8 949F      		mul r25,r20
 1187 03da 300D      		add r19,r0
 1188 03dc 1124      		clr r1
 1189 03de A20F      		add r26,r18
 1190 03e0 B31F      		adc r27,r19
 637:main.c        **** 		SUMxx = SUMxx+(i*i);
 1192               	.LM145:
 1193 03e2 449F      		mul r20,r20
 1194 03e4 C001      		movw r24,r0
 1195 03e6 459F      		mul r20,r21
 1196 03e8 900D      		add r25,r0
 1197 03ea 549F      		mul r21,r20
 1198 03ec 900D      		add r25,r0
 1199 03ee 1124      		clr r1
 1200 03f0 C80F      		add r28,r24
 1201 03f2 D91F      		adc r29,r25
 638:main.c        **** 		average = average+Ip_data[i];
 1203               	.LM146:
 1204 03f4 8081      		ld r24,Z
 1205 03f6 9181      		ldd r25,Z+1
 1206 03f8 080F      		add r16,r24
 1207 03fa 191F      		adc r17,r25
 1208 03fc 4F5F      		subi r20,lo8(-(1))
 1209 03fe 5F4F      		sbci r21,hi8(-(1))
 632:main.c        **** 	for (uint8_t i = 1; i<(IPPOINTS+1); i++)//SUMx
 1211               	.LM147:
 1212 0400 4430      		cpi r20,4
 1213 0402 5105      		cpc r21,__zero_reg__
 1214 0404 01F4      		brne .L37
 1215               	.LBE34:
 639:main.c        **** 	}
 640:main.c        **** 	int16_t slope = ((SUMx*SUMy)- IPPOINTS*SUMxy) / ( (SUMx*SUMx) - IPPOINTS*SUMxx);
 1217               	.LM148:
 1218 0406 9B01      		movw r18,r22
 1219 0408 220F      		lsl r18
 1220 040a 331F      		rol r19
 1221 040c 260F      		add r18,r22
 1222 040e 371F      		adc r19,r23
 1223 0410 220F      		lsl r18
 1224 0412 331F      		rol r19
 1225 0414 CD01      		movw r24,r26
 1226 0416 880F      		lsl r24
 1227 0418 991F      		rol r25
 1228 041a 8A0F      		add r24,r26
 1229 041c 9B1F      		adc r25,r27
 1230 041e 281B      		sub r18,r24
 1231 0420 390B      		sbc r19,r25
 1232 0422 BE01      		movw r22,r28
 1233 0424 660F      		lsl r22
 1234 0426 771F      		rol r23
 1235 0428 6C0F      		add r22,r28
 1236 042a 7D1F      		adc r23,r29
 1237 042c 7095      		com r23
 1238 042e 6195      		neg r22
 1239 0430 7F4F      		sbci r23,lo8(-1)
 1240 0432 6C5D      		subi r22,lo8(-(36))
 1241 0434 7F4F      		sbci r23,hi8(-(36))
 1242 0436 C901      		movw r24,r18
 1243 0438 00D0      		rcall __divmodhi4
 1244 043a 9B01      		movw r18,r22
 641:main.c        **** 	average = average/IPPOINTS;// average
 1246               	.LM149:
 1247 043c C801      		movw r24,r16
 1248 043e 63E0      		ldi r22,lo8(3)
 1249 0440 70E0      		ldi r23,hi8(3)
 1250 0442 00D0      		rcall __udivmodhi4
 642:main.c        **** //	uint16_t rise = ((IPPOINTS+2)*(abs(slope)))/2;
 643:main.c        **** //	uint16_t newpoint = 0;
 644:main.c        **** //	if (slope<0){newpoint = average-rise;}
 645:main.c        **** //	else {newpoint = average+rise;}
 646:main.c        **** 	
 647:main.c        **** 	return(average+slope);
 1252               	.LM150:
 1253 0444 260F      		add r18,r22
 1254 0446 371F      		adc r19,r23
 648:main.c        **** 
 649:main.c        **** }
 1256               	.LM151:
 1257 0448 C901      		movw r24,r18
 1258               	/* epilogue start */
 1259 044a DF91      		pop r29
 1260 044c CF91      		pop r28
 1261 044e 1F91      		pop r17
 1262 0450 0F91      		pop r16
 1263 0452 0895      		ret
 1270               	.Lscope17:
 1271               		.data
 1272               	.LC0:
 1273 000b 0100      		.word	1
 1274 000d 0000      		.word	0
 1275 000f E001      		.word	480
 1276 0011 4400      		.word	68
 1277 0013 3A02      		.word	570
 1278 0015 5000      		.word	80
 1279 0017 6202      		.word	610
 1280 0019 5500      		.word	85
 1281 001b 8A02      		.word	650
 1282 001d 5A00      		.word	90
 1283 001f B202      		.word	690
 1284 0021 6400      		.word	100
 1285 0023 BC02      		.word	700
 1286 0025 6E00      		.word	110
 1287 0027 EE02      		.word	750
 1288 0029 8F00      		.word	143
 1289 002b 1B03      		.word	795
 1290 002d AA00      		.word	170
 1291 002f 2A03      		.word	810
 1292 0031 F200      		.word	242
 1293 0033 4D03      		.word	845
 1294 0035 E84E      		.word	20200
 1295 0037 0004      		.word	1024
 1296 0039 9065      		.word	26000
 1297               		.text
 1299               	.global	eight
 1301               	eight:
 366:main.c        **** {
 1303               	.LM152:
 1304               	.LFBB18:
 1305 0454 AF92      		push r10
 1306 0456 BF92      		push r11
 1307 0458 CF92      		push r12
 1308 045a DF92      		push r13
 1309 045c EF92      		push r14
 1310 045e FF92      		push r15
 1311 0460 0F93      		push r16
 1312 0462 1F93      		push r17
 1313 0464 CF93      		push r28
 1314 0466 DF93      		push r29
 1315 0468 CDB7      		in r28,__SP_L__
 1316 046a DEB7      		in r29,__SP_H__
 1317 046c E097      		sbiw r28,48
 1318 046e 0FB6      		in __tmp_reg__,__SREG__
 1319 0470 F894      		cli
 1320 0472 DEBF      		out __SP_H__,r29
 1321 0474 0FBE      		out __SREG__,__tmp_reg__
 1322 0476 CDBF      		out __SP_L__,r28
 1323               	/* prologue: function */
 1324               	/* frame size = 48 */
 1325               	/* stack size = 58 */
 1326               	.L__stack_usage = 58
 368:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 1328               	.LM153:
 1329 0478 C298      		cbi 56-32,2
 1330               	.LBB35:
 1331               	.LBB36:
 1333               	.Ltext7:
 1335               	.LM154:
 1336 047a 2AE1      		 ldi r18,lo8(26)
 1337 047c 2A95      	    1:dec r18
 1338 047e 01F4      	    brne 1b
 1339 0480 00C0      		rjmp .
 1340               	.LBE36:
 1341               	.LBE35:
 1343               	.Ltext8:
 370:main.c        **** 	DDRB &=~ _BV(2);//hiZ
 1345               	.LM155:
 1346 0482 BA98      		cbi 55-32,2
 371:main.c        **** 	DC_val = ADC_data;
 1348               	.LM156:
 1349 0484 2091 0000 		lds r18,ADC_data
 1350 0488 3091 0000 		lds r19,ADC_data+1
 1351 048c 3093 0000 		sts DC_val+1,r19
 1352 0490 2093 0000 		sts DC_val,r18
 373:main.c        **** 	ADC_flag = 0;	
 1354               	.LM157:
 1355 0494 1092 0000 		sts ADC_flag,__zero_reg__
 375:main.c        **** 	measured_temperature = (DC_val - nurnst);
 1357               	.LM158:
 1358 0498 8091 0000 		lds r24,nurnst
 1359 049c 9091 0000 		lds r25,nurnst+1
 1360 04a0 281B      		sub r18,r24
 1361 04a2 390B      		sbc r19,r25
 376:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 1363               	.LM159:
 1364 04a4 2F3F      		cpi r18,255
 1365 04a6 3105      		cpc r19,__zero_reg__
 1366 04a8 01F0      		breq .+2
 1367 04aa 00F4      		brsh .L40
 378:main.c        **** 		measured_temperature = (255 - measured_temperature);
 1369               	.LM160:
 1370 04ac 8FEF      		ldi r24,lo8(255)
 1371 04ae 90E0      		ldi r25,hi8(255)
 1372 04b0 821B      		sub r24,r18
 1373 04b2 930B      		sbc r25,r19
 1374 04b4 9093 0000 		sts measured_temperature+1,r25
 1375 04b8 8093 0000 		sts measured_temperature,r24
 1376 04bc 00C0      		rjmp .L41
 1377               	.L40:
 382:main.c        **** 		measured_temperature =0;
 1379               	.LM161:
 1380 04be 1092 0000 		sts measured_temperature+1,__zero_reg__
 1381 04c2 1092 0000 		sts measured_temperature,__zero_reg__
 1382               	.L41:
 384:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 1384               	.LM162:
 1385 04c6 8091 0000 		lds r24,measured_temperature
 1386 04ca 9091 0000 		lds r25,measured_temperature+1
 1387 04ce 9C01      		movw r18,r24
 1388 04d0 295E      		subi r18,lo8(-(-233))
 1389 04d2 3040      		sbci r19,hi8(-(-233))
 1390 04d4 2930      		cpi r18,9
 1391 04d6 3105      		cpc r19,__zero_reg__
 1392 04d8 00F4      		brsh .L42
 386:main.c        **** 		PORTD &=~ _BV(4);//LED off
 1394               	.LM163:
 1395 04da 9498      		cbi 50-32,4
 1396 04dc 00C0      		rjmp .L43
 1397               	.L42:
 390:main.c        **** 		PORTD |= _BV(4);//LED on
 1399               	.LM164:
 1400 04de 949A      		sbi 50-32,4
 1401               	.L43:
 392:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 1403               	.LM165:
 1404 04e0 4091 0000 		lds r20,charspot
 1405 04e4 60E0      		ldi r22,lo8(0)
 1406 04e6 00D0      		rcall put_in_string
 1407 04e8 8093 0000 		sts charspot,r24
 393:main.c        **** 	charspot = put_in_string(nurnst_spike,'\0',charspot);//puts data in big string
 1409               	.LM166:
 1410 04ec 8091 0000 		lds r24,nurnst_spike
 1411 04f0 4091 0000 		lds r20,charspot
 1412 04f4 90E0      		ldi r25,lo8(0)
 1413 04f6 60E0      		ldi r22,lo8(0)
 1414 04f8 00D0      		rcall put_in_string
 1415 04fa 8093 0000 		sts charspot,r24
 397:main.c        **** 	data_ip_update(pump);
 1417               	.LM167:
 1418 04fe 8091 0000 		lds r24,pump
 1419 0502 9091 0000 		lds r25,pump+1
 1420 0506 00D0      		rcall data_ip_update
 398:main.c        **** 	data_nurnst_update(nurnst);
 1422               	.LM168:
 1423 0508 8091 0000 		lds r24,nurnst
 1424 050c 9091 0000 		lds r25,nurnst+1
 1425 0510 00D0      		rcall data_nurnst_update
 403:main.c        **** 	if( nurnst_spike == 0)// nurnst was not spiking
 1427               	.LM169:
 1428 0512 8091 0000 		lds r24,nurnst_spike
 1429 0516 8823      		tst r24
 1430 0518 01F4      		brne .L44
 405:main.c        **** 		if( abs((nurnst_data[NURNSTPOINTS-2])-nurnst) > 30)//nurnst spiked 35 or more in one cycle
 1432               	.LM170:
 1433 051a 8091 0000 		lds r24,nurnst_data+2
 1434 051e 9091 0000 		lds r25,nurnst_data+2+1
 1435 0522 2091 0000 		lds r18,nurnst
 1436 0526 3091 0000 		lds r19,nurnst+1
 1437 052a 821B      		sub r24,r18
 1438 052c 930B      		sbc r25,r19
 1439 052e 97FF      		sbrs r25,7
 1440 0530 00C0      		rjmp .L46
 1441 0532 9095      		com r25
 1442 0534 8195      		neg r24
 1443 0536 9F4F      		sbci r25,lo8(-1)
 1444               	.L46:
 1445 0538 8F31      		cpi r24,31
 1446 053a 9105      		cpc r25,__zero_reg__
 1447 053c 04F0      		brlt .L63
 407:main.c        **** 			nurnst_spike = 1;
 1449               	.LM171:
 1450 053e 81E0      		ldi r24,lo8(1)
 1451 0540 8093 0000 		sts nurnst_spike,r24
 409:main.c        **** 			data_ip_backup();
 1453               	.LM172:
 1454 0544 00D0      		rcall data_ip_backup
 410:main.c        **** 			data_nurnst_backup();
 1456               	.LM173:
 1457 0546 00D0      		rcall data_nurnst_backup
 412:main.c        **** 			nurnst_calc = data_nurnst_extrap();
 1459               	.LM174:
 1460 0548 00D0      		rcall data_nurnst_extrap
 1461 054a 8C01      		movw r16,r24
 1462 054c 00C0      		rjmp .L62
 1463               	.L44:
 419:main.c        **** 		timeinspike++;
 1465               	.LM175:
 1466 054e 8091 0000 		lds r24,timeinspike
 1467 0552 8F5F      		subi r24,lo8(-(1))
 1468 0554 8093 0000 		sts timeinspike,r24
 420:main.c        **** 		data_nurnst_backup();
 1470               	.LM176:
 1471 0558 00D0      		rcall data_nurnst_backup
 421:main.c        **** 		nurnst_calc = data_nurnst_extrap();
 1473               	.LM177:
 1474 055a 00D0      		rcall data_nurnst_extrap
 1475 055c 8C01      		movw r16,r24
 422:main.c        **** 		if ( (abs(nurnst_calc-nurnst)<10)||(timeinspike>10) )//back in range or not a spike
 1477               	.LM178:
 1478 055e 8091 0000 		lds r24,nurnst
 1479 0562 9091 0000 		lds r25,nurnst+1
 1480 0566 A801      		movw r20,r16
 1481 0568 481B      		sub r20,r24
 1482 056a 590B      		sbc r21,r25
 1483 056c CA01      		movw r24,r20
 1484 056e 57FF      		sbrs r21,7
 1485 0570 00C0      		rjmp .L49
 1486 0572 9095      		com r25
 1487 0574 8195      		neg r24
 1488 0576 9F4F      		sbci r25,lo8(-1)
 1489               	.L49:
 1490 0578 8A30      		cpi r24,10
 1491 057a 9105      		cpc r25,__zero_reg__
 1492 057c 04F0      		brlt .L48
 422:main.c        **** 		if ( (abs(nurnst_calc-nurnst)<10)||(timeinspike>10) )//back in range or not a spike
 1494               	.LM179:
 1495 057e 8091 0000 		lds r24,timeinspike
 1496 0582 8B30      		cpi r24,lo8(11)
 1497 0584 00F0      		brlo .L50
 1498               	.L48:
 424:main.c        **** 			nurnst_calc = nurnst; ip_calc = pump;
 1500               	.LM180:
 1501 0586 8091 0000 		lds r24,nurnst
 1502 058a 9091 0000 		lds r25,nurnst+1
 1503 058e 8091 0000 		lds r24,pump
 1504 0592 9091 0000 		lds r25,pump+1
 425:main.c        **** 			data_nurnst_update(nurnst);//restor measured values
 1506               	.LM181:
 1507 0596 8091 0000 		lds r24,nurnst
 1508 059a 9091 0000 		lds r25,nurnst+1
 1509 059e 00D0      		rcall data_nurnst_update
 426:main.c        **** 			nurnst_spike = 0;
 1511               	.LM182:
 1512 05a0 1092 0000 		sts nurnst_spike,__zero_reg__
 427:main.c        **** 			timeinspike = 0;
 1514               	.LM183:
 1515 05a4 1092 0000 		sts timeinspike,__zero_reg__
 1516               	.L63:
 428:main.c        **** 			nurnst_calc = nurnst; ip_calc = pump;//pass values on
 1518               	.LM184:
 1519 05a8 0091 0000 		lds r16,nurnst
 1520 05ac 1091 0000 		lds r17,nurnst+1
 1521 05b0 A090 0000 		lds r10,pump
 1522 05b4 B090 0000 		lds r11,pump+1
 1523 05b8 00C0      		rjmp .L47
 1524               	.L50:
 432:main.c        **** 			data_ip_backup();
 1526               	.LM185:
 1527 05ba 00D0      		rcall data_ip_backup
 1528               	.L62:
 433:main.c        **** 			ip_calc = data_ip_extrap();
 1530               	.LM186:
 1531 05bc 00D0      		rcall data_ip_extrap
 1532 05be 5C01      		movw r10,r24
 1533               	.L47:
 437:main.c        **** 	PID_pump(nurnst_calc);//run PID on pump and update pump pwm.
 1535               	.LM187:
 1536 05c0 C801      		movw r24,r16
 1537 05c2 00D0      		rcall PID_pump
 439:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string
 1539               	.LM188:
 1540 05c4 8AB5      		in r24,74-32
 1541 05c6 9BB5      		in r25,74+1-32
 1542 05c8 4091 0000 		lds r20,charspot
 1543 05cc 60E0      		ldi r22,lo8(0)
 1544 05ce 00D0      		rcall put_in_string
 1545 05d0 8093 0000 		sts charspot,r24
 440:main.c        **** 	charspot = put_in_string(nurnst_calc,'\0',charspot);//puts data in big string and sends back new c
 1547               	.LM189:
 1548 05d4 4091 0000 		lds r20,charspot
 1549 05d8 C801      		movw r24,r16
 1550 05da 60E0      		ldi r22,lo8(0)
 1551 05dc 00D0      		rcall put_in_string
 1552 05de 8093 0000 		sts charspot,r24
 441:main.c        **** 	charspot = put_in_string(ip_calc,'\0',charspot);//puts data in big string and sends back new char 
 1554               	.LM190:
 1555 05e2 4091 0000 		lds r20,charspot
 1556 05e6 C501      		movw r24,r10
 1557 05e8 60E0      		ldi r22,lo8(0)
 1558 05ea 00D0      		rcall put_in_string
 1559 05ec 8093 0000 		sts charspot,r24
 467:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 1561               	.LM191:
 1562 05f0 DE01      		movw r26,r28
 1563 05f2 1196      		adiw r26,1
 1564 05f4 E0E0      		ldi r30,lo8(.LC0)
 1565 05f6 F0E0      		ldi r31,hi8(.LC0)
 1566 05f8 80E3      		ldi r24,lo8(48)
 1567               	.L51:
 1568 05fa 0190      		ld r0,Z+
 1569 05fc 0D92      		st X+,r0
 1570 05fe 8150      		subi r24,lo8(-(-1))
 1571 0600 01F4      		brne .L51
 484:main.c        **** 	if (ip_calc<lambda_curve[0].x)//smaller than the lowest value in LOT
 1573               	.LM192:
 1574 0602 8981      		ldd r24,Y+1
 1575 0604 9A81      		ldd r25,Y+2
 1576 0606 A816      		cp r10,r24
 1577 0608 B906      		cpc r11,r25
 1578 060a 00F4      		brsh .L52
 485:main.c        **** 	{lambda = lambda_curve[0].y;}
 1580               	.LM193:
 1581 060c CB80      		ldd r12,Y+3
 1582 060e DC80      		ldd r13,Y+4
 1583 0610 00C0      		rjmp .L64
 1584               	.L60:
 482:main.c        **** 	uint32_t lambda=0;
 1586               	.LM194:
 1587 0612 CC24      		clr r12
 1588 0614 DD24      		clr r13
 1589 0616 7601      		movw r14,r12
 1590               	.L54:
 482:main.c        **** 	uint32_t lambda=0;
 1592               	.LM195:
 1593 0618 20E0      		ldi r18,lo8(0)
 1594 061a 00C0      		rjmp .L53
 1595               	.L52:
 486:main.c        **** 	else if (ip_calc>lambda_curve[n-1].x)//larger than the highest value in the LOT
 1597               	.LM196:
 1598 061c 8DA5      		ldd r24,Y+45
 1599 061e 9EA5      		ldd r25,Y+46
 1600 0620 8A15      		cp r24,r10
 1601 0622 9B05      		cpc r25,r11
 1602 0624 00F4      		brsh .L60
 487:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 1604               	.LM197:
 1605 0626 CFA4      		ldd r12,Y+47
 1606 0628 D8A8      		ldd r13,Y+48
 1607               	.L64:
 1608 062a EE24      		clr r14
 1609 062c FF24      		clr r15
 1610 062e 00C0      		rjmp .L54
 1611               	.L56:
 1612               	.LBB37:
 491:main.c        **** 		if ( (lambda_curve[i].x <= ip_calc )&& (lambda_curve[i+1].x >= ip_calc) )
 1614               	.LM198:
 1615 0630 DC01      		movw r26,r24
 1616 0632 AA0F      		lsl r26
 1617 0634 BB1F      		rol r27
 1618 0636 AA0F      		lsl r26
 1619 0638 BB1F      		rol r27
 1620 063a 41E0      		ldi r20,lo8(1)
 1621 063c 50E0      		ldi r21,hi8(1)
 1622 063e 4C0F      		add r20,r28
 1623 0640 5D1F      		adc r21,r29
 1624 0642 A40F      		add r26,r20
 1625 0644 B51F      		adc r27,r21
 1626 0646 6D91      		ld r22,X+
 1627 0648 7C91      		ld r23,X
 1628 064a 1197      		sbiw r26,1
 1629 064c A616      		cp r10,r22
 1630 064e B706      		cpc r11,r23
 1631 0650 00F0      		brlo .L55
 491:main.c        **** 		if ( (lambda_curve[i].x <= ip_calc )&& (lambda_curve[i+1].x >= ip_calc) )
 1633               	.LM199:
 1634 0652 FC01      		movw r30,r24
 1635 0654 3196      		adiw r30,1
 1636 0656 EE0F      		lsl r30
 1637 0658 FF1F      		rol r31
 1638 065a EE0F      		lsl r30
 1639 065c FF1F      		rol r31
 1640 065e E40F      		add r30,r20
 1641 0660 F51F      		adc r31,r21
 1642 0662 0081      		ld r16,Z
 1643 0664 1181      		ldd r17,Z+1
 1644 0666 0A15      		cp r16,r10
 1645 0668 1B05      		cpc r17,r11
 1646 066a 00F0      		brlo .L55
 1647               	.LBB38:
 495:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 1649               	.LM200:
 1650 066c 1296      		adiw r26,2
 1651 066e CD90      		ld r12,X+
 1652 0670 DC90      		ld r13,X
 1653 0672 1397      		sbiw r26,2+1
 493:main.c        **** 			uint16_t diffx = ip_calc - lambda_curve[i].x; //difference between the pump value and the x valu
 1655               	.LM201:
 1656 0674 D501      		movw r26,r10
 1657 0676 A61B      		sub r26,r22
 1658 0678 B70B      		sbc r27,r23
 495:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 1660               	.LM202:
 1661 067a 8281      		ldd r24,Z+2
 1662 067c 9381      		ldd r25,Z+3
 1663 067e 8C19      		sub r24,r12
 1664 0680 9D09      		sbc r25,r13
 496:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1666               	.LM203:
 1667 0682 A89F      		mul r26,r24
 1668 0684 A001      		movw r20,r0
 1669 0686 A99F      		mul r26,r25
 1670 0688 500D      		add r21,r0
 1671 068a B89F      		mul r27,r24
 1672 068c 500D      		add r21,r0
 1673 068e 1124      		clr r1
 494:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 1675               	.LM204:
 1676 0690 C801      		movw r24,r16
 1677 0692 861B      		sub r24,r22
 1678 0694 970B      		sbc r25,r23
 1679 0696 BC01      		movw r22,r24
 496:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1681               	.LM205:
 1682 0698 CA01      		movw r24,r20
 1683 069a 00D0      		rcall __udivmodhi4
 1684 069c 6C0D      		add r22,r12
 1685 069e 7D1D      		adc r23,r13
 1686 06a0 6B01      		movw r12,r22
 1687 06a2 EE24      		clr r14
 1688 06a4 FF24      		clr r15
 1689               	.L55:
 1690               	.LBE38:
 489:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1692               	.LM206:
 1693 06a6 2F5F      		subi r18,lo8(-(1))
 1694               	.L53:
 489:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1696               	.LM207:
 1697 06a8 822F      		mov r24,r18
 1698 06aa 90E0      		ldi r25,lo8(0)
 1699 06ac 2B30      		cpi r18,lo8(11)
 1700 06ae 01F0      		breq .+2
 1701 06b0 00C0      		rjmp .L56
 1702               	.LBE37:
 502:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 1704               	.LM208:
 1705 06b2 4091 0000 		lds r20,charspot
 1706 06b6 C601      		movw r24,r12
 1707 06b8 60E0      		ldi r22,lo8(0)
 1708 06ba 00D0      		rcall put_in_string
 1709 06bc 8093 0000 		sts charspot,r24
 503:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 1711               	.LM209:
 1712 06c0 D701      		movw r26,r14
 1713 06c2 C601      		movw r24,r12
 1714 06c4 8054      		subi r24,lo8(-(-64))
 1715 06c6 9040      		sbci r25,hi8(-(-64))
 1716 06c8 A040      		sbci r26,hlo8(-(-64))
 1717 06ca B040      		sbci r27,hhi8(-(-64))
 1718 06cc 8934      		cpi r24,lo8(73)
 1719 06ce 9105      		cpc r25,__zero_reg__
 1720 06d0 A105      		cpc r26,__zero_reg__
 1721 06d2 B105      		cpc r27,__zero_reg__
 1722 06d4 00F4      		brsh .L57
 1723               	.LBB39:
 505:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 1725               	.LM210:
 1726 06d6 C701      		movw r24,r14
 1727 06d8 B601      		movw r22,r12
 1728 06da 20EF      		ldi r18,lo8(2550000)
 1729 06dc 38EE      		ldi r19,hi8(2550000)
 1730 06de 46E2      		ldi r20,hlo8(2550000)
 1731 06e0 50E0      		ldi r21,hhi8(2550000)
 1732 06e2 00D0      		rcall __mulsi3
 1733 06e4 6050      		subi r22,lo8(-(-163200000))
 1734 06e6 7C43      		sbci r23,hi8(-(-163200000))
 1735 06e8 8A4B      		sbci r24,hlo8(-(-163200000))
 1736 06ea 9940      		sbci r25,hhi8(-(-163200000))
 1737 06ec 28E4      		ldi r18,lo8(72)
 1738 06ee 30E0      		ldi r19,hi8(72)
 1739 06f0 40E0      		ldi r20,hlo8(72)
 1740 06f2 50E0      		ldi r21,hhi8(72)
 1741 06f4 00D0      		rcall __udivmodsi4
 506:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 1743               	.LM211:
 1744 06f6 CA01      		movw r24,r20
 1745 06f8 B901      		movw r22,r18
 1746 06fa 20E1      		ldi r18,lo8(10000)
 1747 06fc 37E2      		ldi r19,hi8(10000)
 1748 06fe 40E0      		ldi r20,hlo8(10000)
 1749 0700 50E0      		ldi r21,hhi8(10000)
 1750 0702 00D0      		rcall __udivmodsi4
 1751 0704 2093 0000 		sts zero_to_5_WB,r18
 1752 0708 3093 0000 		sts zero_to_5_WB+1,r19
 1753 070c 4093 0000 		sts zero_to_5_WB+2,r20
 1754 0710 5093 0000 		sts zero_to_5_WB+3,r21
 1755 0714 00C0      		rjmp .L58
 1756               	.L57:
 1757               	.LBE39:
 508:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1759               	.LM212:
 1760 0716 99E8      		ldi r25,lo8(137)
 1761 0718 C916      		cp r12,r25
 1762 071a D104      		cpc r13,__zero_reg__
 1763 071c E104      		cpc r14,__zero_reg__
 1764 071e F104      		cpc r15,__zero_reg__
 1765 0720 00F0      		brlo .L59
 508:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1767               	.LM213:
 1768 0722 8FEF      		ldi r24,lo8(255)
 1769 0724 90E0      		ldi r25,hi8(255)
 1770 0726 A0E0      		ldi r26,hlo8(255)
 1771 0728 B0E0      		ldi r27,hhi8(255)
 1772 072a 8093 0000 		sts zero_to_5_WB,r24
 1773 072e 9093 0000 		sts zero_to_5_WB+1,r25
 1774 0732 A093 0000 		sts zero_to_5_WB+2,r26
 1775 0736 B093 0000 		sts zero_to_5_WB+3,r27
 1776 073a 00C0      		rjmp .L58
 1777               	.L59:
 509:main.c        **** 	else {zero_to_5_WB = 0;}
 1779               	.LM214:
 1780 073c 1092 0000 		sts zero_to_5_WB,__zero_reg__
 1781 0740 1092 0000 		sts zero_to_5_WB+1,__zero_reg__
 1782 0744 1092 0000 		sts zero_to_5_WB+2,__zero_reg__
 1783 0748 1092 0000 		sts zero_to_5_WB+3,__zero_reg__
 1784               	.L58:
 510:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 1786               	.LM215:
 1787 074c 8091 0000 		lds r24,zero_to_5_WB
 1788 0750 83BD      		out 67-32,r24
 514:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 1790               	.LM216:
 1791 0752 00D0      		rcall PID_heater
 516:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 1793               	.LM217:
 1794 0754 8091 0000 		lds r24,charspot
 1795 0758 00D0      		rcall spitout
 1796 075a 8093 0000 		sts charspot,r24
 1797               	/* epilogue start */
 517:main.c        **** }
 1799               	.LM218:
 1800 075e E096      		adiw r28,48
 1801 0760 0FB6      		in __tmp_reg__,__SREG__
 1802 0762 F894      		cli
 1803 0764 DEBF      		out __SP_H__,r29
 1804 0766 0FBE      		out __SREG__,__tmp_reg__
 1805 0768 CDBF      		out __SP_L__,r28
 1806 076a DF91      		pop r29
 1807 076c CF91      		pop r28
 1808 076e 1F91      		pop r17
 1809 0770 0F91      		pop r16
 1810 0772 FF90      		pop r15
 1811 0774 EF90      		pop r14
 1812 0776 DF90      		pop r13
 1813 0778 CF90      		pop r12
 1814 077a BF90      		pop r11
 1815 077c AF90      		pop r10
 1816 077e 0895      		ret
 1825               	.Lscope18:
 1827               	.global	__vector_14
 1829               	__vector_14:
 158:main.c        **** {
 1831               	.LM219:
 1832               	.LFBB19:
 1833 0780 1F92      		push r1
 1834 0782 0F92      		push r0
 1835 0784 0FB6      		in r0,__SREG__
 1836 0786 0F92      		push r0
 1837 0788 1124      		clr __zero_reg__
 1838 078a 2F93      		push r18
 1839 078c 3F93      		push r19
 1840 078e 4F93      		push r20
 1841 0790 5F93      		push r21
 1842 0792 6F93      		push r22
 1843 0794 7F93      		push r23
 1844 0796 8F93      		push r24
 1845 0798 9F93      		push r25
 1846 079a AF93      		push r26
 1847 079c BF93      		push r27
 1848 079e EF93      		push r30
 1849 07a0 FF93      		push r31
 1850               	/* prologue: Signal */
 1851               	/* frame size = 0 */
 1852               	/* stack size = 15 */
 1853               	.L__stack_usage = 15
 159:main.c        **** ADC_data = readadc();
 1855               	.LM220:
 1856 07a2 00D0      		rcall readadc
 1857 07a4 9093 0000 		sts ADC_data+1,r25
 1858 07a8 8093 0000 		sts ADC_data,r24
 161:main.c        **** if (ADC_flag == 7)//
 1860               	.LM221:
 1861 07ac 8091 0000 		lds r24,ADC_flag
 1862 07b0 8730      		cpi r24,lo8(7)
 1863 07b2 01F4      		brne .L66
 163:main.c        **** 	four();
 1865               	.LM222:
 1866 07b4 00D0      		rcall four
 1867 07b6 00C0      		rjmp .L65
 1868               	.L66:
 165:main.c        **** else if (ADC_flag == 2)
 1870               	.LM223:
 1871 07b8 8091 0000 		lds r24,ADC_flag
 1872 07bc 8230      		cpi r24,lo8(2)
 1873 07be 01F4      		brne .L68
 167:main.c        **** 	six_1();
 1875               	.LM224:
 1876 07c0 00D0      		rcall six_1
 1877 07c2 00C0      		rjmp .L65
 1878               	.L68:
 169:main.c        **** else if (ADC_flag == 8)
 1880               	.LM225:
 1881 07c4 8091 0000 		lds r24,ADC_flag
 1882 07c8 8830      		cpi r24,lo8(8)
 1883 07ca 01F4      		brne .L69
 171:main.c        **** 	six_2();
 1885               	.LM226:
 1886 07cc 00D0      		rcall six_2
 1887 07ce 00C0      		rjmp .L65
 1888               	.L69:
 173:main.c        **** else if (ADC_flag == 9)
 1890               	.LM227:
 1891 07d0 8091 0000 		lds r24,ADC_flag
 1892 07d4 8930      		cpi r24,lo8(9)
 1893 07d6 01F4      		brne .L70
 175:main.c        **** 	six_3();
 1895               	.LM228:
 1896 07d8 00D0      		rcall six_3
 1897 07da 00C0      		rjmp .L65
 1898               	.L70:
 178:main.c        **** else if (ADC_flag == 3)//nurnst
 1900               	.LM229:
 1901 07dc 8091 0000 		lds r24,ADC_flag
 1902 07e0 8330      		cpi r24,lo8(3)
 1903 07e2 01F4      		brne .L71
 180:main.c        **** 	seven();
 1905               	.LM230:
 1906 07e4 00D0      		rcall seven
 1907 07e6 00C0      		rjmp .L65
 1908               	.L71:
 182:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 1910               	.LM231:
 1911 07e8 8091 0000 		lds r24,ADC_flag
 1912 07ec 8430      		cpi r24,lo8(4)
 1913 07ee 01F4      		brne .L72
 184:main.c        **** 	eight();
 1915               	.LM232:
 1916 07f0 00D0      		rcall eight
 1917 07f2 00C0      		rjmp .L65
 1918               	.L72:
 189:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 1920               	.LM233:
 1921 07f4 00D0      		rcall readadc
 1922 07f6 9093 0000 		sts ADC_data+1,r25
 1923 07fa 8093 0000 		sts ADC_data,r24
 1924               	.L65:
 1925               	/* epilogue start */
 191:main.c        **** }
 1927               	.LM234:
 1928 07fe FF91      		pop r31
 1929 0800 EF91      		pop r30
 1930 0802 BF91      		pop r27
 1931 0804 AF91      		pop r26
 1932 0806 9F91      		pop r25
 1933 0808 8F91      		pop r24
 1934 080a 7F91      		pop r23
 1935 080c 6F91      		pop r22
 1936 080e 5F91      		pop r21
 1937 0810 4F91      		pop r20
 1938 0812 3F91      		pop r19
 1939 0814 2F91      		pop r18
 1940 0816 0F90      		pop r0
 1941 0818 0FBE      		out __SREG__,r0
 1942 081a 0F90      		pop r0
 1943 081c 1F90      		pop r1
 1944 081e 1895      		reti
 1946               	.Lscope19:
 1947               		.comm pidData_pump,18,1
 1948               		.comm pidData_temp,18,1
 1949               		.comm pidCounter,1,1
 1950               	.global	timeinspike
 1951               	.global	timeinspike
 1952               		.section .bss
 1955               	timeinspike:
 1956 0000 00        		.skip 1,0
 1957               	.global	ip_slope
 1958               	.global	ip_slope
 1961               	ip_slope:
 1962 0001 0000      		.skip 2,0
 1963               	.global	nurnst_slope
 1964               	.global	nurnst_slope
 1967               	nurnst_slope:
 1968 0003 0000      		.skip 2,0
 1969               	.global	nurnst_spike
 1970               	.global	nurnst_spike
 1973               	nurnst_spike:
 1974 0005 00        		.skip 1,0
 1975               	.global	cycle_counter
 1976               	.global	cycle_counter
 1979               	cycle_counter:
 1980 0006 00        		.skip 1,0
 1981               	.global	charspot
 1982               	.global	charspot
 1985               	charspot:
 1986 0007 00        		.skip 1,0
 1987               		.comm ADC_flag,1,1
 1988               		.comm its_off,1,1
 1989               	.global	ramp_flag
 1990               	.global	ramp_flag
 1993               	ramp_flag:
 1994 0008 00        		.skip 1,0
 1995               		.comm zero_to_5_WB,4,1
 1996               		.comm measured_temperature,2,1
 1997               	.global	DC_val
 1998               	.global	DC_val
 2001               	DC_val:
 2002 0009 0000      		.skip 2,0
 2003               	.global	pump
 2004               	.global	pump
 2007               	pump:
 2008 000b 0000      		.skip 2,0
 2009               	.global	nurnst
 2010               	.global	nurnst
 2013               	nurnst:
 2014 000d 0000      		.skip 2,0
 2015               		.comm ADC_data,2,1
 2016               		.comm heat_power,1,1
 2017               		.comm Ip_data,8,1
 2018               		.comm nurnst_data,8,1
 2019               	.global	ipramp
 2020               	.global	ipramp
 2023               	ipramp:
 2024 000f 0000      		.skip 2,0
 2025               	.global	IpCount
 2026               	.global	IpCount
 2029               	IpCount:
 2030 0011 0000 0000 		.skip 4,0
 2031               		.comm serialout,50,1
 2056               		.text
 2058               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccMQ8taK.s:2      *ABS*:0000003f __SREG__
     /tmp/ccMQ8taK.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccMQ8taK.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccMQ8taK.s:5      *ABS*:00000034 __CCP__
     /tmp/ccMQ8taK.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccMQ8taK.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccMQ8taK.s:127    .text.startup:00000000 main
                            *COM*:00000012 pidData_temp
                            *COM*:00000012 pidData_pump
                            *COM*:00000001 heat_power
     /tmp/ccMQ8taK.s:1993   .bss:00000008 ramp_flag
     /tmp/ccMQ8taK.s:295    .text:00000000 do_things
     /tmp/ccMQ8taK.s:1979   .bss:00000006 cycle_counter
                            *COM*:00000001 ADC_flag
     /tmp/ccMQ8taK.s:357    .text:00000034 __vector_9
                            *COM*:00000001 its_off
     /tmp/ccMQ8taK.s:460    .text:000000a6 four
     /tmp/ccMQ8taK.s:1985   .bss:00000007 charspot
                            *COM*:00000002 ADC_data
     /tmp/ccMQ8taK.s:496    .text:000000c8 six_1
     /tmp/ccMQ8taK.s:2007   .bss:0000000b pump
     /tmp/ccMQ8taK.s:526    .text:000000e2 six_2
     /tmp/ccMQ8taK.s:560    .text:00000108 six_3
     /tmp/ccMQ8taK.s:615    .text:0000015c seven
     /tmp/ccMQ8taK.s:2013   .bss:0000000d nurnst
     /tmp/ccMQ8taK.s:677    .text:0000019a readadc
     /tmp/ccMQ8taK.s:713    .text:000001aa PID_heater
                            *COM*:00000002 measured_temperature
     /tmp/ccMQ8taK.s:769    .text:000001e4 PID_pump
     /tmp/ccMQ8taK.s:833    .text:0000022c data_nurnst_update
                            *COM*:00000008 nurnst_data
     /tmp/ccMQ8taK.s:872    .text:00000256 data_nurnst_backup
     /tmp/ccMQ8taK.s:912    .text:0000028a data_nurnst_extrap
     /tmp/ccMQ8taK.s:1054   .text:00000340 data_ip_update
                            *COM*:00000008 Ip_data
     /tmp/ccMQ8taK.s:1093   .text:0000036a data_ip_backup
     /tmp/ccMQ8taK.s:1133   .text:0000039e data_ip_extrap
     /tmp/ccMQ8taK.s:1301   .text:00000454 eight
     /tmp/ccMQ8taK.s:2001   .bss:00000009 DC_val
     /tmp/ccMQ8taK.s:1973   .bss:00000005 nurnst_spike
     /tmp/ccMQ8taK.s:1955   .bss:00000000 timeinspike
                            *COM*:00000004 zero_to_5_WB
     /tmp/ccMQ8taK.s:1829   .text:00000780 __vector_14
                            *COM*:00000001 pidCounter
     /tmp/ccMQ8taK.s:1961   .bss:00000001 ip_slope
     /tmp/ccMQ8taK.s:1967   .bss:00000003 nurnst_slope
     /tmp/ccMQ8taK.s:2023   .bss:0000000f ipramp
     /tmp/ccMQ8taK.s:2029   .bss:00000011 IpCount
                            *COM*:00000032 serialout

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
setup_timer1
setup_timer2
pid_Init
adc_init
timer0init
uart_putst
uart_put16dec
uart_putch
put_in_string
__udivmodhi4
pid_Controller
__divmodhi4
__mulsi3
__udivmodsi4
spitout
