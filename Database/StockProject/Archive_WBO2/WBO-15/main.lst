   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 120               		.data
 121               	.LC1:
 122 0000 7261 6D70 		.string	"ramp temp\n"
 122      2074 656D 
 122      700A 00
 123               		.section	.text.startup,"ax",@progbits
 125               	.global	main
 127               	main:
   1:main.c        **** 
   2:main.c        **** /////////////---------------------------------///////////////////
   3:main.c        **** // 
   4:main.c        **** // www.waltech.com
   5:main.c        **** //
   6:main.c        **** /////////////---------------------------------/////////////////
   7:main.c        **** /*
   8:main.c        ****  * has pump ramp, not PID.  In PID function.
   9:main.c        ****  */
  10:main.c        **** 
  11:main.c        **** //Includes here:
  12:main.c        **** 
  13:main.c        **** #include <avr/interrupt.h>
  14:main.c        **** #include <stdlib.h>
  15:main.c        **** #include <string.h>
  16:main.c        **** #include <util/delay.h>
  17:main.c        **** #include <avr/pgmspace.h>
  18:main.c        **** #include "pid.h"
  19:main.c        **** #include "stdint.h"
  20:main.c        **** #include "initilize_hardware.h"
  21:main.c        **** #include "dataout.h"
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** ////////calibration settings://///////////
  25:main.c        **** //offset for lamda value, uses to calibrate (lambda*100) = 100  at stoic.  Checking against NB sens
  26:main.c        **** //POSOFFSET is added, NEGOFFSET is subtracted.
  27:main.c        **** #define POSOFFSET 0
  28:main.c        **** #define NEGOFFSET 0
  29:main.c        **** 
  30:main.c        **** /*Lambda*100 to DAC (0-255)
  31:main.c        **** * 
  32:main.c        **** *	formula for output voltage:
  33:main.c        **** *	Vout = [(L-Lmin)/(Lmax-Lmin)]*5
  34:main.c        **** *
  35:main.c        **** * example to provide lambda range from 0.64 to 1.36:
  36:main.c        **** *	 LAMBDA_MIN	64UL
  37:main.c        **** *	 LAMBDA_MAX 136UL
  38:main.c        **** * Set two values below: 
  39:main.c        **** */
  40:main.c        **** #define LAMBDA_MIN	64UL// set to desired value for 0v output (Lambda*100)
  41:main.c        **** #define LAMBDA_MAX 136UL//set to desired value for 5v output	(Lambda*100
  42:main.c        **** ////////end calibration settings/////////////
  43:main.c        **** 
  44:main.c        **** #define NUM_BOXES 3//for boxcar averaging.  Set to 1 for no averaging
  45:main.c        **** 
  46:main.c        **** #define DAC_FACTOR 2550000UL/(LAMBDA_MAX-LAMBDA_MIN)//don't change: just a calculation pre-compile
  47:main.c        **** 
  48:main.c        **** //#define MAXPUMP_I 196 // maximum current value for pump (leanest).
  49:main.c        **** #define MAXPUMP_I 254 // maximum current value for pump (leanest).
  50:main.c        ****  
  51:main.c        **** #define MINPUMP_I 50 // minimum current value for pump.  
  52:main.c        **** //NOTE (based on manual pump power settings)
  53:main.c        **** // Above max, virt gnd is pushed up. 
  54:main.c        **** // Nothing happens below min.
  55:main.c        **** // 0 current is at 116
  56:main.c        **** 
  57:main.c        **** //#define TARGET_NERNST 832 // lambda=1 value for nurnst, target for pump pid 
  58:main.c        **** #define TARGET_NERNST 855 // lambda=1 value for nurnst, target for pump pid
  59:main.c        **** #define TARGET_TEMP 237 
  60:main.c        **** #define P_temp    350//was 450
  61:main.c        **** #define I_temp    100//5
  62:main.c        **** #define D_temp    0//1
  63:main.c        **** 
  64:main.c        **** //#define P_pump    15
  65:main.c        **** //#define I_pump    74
  66:main.c        **** //#define D_pump    2
  67:main.c        **** 
  68:main.c        **** #define P_pump    4//
  69:main.c        **** #define I_pump    10
  70:main.c        **** #define D_pump    0
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** //#define F_CPU 4000000UL
  74:main.c        **** //(in makefile)
  75:main.c        **** #define BAUD 9600UL
  76:main.c        **** #define UBRRVAL (F_CPU/(BAUD*16)-1)
  77:main.c        **** 
  78:main.c        **** 
  79:main.c        **** 
  80:main.c        **** //test
  81:main.c        **** //for manual ip ramp:
  82:main.c        **** uint32_t IpCount = 0;
  83:main.c        **** uint8_t ipramp = 0;
  84:main.c        **** 
  85:main.c        **** uint32_t box_data[NUM_BOXES];
  86:main.c        **** //in pid.h, changed scalevalue to 1 since parampeters are now integers: K * 128
  87:main.c        **** 
  88:main.c        **** uint8_t heat_power;//global value fed to timer 0 for heater pwm
  89:main.c        **** uint16_t ADC_data;//read the ADC into this
  90:main.c        **** 
  91:main.c        **** uint16_t nurnst = 0;// value read from adc2 for the nernst cell w/o DC
  92:main.c        **** uint16_t pump = 0;//measured voltage at pump
  93:main.c        **** uint16_t DC_val = 0;//value read from adc2 for the nernst cell w/DC
  94:main.c        **** 
  95:main.c        **** int16_t IpumpVolts=0;//difference from above proportional to current flowing to pump.
  96:main.c        **** uint16_t measured_temperature;//measured temperature value. also known as Ri
  97:main.c        **** uint32_t zero_to_5_WB;//value applier to timer2 to make DAC output
  98:main.c        **** 
  99:main.c        **** uint8_t ramp_flag=0;// flag gets set once the startup temperature ramp is done
 100:main.c        **** uint8_t its_off;//flag to keep track of the heater pwm state
 101:main.c        **** volatile uint8_t ADC_flag;//keeps track in the ADC interrupt 
 102:main.c        **** volatile uint8_t charspot=0;//keeps track of the position of the numbers going into the string
 103:main.c        **** volatile uint8_t rampcounter=0;//test couter
 104:main.c        **** 
 105:main.c        **** ////////////////////////////////////////////////////////////////////////
 106:main.c        **** //for PID:
 107:main.c        **** uint8_t pidCounter; //True when PID control loop should run one time
 108:main.c        **** struct PID_DATA pidData_temp; //termperature PID structure of vars
 109:main.c        **** struct PID_DATA pidData_pump; //pump PID structure of vars
 110:main.c        **** ////////////////////////////////////////////////////////////////////////
 111:main.c        **** 
 112:main.c        **** 
 113:main.c        **** 
 114:main.c        **** /////function prototypes/////
 115:main.c        **** uint16_t readadc(void);
 116:main.c        **** 
 117:main.c        **** void do_things(void);
 118:main.c        **** void two(void);
 119:main.c        **** void three(void);
 120:main.c        **** void four(void);
 121:main.c        **** void six_1(void);
 122:main.c        **** void six_2(void);
 123:main.c        **** void six_3(void);
 124:main.c        **** void seven(void);
 125:main.c        **** void eight(void);
 126:main.c        **** 
 127:main.c        **** void PID_pump(void);
 128:main.c        **** void PID_heater(void);
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** 
 132:main.c        **** ////Interrupt Service Routines
 133:main.c        **** ISR(ADC_vect)
 134:main.c        **** {
 135:main.c        **** ADC_data = readadc();
 136:main.c        **** 
 137:main.c        **** if (ADC_flag == 7)//
 138:main.c        **** {
 139:main.c        **** 	four();
 140:main.c        **** }	
 141:main.c        **** else if (ADC_flag == 2)
 142:main.c        **** {
 143:main.c        **** 	six_1();
 144:main.c        **** }
 145:main.c        **** else if (ADC_flag == 8)
 146:main.c        **** {
 147:main.c        **** 	six_2();
 148:main.c        **** }
 149:main.c        **** else if (ADC_flag == 9)
 150:main.c        **** {
 151:main.c        **** 	six_3();
 152:main.c        **** }	
 153:main.c        **** 
 154:main.c        **** else if (ADC_flag == 3)//nurnst
 155:main.c        **** {
 156:main.c        **** 	seven();
 157:main.c        **** }
 158:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 159:main.c        **** {
 160:main.c        **** 	eight();
 161:main.c        **** }
 162:main.c        **** 	else
 163:main.c        **** 	
 164:main.c        **** 	{
 165:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 166:main.c        **** 	}
 167:main.c        **** }
 168:main.c        **** ISR(TIMER0_OVF_vect)
 169:main.c        **** {		
 170:main.c        **** 	if (its_off==1)//pulse is off
 171:main.c        **** 	 {
 172:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 173:main.c        **** 		 its_off = 0;
 174:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 175:main.c        **** 		 if (newtimerval < 128)
 176:main.c        **** 		 {
 177:main.c        **** 			do_things();
 178:main.c        **** 		 }
 179:main.c        **** 		 TCNT0 = newtimerval;	 
 180:main.c        **** 	 }
 181:main.c        **** 	 else//pulse is on
 182:main.c        **** 	 {
 183:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 184:main.c        **** 		 its_off = 1; 
 185:main.c        **** 		 uint8_t newtimerval= (heat_power);
 186:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 187:main.c        **** 		 if (newtimerval < 128)
 188:main.c        **** 		 {
 189:main.c        **** 			do_things();
 190:main.c        **** 		 }
 191:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 192:main.c        **** 	 }
 193:main.c        **** 
 194:main.c        **** }
 195:main.c        **** 
 196:main.c        **** //////////////////////////////vvvvvvvvvvvvvvv MAIN  vvvvvvvvvvvvvvvvvvvvv//////////////////////////
 197:main.c        **** int main()
 198:main.c        **** {
 129               	.LM0:
 130               	.LFBB1:
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 0 */
 134               	.L__stack_usage = 0
 199:main.c        **** //set up all the pins as inputs and outputs
 200:main.c        **** /* 
 201:main.c        ****  * 	PC5 //outputs for R2R DAC/not used
 202:main.c        ****  * 	PC4
 203:main.c        ****  * 	PC3
 204:main.c        ****  *  PB5  
 205:main.c        ****  *  PB4
 206:main.c        ****  * 	PB0
 207:main.c        ****  * 
 208:main.c        ****  *  PD4  LED
 209:main.c        ****  * 
 210:main.c        ****  * Nernst DC connection: PB2
 211:main.c        ****  * nch mosfet for heater: PD5
 212:main.c        ****  * 
 213:main.c        ****  * PB1 = pump power OC1A timer out
 214:main.c        ****  * PB3 = output voltage OC2 timer output
 215:main.c        ****  *   //ADC:
 216:main.c        ****  * nernst V: 	adc2
 217:main.c        ****  * pump			adc0
 218:main.c        ****  *
 219:main.c        ****  */ 
 220:main.c        **** DDRC |= _BV(5)| _BV(4) | _BV(3);//six bit dac
 136               	.LM1:
 137 0000 84B3      		in r24,52-32
 138 0002 8863      		ori r24,lo8(56)
 139 0004 84BB      		out 52-32,r24
 221:main.c        **** DDRB |= _BV(5)| _BV(4) | _BV(0);//six bit dac
 141               	.LM2:
 142 0006 87B3      		in r24,55-32
 143 0008 8163      		ori r24,lo8(49)
 144 000a 87BB      		out 55-32,r24
 222:main.c        **** DDRD |= _BV(4);//LED
 146               	.LM3:
 147 000c 8C9A      		sbi 49-32,4
 223:main.c        **** 
 224:main.c        **** DDRD |= ( _BV(5));// mosfet for heater
 149               	.LM4:
 150 000e 8D9A      		sbi 49-32,5
 225:main.c        **** DDRB |= _BV(2);// dc for temperature measurment
 152               	.LM5:
 153 0010 BA9A      		sbi 55-32,2
 226:main.c        **** ////setup uart:////
 227:main.c        **** cli();//  disable interrupts until things are set up
 155               	.LM6:
 156               	/* #APP */
 157               	 ;  227 "main.c" 1
 158 0012 F894      		cli
 159               	 ;  0 "" 2
 228:main.c        **** 	//init uart
 229:main.c        ****     /* set baud rate */
 230:main.c        ****    	UBRRH = (UBRRVAL >> 8);
 161               	.LM7:
 162               	/* #NOAPP */
 163 0014 10BC      		out 64-32,__zero_reg__
 231:main.c        ****    	UBRRL = (UBRRVAL & 0xff);
 165               	.LM8:
 166 0016 89E1      		ldi r24,lo8(25)
 167 0018 89B9      		out 41-32,r24
 232:main.c        ****     /* set frame format: 8 bit, no parity, 1 bit */
 233:main.c        ****     UCSRC |=  (1 << URSEL | 1 << UCSZ1 | 1 << UCSZ0);
 169               	.LM9:
 170 001a 80B5      		in r24,64-32
 171 001c 8668      		ori r24,lo8(-122)
 172 001e 80BD      		out 64-32,r24
 234:main.c        ****     UCSRB |= (1 << RXEN | 1 << TXEN | 1 << RXCIE);//enable receive, transmit, and receive complete 
 174               	.LM10:
 175 0020 8AB1      		in r24,42-32
 176 0022 8869      		ori r24,lo8(-104)
 177 0024 8AB9      		out 42-32,r24
 235:main.c        **** 
 236:main.c        **** //disable uart input, avoid Rx buffer overrun:
 237:main.c        **** UCSRB &= ~(1 << RXEN);
 179               	.LM11:
 180 0026 5498      		cbi 42-32,4
 238:main.c        **** UCSRB &= ~(1 << RXCIE);
 182               	.LM12:
 183 0028 5798      		cbi 42-32,7
 239:main.c        **** 
 240:main.c        **** setup_timer1();// pump control current dac on OC1A  
 185               	.LM13:
 186 002a 00D0      		rcall setup_timer1
 241:main.c        **** setup_timer2();//output 0-5v on OC2  
 188               	.LM14:
 189 002c 00D0      		rcall setup_timer2
 242:main.c        **** 	
 243:main.c        **** pid_Init(P_temp, I_temp, D_temp, &pidData_temp);//set up PID structure for temperature
 191               	.LM15:
 192 002e 8EE5      		ldi r24,lo8(350)
 193 0030 91E0      		ldi r25,hi8(350)
 194 0032 64E6      		ldi r22,lo8(100)
 195 0034 70E0      		ldi r23,hi8(100)
 196 0036 40E0      		ldi r20,lo8(0)
 197 0038 50E0      		ldi r21,hi8(0)
 198 003a 20E0      		ldi r18,lo8(pidData_temp)
 199 003c 30E0      		ldi r19,hi8(pidData_temp)
 200 003e 00D0      		rcall pid_Init
 244:main.c        **** pid_Init(P_pump, I_pump, D_pump, &pidData_pump);//set up PID structure for nernst
 202               	.LM16:
 203 0040 84E0      		ldi r24,lo8(4)
 204 0042 90E0      		ldi r25,hi8(4)
 205 0044 6AE0      		ldi r22,lo8(10)
 206 0046 70E0      		ldi r23,hi8(10)
 207 0048 40E0      		ldi r20,lo8(0)
 208 004a 50E0      		ldi r21,hi8(0)
 209 004c 20E0      		ldi r18,lo8(pidData_pump)
 210 004e 30E0      		ldi r19,hi8(pidData_pump)
 211 0050 00D0      		rcall pid_Init
 245:main.c        **** sei();//enable interrupts
 213               	.LM17:
 214               	/* #APP */
 215               	 ;  245 "main.c" 1
 216 0052 7894      		sei
 217               	 ;  0 "" 2
 246:main.c        **** adc_init();
 219               	.LM18:
 220               	/* #NOAPP */
 221 0054 00D0      		rcall adc_init
 247:main.c        **** // ramp up heat:
 248:main.c        **** heat_power = 130;//initial time
 223               	.LM19:
 224 0056 82E8      		ldi r24,lo8(-126)
 225 0058 8093 0000 		sts heat_power,r24
 249:main.c        **** timer0init();
 227               	.LM20:
 228 005c 00D0      		rcall timer0init
 250:main.c        **** PORTD |= _BV(4);//LED on
 230               	.LM21:
 231 005e 949A      		sbi 50-32,4
 251:main.c        **** uart_putst("ramp temp\n");
 233               	.LM22:
 234 0060 80E0      		ldi r24,lo8(.LC1)
 235 0062 90E0      		ldi r25,hi8(.LC1)
 236 0064 00D0      		rcall uart_putst
 252:main.c        **** while (heat_power<200)
 238               	.LM23:
 239 0066 00C0      		rjmp .L2
 240               	.L3:
 253:main.c        **** {
 254:main.c        **** heat_power++;
 242               	.LM24:
 243 0068 8F5F      		subi r24,lo8(-(1))
 244 006a 8093 0000 		sts heat_power,r24
 245               	.LBB8:
 246               	.LBB9:
 248               	.Ltext1:
   1:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 250               	.LM25:
 251 006e 2FEB      		 ldi r18,lo8(119999)
 252 0070 34ED      	    ldi r19,hi8(119999)
 253 0072 41E0      	    ldi r20,hlo8(119999)
 254 0074 2150      	    1:subi r18,1
 255 0076 3040      	    sbci r19,0
 256 0078 4040      	    sbci r20,0
 257 007a 01F4      	    brne 1b
 258 007c 00C0      		rjmp .
 259 007e 0000      		nop
 260               	.LBE9:
 261               	.LBE8:
 263               	.Ltext2:
 255:main.c        **** _delay_ms(150);
 256:main.c        **** uart_put16dec(heat_power);
 265               	.LM26:
 266 0080 90E0      		ldi r25,lo8(0)
 267 0082 00D0      		rcall uart_put16dec
 257:main.c        **** uart_putch(',');
 269               	.LM27:
 270 0084 8CE2      		ldi r24,lo8(44)
 271 0086 00D0      		rcall uart_putch
 258:main.c        **** uart_putch(' ');
 273               	.LM28:
 274 0088 80E2      		ldi r24,lo8(32)
 275 008a 00D0      		rcall uart_putch
 276               	.L2:
 252:main.c        **** while (heat_power<200)
 278               	.LM29:
 279 008c 8091 0000 		lds r24,heat_power
 280 0090 883C      		cpi r24,lo8(-56)
 281 0092 00F0      		brlo .L3
 259:main.c        **** }
 260:main.c        **** uart_putch('\n');
 283               	.LM30:
 284 0094 8AE0      		ldi r24,lo8(10)
 285 0096 00D0      		rcall uart_putch
 261:main.c        **** ramp_flag=1;
 287               	.LM31:
 288 0098 81E0      		ldi r24,lo8(1)
 289 009a 8093 0000 		sts ramp_flag,r24
 290               	.L4:
 291 009e 00C0      		rjmp .L4
 293               	.Lscope1:
 294               		.text
 296               	.global	do_things
 298               	do_things:
 262:main.c        **** ///////////////////////
 263:main.c        **** while(1)
 264:main.c        **** 	{
 265:main.c        **** //most stuff handled in timer0 interrupt
 266:main.c        **** //Suggested: use a state machine, just read ADC data in the interrupt, and poll a flag to see if it
 267:main.c        **** 	}
 268:main.c        **** return 0;
 269:main.c        **** }
 270:main.c        **** //// end of main
 271:main.c        **** ///////////////////////////////////////////////////////// 
 272:main.c        **** //////vvvvvvvvvvvvvv functions vvvvvvvvvvvvvvvvv/////////
 273:main.c        **** /////////////////////////////////////////////////////////
 274:main.c        **** 
 275:main.c        **** void do_things(void)//do first adc, throw away pump measurement
 276:main.c        **** {  
 300               	.LM32:
 301               	.LFBB2:
 302               	/* prologue: function */
 303               	/* frame size = 0 */
 304               	/* stack size = 0 */
 305               	.L__stack_usage = 0
 277:main.c        **** 	if (ramp_flag == 1)
 307               	.LM33:
 308 0000 8091 0000 		lds r24,ramp_flag
 309 0004 8130      		cpi r24,lo8(1)
 310 0006 01F4      		brne .L5
 311               	.LBB14:
 312               	.LBB15:
 313               	.LBB16:
 314               	.LBB17:
 316               	.Ltext3:
 165:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr/bin/../lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 318               	.LM34:
 319 0008 82E4      		 ldi r24,lo8(66)
 320 000a 8A95      	    1:dec r24
 321 000c 01F4      	    brne 1b
 322 000e 00C0      		rjmp .
 323               	.LBE17:
 324               	.LBE16:
 326               	.Ltext4:
 278:main.c        **** 	{
 279:main.c        **** 	_delay_us(50);//maybe let things settle?
 280:main.c        **** 	ADC_flag = 7;//sets to run function after conversion
 328               	.LM35:
 329 0010 87E0      		ldi r24,lo8(7)
 330 0012 8093 0000 		sts ADC_flag,r24
 281:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 332               	.LM36:
 333 0016 80EC      		ldi r24,lo8(-64)
 334 0018 87B9      		out 39-32,r24
 282:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 336               	.LM37:
 337 001a 369A      		sbi 38-32,6
 338               	.L5:
 339 001c 0895      		ret
 340               	.LBE15:
 341               	.LBE14:
 343               	.Lscope2:
 345               	.global	__vector_9
 347               	__vector_9:
 169:main.c        **** {		
 349               	.LM38:
 350               	.LFBB3:
 351 001e 1F92      		push r1
 352 0020 0F92      		push r0
 353 0022 0FB6      		in r0,__SREG__
 354 0024 0F92      		push r0
 355 0026 1124      		clr __zero_reg__
 356 0028 2F93      		push r18
 357 002a 3F93      		push r19
 358 002c 4F93      		push r20
 359 002e 5F93      		push r21
 360 0030 6F93      		push r22
 361 0032 7F93      		push r23
 362 0034 8F93      		push r24
 363 0036 9F93      		push r25
 364 0038 AF93      		push r26
 365 003a BF93      		push r27
 366 003c CF93      		push r28
 367 003e EF93      		push r30
 368 0040 FF93      		push r31
 369               	/* prologue: Signal */
 370               	/* frame size = 0 */
 371               	/* stack size = 16 */
 372               	.L__stack_usage = 16
 170:main.c        **** 	if (its_off==1)//pulse is off
 374               	.LM39:
 375 0042 8091 0000 		lds r24,its_off
 376 0046 8130      		cpi r24,lo8(1)
 377 0048 01F4      		brne .L8
 378               	.LBB18:
 172:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 380               	.LM40:
 381 004a 959A      		sbi 50-32,5
 173:main.c        **** 		 its_off = 0;
 383               	.LM41:
 384 004c 1092 0000 		sts its_off,__zero_reg__
 174:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 386               	.LM42:
 387 0050 C091 0000 		lds r28,heat_power
 388 0054 C095      		com r28
 389 0056 00C0      		rjmp .L14
 390               	.L8:
 391               	.LBE18:
 392               	.LBB19:
 183:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 394               	.LM43:
 395 0058 9598      		cbi 50-32,5
 184:main.c        **** 		 its_off = 1; 
 397               	.LM44:
 398 005a 81E0      		ldi r24,lo8(1)
 399 005c 8093 0000 		sts its_off,r24
 185:main.c        **** 		 uint8_t newtimerval= (heat_power);
 401               	.LM45:
 402 0060 C091 0000 		lds r28,heat_power
 186:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 404               	.LM46:
 405 0064 C2BF      		out 82-32,r28
 406               	.L14:
 187:main.c        **** 		 if (newtimerval < 128)
 408               	.LM47:
 409 0066 C7FF      		sbrs r28,7
 189:main.c        **** 			do_things();
 411               	.LM48:
 412 0068 00D0      		rcall do_things
 413               	.L11:
 191:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 415               	.LM49:
 416 006a C2BF      		out 82-32,r28
 417               	/* epilogue start */
 418               	.LBE19:
 194:main.c        **** }
 420               	.LM50:
 421 006c FF91      		pop r31
 422 006e EF91      		pop r30
 423 0070 CF91      		pop r28
 424 0072 BF91      		pop r27
 425 0074 AF91      		pop r26
 426 0076 9F91      		pop r25
 427 0078 8F91      		pop r24
 428 007a 7F91      		pop r23
 429 007c 6F91      		pop r22
 430 007e 5F91      		pop r21
 431 0080 4F91      		pop r20
 432 0082 3F91      		pop r19
 433 0084 2F91      		pop r18
 434 0086 0F90      		pop r0
 435 0088 0FBE      		out __SREG__,r0
 436 008a 0F90      		pop r0
 437 008c 1F90      		pop r1
 438 008e 1895      		reti
 446               	.Lscope3:
 448               	.global	four
 450               	four:
 283:main.c        **** 	}	
 284:main.c        **** }
 285:main.c        **** void four(void)//record aux adc 1, mux for pump current
 286:main.c        **** { 
 452               	.LM51:
 453               	.LFBB4:
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 0 */
 457               	.L__stack_usage = 0
 287:main.c        **** 	ADC_flag = 2;
 459               	.LM52:
 460 0090 82E0      		ldi r24,lo8(2)
 461 0092 8093 0000 		sts ADC_flag,r24
 288:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 463               	.LM53:
 464 0096 80EC      		ldi r24,lo8(-64)
 465 0098 87B9      		out 39-32,r24
 289:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 467               	.LM54:
 468 009a 369A      		sbi 38-32,6
 469               	/* epilogue start */
 290:main.c        **** }	
 471               	.LM55:
 472 009c 0895      		ret
 474               	.Lscope4:
 476               	.global	six_1
 478               	six_1:
 291:main.c        **** 
 292:main.c        **** void six_1(void)//measures pump current 1/3 sample
 293:main.c        **** {	
 480               	.LM56:
 481               	.LFBB5:
 482               	/* prologue: function */
 483               	/* frame size = 0 */
 484               	/* stack size = 0 */
 485               	.L__stack_usage = 0
 294:main.c        **** 	pump = ADC_data;
 487               	.LM57:
 488 009e 8091 0000 		lds r24,ADC_data
 489 00a2 9091 0000 		lds r25,ADC_data+1
 490 00a6 9093 0000 		sts pump+1,r25
 491 00aa 8093 0000 		sts pump,r24
 295:main.c        **** 	ADC_flag = 8;	
 493               	.LM58:
 494 00ae 88E0      		ldi r24,lo8(8)
 495 00b0 8093 0000 		sts ADC_flag,r24
 296:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 497               	.LM59:
 498 00b4 369A      		sbi 38-32,6
 499               	/* epilogue start */
 297:main.c        **** }
 501               	.LM60:
 502 00b6 0895      		ret
 504               	.Lscope5:
 506               	.global	six_2
 508               	six_2:
 298:main.c        **** 
 299:main.c        **** void six_2(void)//measures pump current 2/3
 300:main.c        **** {	
 510               	.LM61:
 511               	.LFBB6:
 512               	/* prologue: function */
 513               	/* frame size = 0 */
 514               	/* stack size = 0 */
 515               	.L__stack_usage = 0
 301:main.c        **** 	pump = pump + ADC_data;
 517               	.LM62:
 518 00b8 8091 0000 		lds r24,pump
 519 00bc 9091 0000 		lds r25,pump+1
 520 00c0 2091 0000 		lds r18,ADC_data
 521 00c4 3091 0000 		lds r19,ADC_data+1
 522 00c8 820F      		add r24,r18
 523 00ca 931F      		adc r25,r19
 524 00cc 9093 0000 		sts pump+1,r25
 525 00d0 8093 0000 		sts pump,r24
 302:main.c        **** 	ADC_flag = 9;	
 527               	.LM63:
 528 00d4 89E0      		ldi r24,lo8(9)
 529 00d6 8093 0000 		sts ADC_flag,r24
 303:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 531               	.LM64:
 532 00da 369A      		sbi 38-32,6
 533               	/* epilogue start */
 304:main.c        **** }
 535               	.LM65:
 536 00dc 0895      		ret
 538               	.Lscope6:
 540               	.global	six_3
 542               	six_3:
 305:main.c        **** 
 306:main.c        **** void six_3(void)//measures pump current 3/3
 307:main.c        **** {	
 544               	.LM66:
 545               	.LFBB7:
 546               	/* prologue: function */
 547               	/* frame size = 0 */
 548               	/* stack size = 0 */
 549               	.L__stack_usage = 0
 308:main.c        **** 	pump = pump + ADC_data;
 551               	.LM67:
 552 00de 8091 0000 		lds r24,ADC_data
 553 00e2 9091 0000 		lds r25,ADC_data+1
 554 00e6 2091 0000 		lds r18,pump
 555 00ea 3091 0000 		lds r19,pump+1
 556 00ee 820F      		add r24,r18
 557 00f0 931F      		adc r25,r19
 309:main.c        **** 	pump = pump/3;
 559               	.LM68:
 560 00f2 63E0      		ldi r22,lo8(3)
 561 00f4 70E0      		ldi r23,hi8(3)
 562 00f6 00D0      		rcall __udivmodhi4
 563 00f8 CB01      		movw r24,r22
 564 00fa 6093 0000 		sts pump,r22
 565 00fe 9093 0000 		sts pump+1,r25
 310:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 567               	.LM69:
 568 0102 4091 0000 		lds r20,charspot
 569 0106 60E0      		ldi r22,lo8(0)
 570 0108 00D0      		rcall put_in_string
 571 010a 8093 0000 		sts charspot,r24
 311:main.c        **** 	ADC_flag = 3;	
 573               	.LM70:
 574 010e 83E0      		ldi r24,lo8(3)
 575 0110 8093 0000 		sts ADC_flag,r24
 312:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 577               	.LM71:
 578 0114 82EC      		ldi r24,lo8(-62)
 579 0116 87B9      		out 39-32,r24
 313:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 581               	.LM72:
 582 0118 369A      		sbi 38-32,6
 583               	/* epilogue start */
 314:main.c        **** }
 585               	.LM73:
 586 011a 0895      		ret
 588               	.Lscope7:
 590               	.global	seven
 592               	seven:
 315:main.c        **** 
 316:main.c        **** void seven(void)//measure nurnst 
 317:main.c        **** {
 594               	.LM74:
 595               	.LFBB8:
 596               	/* prologue: function */
 597               	/* frame size = 0 */
 598               	/* stack size = 0 */
 599               	.L__stack_usage = 0
 318:main.c        **** 	nurnst = ADC_data;
 601               	.LM75:
 602 011c 8091 0000 		lds r24,ADC_data
 603 0120 9091 0000 		lds r25,ADC_data+1
 604 0124 9093 0000 		sts nurnst+1,r25
 605 0128 8093 0000 		sts nurnst,r24
 319:main.c        **** 	charspot = put_in_string(nurnst,'\0',charspot);//puts data in big string
 607               	.LM76:
 608 012c 4091 0000 		lds r20,charspot
 609 0130 60E0      		ldi r22,lo8(0)
 610 0132 00D0      		rcall put_in_string
 611 0134 8093 0000 		sts charspot,r24
 320:main.c        **** 	ADC_flag = 4;
 613               	.LM77:
 614 0138 84E0      		ldi r24,lo8(4)
 615 013a 8093 0000 		sts ADC_flag,r24
 321:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 617               	.LM78:
 618 013e 82EC      		ldi r24,lo8(-62)
 619 0140 87B9      		out 39-32,r24
 322:main.c        **** 	PORTB |= _BV(2);//DC on
 621               	.LM79:
 622 0142 C29A      		sbi 56-32,2
 323:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 624               	.LM80:
 625 0144 369A      		sbi 38-32,6
 626               	/* epilogue start */
 324:main.c        **** }
 628               	.LM81:
 629 0146 0895      		ret
 631               	.Lscope8:
 633               	.global	readadc
 635               	readadc:
 325:main.c        **** 
 326:main.c        **** void eight(void)
 327:main.c        **** {
 328:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 329:main.c        **** 	DC_val = ADC_data;
 330:main.c        **** //	charspot = put_in_string(DC_val,'d',charspot);//puts data in big string
 331:main.c        **** 	ADC_flag = 0;	
 332:main.c        **** 	////do calculations and PIDs
 333:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 334:main.c        **** 	//done in PID_pump//charspot = put_in_string(measured_temperature,'f',charspot);
 335:main.c        **** 	measured_temperature = (DC_val - nurnst);
 336:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 337:main.c        **** 		{
 338:main.c        **** 		measured_temperature = (255 - measured_temperature);
 339:main.c        **** 		}
 340:main.c        **** 	else
 341:main.c        **** 		{
 342:main.c        **** 		measured_temperature =0;
 343:main.c        **** 		}
 344:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 345:main.c        **** 		{
 346:main.c        **** 		PORTD &=~ _BV(4);//LED off
 347:main.c        **** 		}
 348:main.c        **** 	else
 349:main.c        **** 		{
 350:main.c        **** 		PORTD |= _BV(4);//LED on
 351:main.c        **** 		}
 352:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 353:main.c        **** 	
 354:main.c        **** 	//boxcar average pump current:
 355:main.c        **** 	for (uint8_t i = 0; i<(NUM_BOXES-1); i++)//shift boxcars
 356:main.c        **** 	{
 357:main.c        **** 		box_data[i]=box_data[i+1];
 358:main.c        **** 	}
 359:main.c        **** 	box_data[NUM_BOXES-1] = pump;//put in latest value
 360:main.c        **** 	uint16_t avrg_data_tot = 0; 
 361:main.c        **** 	for (uint8_t i = 0; i<(NUM_BOXES); i++)//add up boxcars
 362:main.c        **** 	{
 363:main.c        **** 	avrg_data_tot = avrg_data_tot+box_data[i];
 364:main.c        **** 	}
 365:main.c        **** 	pump = avrg_data_tot/NUM_BOXES;//get averaged value
 366:main.c        **** 	
 367:main.c        **** 	//calculate lambda output from Look Up Table:
 368:main.c        **** 	struct two_col{
 369:main.c        **** 		uint16_t x;
 370:main.c        **** 		uint16_t y;
 371:main.c        **** 	}; 
 372:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 373:main.c        **** 		{200,0},
 374:main.c        **** 		{280,68},
 375:main.c        **** 		{392,80},
 376:main.c        **** 		{442,85},
 377:main.c        **** 		{488,90},
 378:main.c        **** 		{562,100},
 379:main.c        **** 		{616,110},
 380:main.c        **** 		{669,143},
 381:main.c        **** 		{712,170},
 382:main.c        **** 		{783,242},
 383:main.c        **** 		{960,20200},
 384:main.c        **** 		{1024,26000},
 385:main.c        **** 		};
 386:main.c        **** 	uint8_t n = 12;//number of rows in table	
 387:main.c        **** 	uint32_t lambda=0;
 388:main.c        **** 	//out of range check:
 389:main.c        **** 	if (pump<lambda_curve[0].x)//smaller than the lowest value in LOT
 390:main.c        **** 	{lambda = lambda_curve[0].y;}
 391:main.c        **** 	else if (pump>lambda_curve[n-1].x)//larger than the highest value in the LOT
 392:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 393:main.c        **** 	//lookup in table, interpolate
 394:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 395:main.c        **** 	{
 396:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 397:main.c        **** 		{
 398:main.c        **** 			uint16_t diffx = pump - lambda_curve[i].x; //difference between the pump value and the x value i
 399:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 400:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 401:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 402:main.c        **** 		}
 403:main.c        **** 	}
 404:main.c        **** 	lambda = lambda + POSOFFSET;
 405:main.c        **** 	lambda = lambda - NEGOFFSET;
 406:main.c        **** 	
 407:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 408:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 409:main.c        **** 	{
 410:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 411:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 412:main.c        **** 	}
 413:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 414:main.c        **** 	else {zero_to_5_WB = 0;}
 415:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 416:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 417:main.c        **** 	
 418:main.c        **** 
 419:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 420:main.c        **** //	charspot = put_in_string(heat_power,'h',charspot);//puts data in big string
 421:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 422:main.c        **** }
 423:main.c        **** 	
 424:main.c        **** uint16_t readadc(void)
 425:main.c        **** {
 637               	.LM82:
 638               	.LFBB9:
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 426:main.c        **** 	uint8_t adcDataL = ADCL;
 644               	.LM83:
 645 0148 84B1      		in r24,36-32
 427:main.c        ****     uint8_t adcDataH = ADCH;
 647               	.LM84:
 648 014a 95B1      		in r25,37-32
 428:main.c        ****     uint16_t adcData = 0;
 429:main.c        ****     adcData = adcData | adcDataH;
 430:main.c        ****     adcData = adcData << 8;//left shift 8 spots
 650               	.LM85:
 651 014c 392F      		mov r19,r25
 652 014e 20E0      		ldi r18,lo8(0)
 431:main.c        ****     adcData = adcData | adcDataL;
 654               	.LM86:
 655 0150 90E0      		ldi r25,lo8(0)
 656 0152 822B      		or r24,r18
 657 0154 932B      		or r25,r19
 658               	/* epilogue start */
 432:main.c        ****     return adcData;
 433:main.c        **** }
 660               	.LM87:
 661 0156 0895      		ret
 667               	.Lscope9:
 669               	.global	PID_heater
 671               	PID_heater:
 434:main.c        **** 
 435:main.c        **** void PID_heater(void)
 436:main.c        **** {
 673               	.LM88:
 674               	.LFBB10:
 675               	/* prologue: function */
 676               	/* frame size = 0 */
 677               	/* stack size = 0 */
 678               	.L__stack_usage = 0
 437:main.c        **** 	int32_t calculated = pid_Controller(TARGET_TEMP, measured_temperature, &pidData_temp);  // for tem
 680               	.LM89:
 681 0158 6091 0000 		lds r22,measured_temperature
 682 015c 7091 0000 		lds r23,measured_temperature+1
 683 0160 8DEE      		ldi r24,lo8(237)
 684 0162 90E0      		ldi r25,hi8(237)
 685 0164 40E0      		ldi r20,lo8(pidData_temp)
 686 0166 50E0      		ldi r21,hi8(pidData_temp)
 687 0168 00D0      		rcall pid_Controller
 688 016a AA27      		clr r26
 689 016c 97FD      		sbrc r25,7
 690 016e A095      		com r26
 691 0170 BA2F      		mov r27,r26
 438:main.c        **** 
 439:main.c        **** 	if ((calculated) > 255 )
 693               	.LM90:
 694 0172 8F3F      		cpi r24,lo8(255)
 695 0174 9105      		cpc r25,__zero_reg__
 696 0176 A105      		cpc r26,__zero_reg__
 697 0178 B105      		cpc r27,__zero_reg__
 698 017a 01F0      		breq .L22
 699 017c 04F0      		brlt .L22
 440:main.c        **** 	{
 441:main.c        **** 		heat_power = 255 ;
 701               	.LM91:
 702 017e 8FEF      		ldi r24,lo8(-1)
 703 0180 00C0      		rjmp .L24
 704               	.L22:
 442:main.c        **** 	}
 443:main.c        **** 	else if ((calculated) < 0 )
 706               	.LM92:
 707 0182 B7FF      		sbrs r27,7
 708 0184 00C0      		rjmp .L24
 444:main.c        **** 	{
 445:main.c        **** 		heat_power = 0 ;
 710               	.LM93:
 711 0186 1092 0000 		sts heat_power,__zero_reg__
 712 018a 0895      		ret
 713               	.L24:
 446:main.c        **** 	}
 447:main.c        **** 	else
 448:main.c        **** 	{
 449:main.c        **** 		heat_power =(calculated);
 715               	.LM94:
 716 018c 8093 0000 		sts heat_power,r24
 717 0190 0895      		ret
 722               	.Lscope10:
 724               	.global	PID_pump
 726               	PID_pump:
 450:main.c        **** 	}
 451:main.c        **** 
 452:main.c        **** }
 453:main.c        **** 
 454:main.c        **** void PID_pump(void)
 455:main.c        **** {
 728               	.LM95:
 729               	.LFBB11:
 730               	/* prologue: function */
 731               	/* frame size = 0 */
 732               	/* stack size = 0 */
 733               	.L__stack_usage = 0
 456:main.c        **** 	//int32_t calculated =  ( pid_Controller(TARGET_NERNST, nurnst, &pidData_pump) );  // PID
 457:main.c        **** 
 458:main.c        **** 	int32_t calculated = 0;
 459:main.c        **** 	// manual ramp for testing //
 460:main.c        **** 	IpCount ++;
 735               	.LM96:
 736 0192 8091 0000 		lds r24,IpCount
 737 0196 9091 0000 		lds r25,IpCount+1
 738 019a A091 0000 		lds r26,IpCount+2
 739 019e B091 0000 		lds r27,IpCount+3
 740 01a2 0196      		adiw r24,1
 741 01a4 A11D      		adc r26,__zero_reg__
 742 01a6 B11D      		adc r27,__zero_reg__
 743 01a8 8093 0000 		sts IpCount,r24
 744 01ac 9093 0000 		sts IpCount+1,r25
 745 01b0 A093 0000 		sts IpCount+2,r26
 746 01b4 B093 0000 		sts IpCount+3,r27
 461:main.c        **** 	if (IpCount > 80UL)//nmber of loops before incrementing Ip power 
 748               	.LM97:
 749 01b8 8135      		cpi r24,lo8(81)
 750 01ba 9105      		cpc r25,__zero_reg__
 751 01bc A105      		cpc r26,__zero_reg__
 752 01be B105      		cpc r27,__zero_reg__
 753 01c0 00F0      		brlo .L26
 462:main.c        **** 	{
 463:main.c        **** 		ipramp++;
 755               	.LM98:
 756 01c2 8091 0000 		lds r24,ipramp
 757 01c6 8F5F      		subi r24,lo8(-(1))
 758 01c8 8093 0000 		sts ipramp,r24
 464:main.c        **** 		IpCount = 0;//reset counter
 760               	.LM99:
 761 01cc 1092 0000 		sts IpCount,__zero_reg__
 762 01d0 1092 0000 		sts IpCount+1,__zero_reg__
 763 01d4 1092 0000 		sts IpCount+2,__zero_reg__
 764 01d8 1092 0000 		sts IpCount+3,__zero_reg__
 465:main.c        **** 		if (ipramp>MAXPUMP_I) {ipramp = 180UL;}//reset to 180
 766               	.LM100:
 767 01dc 8F3F      		cpi r24,lo8(-1)
 768 01de 01F4      		brne .L27
 770               	.LM101:
 771 01e0 84EB      		ldi r24,lo8(-76)
 772 01e2 8093 0000 		sts ipramp,r24
 773               	.L27:
 466:main.c        **** 		if (ipramp<MAXPUMP_I-100) {ipramp = 180UL;}//start at 180
 775               	.LM102:
 776 01e6 8091 0000 		lds r24,ipramp
 777 01ea 8A39      		cpi r24,lo8(-102)
 778 01ec 00F4      		brsh .L26
 780               	.LM103:
 781 01ee 84EB      		ldi r24,lo8(-76)
 782 01f0 8093 0000 		sts ipramp,r24
 783               	.L26:
 467:main.c        **** 	}
 468:main.c        **** 	calculated = ipramp;
 785               	.LM104:
 786 01f4 8091 0000 		lds r24,ipramp
 787 01f8 90E0      		ldi r25,lo8(0)
 788 01fa A0E0      		ldi r26,lo8(0)
 789 01fc B0E0      		ldi r27,hi8(0)
 469:main.c        **** 	//calculated = (calculated) + 116;//116 is zero current.
 470:main.c        **** 	if ((calculated) > MAXPUMP_I)
 791               	.LM105:
 792 01fe 8F3F      		cpi r24,lo8(255)
 793 0200 9105      		cpc r25,__zero_reg__
 794 0202 A105      		cpc r26,__zero_reg__
 795 0204 B105      		cpc r27,__zero_reg__
 796 0206 01F4      		brne .L28
 471:main.c        **** 	{
 472:main.c        **** 		OCR1A = MAXPUMP_I;
 798               	.LM106:
 799 0208 8EEF      		ldi r24,lo8(254)
 800 020a 90E0      		ldi r25,hi8(254)
 801 020c 9BBD      		out 74+1-32,r25
 802 020e 8ABD      		out 74-32,r24
 473:main.c        **** 		ipramp = 0;//reset ramp
 804               	.LM107:
 805 0210 1092 0000 		sts ipramp,__zero_reg__
 806 0214 00C0      		rjmp .L29
 807               	.L28:
 474:main.c        **** 	}
 475:main.c        **** 	else if ((calculated) < MINPUMP_I)
 809               	.LM108:
 810 0216 8233      		cpi r24,lo8(50)
 811 0218 9105      		cpc r25,__zero_reg__
 812 021a A105      		cpc r26,__zero_reg__
 813 021c B105      		cpc r27,__zero_reg__
 814 021e 04F4      		brge .L30
 476:main.c        **** 	{
 477:main.c        **** 		OCR1A = MINPUMP_I;
 816               	.LM109:
 817 0220 82E3      		ldi r24,lo8(50)
 818 0222 90E0      		ldi r25,hi8(50)
 819               	.L30:
 478:main.c        **** 	}
 479:main.c        **** 	else
 480:main.c        **** 	{
 481:main.c        **** 		OCR1A =(calculated);
 821               	.LM110:
 822 0224 9BBD      		out 74+1-32,r25
 823 0226 8ABD      		out 74-32,r24
 824               	.L29:
 482:main.c        **** 	}
 483:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string	
 826               	.LM111:
 827 0228 8AB5      		in r24,74-32
 828 022a 9BB5      		in r25,74+1-32
 829 022c 4091 0000 		lds r20,charspot
 830 0230 60E0      		ldi r22,lo8(0)
 831 0232 00D0      		rcall put_in_string
 832 0234 8093 0000 		sts charspot,r24
 833               	/* epilogue start */
 484:main.c        **** 	//charspot = put_in_string(calculated,'\0',charspot);//puts data in big string
 485:main.c        **** 
 486:main.c        **** }
 835               	.LM112:
 836 0238 0895      		ret
 841               	.Lscope11:
 842               		.data
 843               	.LC0:
 844 000b C800      		.word	200
 845 000d 0000      		.word	0
 846 000f 1801      		.word	280
 847 0011 4400      		.word	68
 848 0013 8801      		.word	392
 849 0015 5000      		.word	80
 850 0017 BA01      		.word	442
 851 0019 5500      		.word	85
 852 001b E801      		.word	488
 853 001d 5A00      		.word	90
 854 001f 3202      		.word	562
 855 0021 6400      		.word	100
 856 0023 6802      		.word	616
 857 0025 6E00      		.word	110
 858 0027 9D02      		.word	669
 859 0029 8F00      		.word	143
 860 002b C802      		.word	712
 861 002d AA00      		.word	170
 862 002f 0F03      		.word	783
 863 0031 F200      		.word	242
 864 0033 C003      		.word	960
 865 0035 E84E      		.word	20200
 866 0037 0004      		.word	1024
 867 0039 9065      		.word	26000
 868               		.text
 870               	.global	eight
 872               	eight:
 327:main.c        **** {
 874               	.LM113:
 875               	.LFBB12:
 876 023a AF92      		push r10
 877 023c BF92      		push r11
 878 023e CF92      		push r12
 879 0240 DF92      		push r13
 880 0242 EF92      		push r14
 881 0244 FF92      		push r15
 882 0246 0F93      		push r16
 883 0248 1F93      		push r17
 884 024a CF93      		push r28
 885 024c DF93      		push r29
 886 024e CDB7      		in r28,__SP_L__
 887 0250 DEB7      		in r29,__SP_H__
 888 0252 E097      		sbiw r28,48
 889 0254 0FB6      		in __tmp_reg__,__SREG__
 890 0256 F894      		cli
 891 0258 DEBF      		out __SP_H__,r29
 892 025a 0FBE      		out __SREG__,__tmp_reg__
 893 025c CDBF      		out __SP_L__,r28
 894               	/* prologue: function */
 895               	/* frame size = 48 */
 896               	/* stack size = 58 */
 897               	.L__stack_usage = 58
 328:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 899               	.LM114:
 900 025e C298      		cbi 56-32,2
 329:main.c        **** 	DC_val = ADC_data;
 902               	.LM115:
 903 0260 8091 0000 		lds r24,ADC_data
 904 0264 9091 0000 		lds r25,ADC_data+1
 905 0268 9093 0000 		sts DC_val+1,r25
 906 026c 8093 0000 		sts DC_val,r24
 331:main.c        **** 	ADC_flag = 0;	
 908               	.LM116:
 909 0270 1092 0000 		sts ADC_flag,__zero_reg__
 333:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 911               	.LM117:
 912 0274 00D0      		rcall PID_pump
 335:main.c        **** 	measured_temperature = (DC_val - nurnst);
 914               	.LM118:
 915 0276 8091 0000 		lds r24,DC_val
 916 027a 9091 0000 		lds r25,DC_val+1
 917 027e 2091 0000 		lds r18,nurnst
 918 0282 3091 0000 		lds r19,nurnst+1
 919 0286 821B      		sub r24,r18
 920 0288 930B      		sbc r25,r19
 336:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 922               	.LM119:
 923 028a 8F3F      		cpi r24,255
 924 028c 9105      		cpc r25,__zero_reg__
 925 028e 01F0      		breq .+2
 926 0290 00F4      		brsh .L32
 338:main.c        **** 		measured_temperature = (255 - measured_temperature);
 928               	.LM120:
 929 0292 2FEF      		ldi r18,lo8(255)
 930 0294 30E0      		ldi r19,hi8(255)
 931 0296 281B      		sub r18,r24
 932 0298 390B      		sbc r19,r25
 933 029a 3093 0000 		sts measured_temperature+1,r19
 934 029e 2093 0000 		sts measured_temperature,r18
 935 02a2 00C0      		rjmp .L33
 936               	.L32:
 342:main.c        **** 		measured_temperature =0;
 938               	.LM121:
 939 02a4 1092 0000 		sts measured_temperature+1,__zero_reg__
 940 02a8 1092 0000 		sts measured_temperature,__zero_reg__
 941               	.L33:
 344:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 943               	.LM122:
 944 02ac 8091 0000 		lds r24,measured_temperature
 945 02b0 9091 0000 		lds r25,measured_temperature+1
 946 02b4 9C01      		movw r18,r24
 947 02b6 295E      		subi r18,lo8(-(-233))
 948 02b8 3040      		sbci r19,hi8(-(-233))
 949 02ba 2930      		cpi r18,9
 950 02bc 3105      		cpc r19,__zero_reg__
 951 02be 00F4      		brsh .L34
 346:main.c        **** 		PORTD &=~ _BV(4);//LED off
 953               	.LM123:
 954 02c0 9498      		cbi 50-32,4
 955 02c2 00C0      		rjmp .L35
 956               	.L34:
 350:main.c        **** 		PORTD |= _BV(4);//LED on
 958               	.LM124:
 959 02c4 949A      		sbi 50-32,4
 960               	.L35:
 352:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 962               	.LM125:
 963 02c6 4091 0000 		lds r20,charspot
 964 02ca 60E0      		ldi r22,lo8(0)
 965 02cc 00D0      		rcall put_in_string
 966 02ce 8093 0000 		sts charspot,r24
 967               	.LBB20:
 357:main.c        **** 		box_data[i]=box_data[i+1];
 969               	.LM126:
 970 02d2 4091 0000 		lds r20,box_data+4
 971 02d6 5091 0000 		lds r21,box_data+4+1
 972 02da 6091 0000 		lds r22,box_data+4+2
 973 02de 7091 0000 		lds r23,box_data+4+3
 974 02e2 4093 0000 		sts box_data,r20
 975 02e6 5093 0000 		sts box_data+1,r21
 976 02ea 6093 0000 		sts box_data+2,r22
 977 02ee 7093 0000 		sts box_data+3,r23
 978 02f2 8091 0000 		lds r24,box_data+8
 979 02f6 9091 0000 		lds r25,box_data+8+1
 980 02fa A091 0000 		lds r26,box_data+8+2
 981 02fe B091 0000 		lds r27,box_data+8+3
 982 0302 8093 0000 		sts box_data+4,r24
 983 0306 9093 0000 		sts box_data+4+1,r25
 984 030a A093 0000 		sts box_data+4+2,r26
 985 030e B093 0000 		sts box_data+4+3,r27
 986               	.LBE20:
 359:main.c        **** 	box_data[NUM_BOXES-1] = pump;//put in latest value
 988               	.LM127:
 989 0312 E091 0000 		lds r30,pump
 990 0316 F091 0000 		lds r31,pump+1
 991 031a 8F01      		movw r16,r30
 992 031c 20E0      		ldi r18,lo8(0)
 993 031e 30E0      		ldi r19,hi8(0)
 994 0320 0093 0000 		sts box_data+8,r16
 995 0324 1093 0000 		sts box_data+8+1,r17
 996 0328 2093 0000 		sts box_data+8+2,r18
 997 032c 3093 0000 		sts box_data+8+3,r19
 998               	.LBB21:
 363:main.c        **** 	avrg_data_tot = avrg_data_tot+box_data[i];
 1000               	.LM128:
 1001 0330 840F      		add r24,r20
 1002 0332 951F      		adc r25,r21
 1003 0334 8E0F      		add r24,r30
 1004 0336 9F1F      		adc r25,r31
 1005               	.LBE21:
 365:main.c        **** 	pump = avrg_data_tot/NUM_BOXES;//get averaged value
 1007               	.LM129:
 1008 0338 63E0      		ldi r22,lo8(3)
 1009 033a 70E0      		ldi r23,hi8(3)
 1010 033c 00D0      		rcall __udivmodhi4
 1011 033e 8B01      		movw r16,r22
 1012 0340 7093 0000 		sts pump+1,r23
 1013 0344 6093 0000 		sts pump,r22
 372:main.c        **** 	struct two_col lambda_curve[]={	//table columns: pump, lambda(x=pump current ADC value, y=lambda)
 1015               	.LM130:
 1016 0348 DE01      		movw r26,r28
 1017 034a 1196      		adiw r26,1
 1018 034c E0E0      		ldi r30,lo8(.LC0)
 1019 034e F0E0      		ldi r31,hi8(.LC0)
 1020 0350 80E3      		ldi r24,lo8(48)
 1021               	.L36:
 1022 0352 0190      		ld r0,Z+
 1023 0354 0D92      		st X+,r0
 1024 0356 8150      		subi r24,lo8(-(-1))
 1025 0358 01F4      		brne .L36
 389:main.c        **** 	if (pump<lambda_curve[0].x)//smaller than the lowest value in LOT
 1027               	.LM131:
 1028 035a 8981      		ldd r24,Y+1
 1029 035c 9A81      		ldd r25,Y+2
 1030 035e 0817      		cp r16,r24
 1031 0360 1907      		cpc r17,r25
 1032 0362 00F4      		brsh .L37
 390:main.c        **** 	{lambda = lambda_curve[0].y;}
 1034               	.LM132:
 1035 0364 CB80      		ldd r12,Y+3
 1036 0366 DC80      		ldd r13,Y+4
 1037 0368 00C0      		rjmp .L47
 1038               	.L45:
 387:main.c        **** 	uint32_t lambda=0;
 1040               	.LM133:
 1041 036a CC24      		clr r12
 1042 036c DD24      		clr r13
 1043 036e 7601      		movw r14,r12
 1044               	.L39:
 387:main.c        **** 	uint32_t lambda=0;
 1046               	.LM134:
 1047 0370 20E0      		ldi r18,lo8(0)
 1048 0372 00C0      		rjmp .L38
 1049               	.L37:
 391:main.c        **** 	else if (pump>lambda_curve[n-1].x)//larger than the highest value in the LOT
 1051               	.LM135:
 1052 0374 8DA5      		ldd r24,Y+45
 1053 0376 9EA5      		ldd r25,Y+46
 1054 0378 8017      		cp r24,r16
 1055 037a 9107      		cpc r25,r17
 1056 037c 00F4      		brsh .L45
 392:main.c        **** 	{lambda = lambda_curve[n-1].y;}
 1058               	.LM136:
 1059 037e CFA4      		ldd r12,Y+47
 1060 0380 D8A8      		ldd r13,Y+48
 1061               	.L47:
 1062 0382 EE24      		clr r14
 1063 0384 FF24      		clr r15
 1064 0386 00C0      		rjmp .L39
 1065               	.L41:
 1066               	.LBB22:
 396:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 1068               	.LM137:
 1069 0388 DC01      		movw r26,r24
 1070 038a AA0F      		lsl r26
 1071 038c BB1F      		rol r27
 1072 038e AA0F      		lsl r26
 1073 0390 BB1F      		rol r27
 1074 0392 41E0      		ldi r20,lo8(1)
 1075 0394 50E0      		ldi r21,hi8(1)
 1076 0396 4C0F      		add r20,r28
 1077 0398 5D1F      		adc r21,r29
 1078 039a A40F      		add r26,r20
 1079 039c B51F      		adc r27,r21
 1080 039e 6D91      		ld r22,X+
 1081 03a0 7C91      		ld r23,X
 1082 03a2 1197      		sbiw r26,1
 1083 03a4 0617      		cp r16,r22
 1084 03a6 1707      		cpc r17,r23
 1085 03a8 00F0      		brlo .L40
 396:main.c        **** 		if ( (lambda_curve[i].x <= pump )&& (lambda_curve[i+1].x >= pump) )
 1087               	.LM138:
 1088 03aa FC01      		movw r30,r24
 1089 03ac 3196      		adiw r30,1
 1090 03ae EE0F      		lsl r30
 1091 03b0 FF1F      		rol r31
 1092 03b2 EE0F      		lsl r30
 1093 03b4 FF1F      		rol r31
 1094 03b6 E40F      		add r30,r20
 1095 03b8 F51F      		adc r31,r21
 1096 03ba A080      		ld r10,Z
 1097 03bc B180      		ldd r11,Z+1
 1098 03be A016      		cp r10,r16
 1099 03c0 B106      		cpc r11,r17
 1100 03c2 00F0      		brlo .L40
 1101               	.LBB23:
 400:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 1103               	.LM139:
 1104 03c4 1296      		adiw r26,2
 1105 03c6 CD90      		ld r12,X+
 1106 03c8 DC90      		ld r13,X
 1107 03ca 1397      		sbiw r26,2+1
 398:main.c        **** 			uint16_t diffx = pump - lambda_curve[i].x; //difference between the pump value and the x value i
 1109               	.LM140:
 1110 03cc D801      		movw r26,r16
 1111 03ce A61B      		sub r26,r22
 1112 03d0 B70B      		sbc r27,r23
 400:main.c        **** 			uint16_t diffy = lambda_curve[i+1].y - lambda_curve[i].y;//spacing of y values in table
 1114               	.LM141:
 1115 03d2 8281      		ldd r24,Z+2
 1116 03d4 9381      		ldd r25,Z+3
 1117 03d6 8C19      		sub r24,r12
 1118 03d8 9D09      		sbc r25,r13
 401:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1120               	.LM142:
 1121 03da A89F      		mul r26,r24
 1122 03dc A001      		movw r20,r0
 1123 03de A99F      		mul r26,r25
 1124 03e0 500D      		add r21,r0
 1125 03e2 B89F      		mul r27,r24
 1126 03e4 500D      		add r21,r0
 1127 03e6 1124      		clr r1
 399:main.c        **** 			uint16_t diffn = lambda_curve[i+1].x - lambda_curve[i].x;//spacing between the values in the LOT
 1129               	.LM143:
 1130 03e8 C501      		movw r24,r10
 1131 03ea 861B      		sub r24,r22
 1132 03ec 970B      		sbc r25,r23
 1133 03ee BC01      		movw r22,r24
 401:main.c        **** 			lambda = lambda_curve[i].y + ((diffy * diffx )/diffn); //output value is interpolated.
 1135               	.LM144:
 1136 03f0 CA01      		movw r24,r20
 1137 03f2 00D0      		rcall __udivmodhi4
 1138 03f4 6C0D      		add r22,r12
 1139 03f6 7D1D      		adc r23,r13
 1140 03f8 6B01      		movw r12,r22
 1141 03fa EE24      		clr r14
 1142 03fc FF24      		clr r15
 1143               	.L40:
 1144               	.LBE23:
 394:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1146               	.LM145:
 1147 03fe 2F5F      		subi r18,lo8(-(1))
 1148               	.L38:
 394:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1150               	.LM146:
 1151 0400 822F      		mov r24,r18
 1152 0402 90E0      		ldi r25,lo8(0)
 1153 0404 2B30      		cpi r18,lo8(11)
 1154 0406 01F0      		breq .+2
 1155 0408 00C0      		rjmp .L41
 1156               	.LBE22:
 407:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 1158               	.LM147:
 1159 040a 4091 0000 		lds r20,charspot
 1160 040e C601      		movw r24,r12
 1161 0410 60E0      		ldi r22,lo8(0)
 1162 0412 00D0      		rcall put_in_string
 1163 0414 8093 0000 		sts charspot,r24
 408:main.c        **** 	if((lambda>=LAMBDA_MIN) && (lambda<=LAMBDA_MAX))
 1165               	.LM148:
 1166 0418 D701      		movw r26,r14
 1167 041a C601      		movw r24,r12
 1168 041c 8054      		subi r24,lo8(-(-64))
 1169 041e 9040      		sbci r25,hi8(-(-64))
 1170 0420 A040      		sbci r26,hlo8(-(-64))
 1171 0422 B040      		sbci r27,hhi8(-(-64))
 1172 0424 8934      		cpi r24,lo8(73)
 1173 0426 9105      		cpc r25,__zero_reg__
 1174 0428 A105      		cpc r26,__zero_reg__
 1175 042a B105      		cpc r27,__zero_reg__
 1176 042c 00F4      		brsh .L42
 1177               	.LBB24:
 410:main.c        **** 		uint32_t dacval = (lambda-LAMBDA_MIN)*DAC_FACTOR;
 1179               	.LM149:
 1180 042e C701      		movw r24,r14
 1181 0430 B601      		movw r22,r12
 1182 0432 20EF      		ldi r18,lo8(2550000)
 1183 0434 38EE      		ldi r19,hi8(2550000)
 1184 0436 46E2      		ldi r20,hlo8(2550000)
 1185 0438 50E0      		ldi r21,hhi8(2550000)
 1186 043a 00D0      		rcall __mulsi3
 1187 043c 6050      		subi r22,lo8(-(-163200000))
 1188 043e 7C43      		sbci r23,hi8(-(-163200000))
 1189 0440 8A4B      		sbci r24,hlo8(-(-163200000))
 1190 0442 9940      		sbci r25,hhi8(-(-163200000))
 1191 0444 28E4      		ldi r18,lo8(72)
 1192 0446 30E0      		ldi r19,hi8(72)
 1193 0448 40E0      		ldi r20,hlo8(72)
 1194 044a 50E0      		ldi r21,hhi8(72)
 1195 044c 00D0      		rcall __udivmodsi4
 411:main.c        **** 		zero_to_5_WB = dacval/10000UL;
 1197               	.LM150:
 1198 044e CA01      		movw r24,r20
 1199 0450 B901      		movw r22,r18
 1200 0452 20E1      		ldi r18,lo8(10000)
 1201 0454 37E2      		ldi r19,hi8(10000)
 1202 0456 40E0      		ldi r20,hlo8(10000)
 1203 0458 50E0      		ldi r21,hhi8(10000)
 1204 045a 00D0      		rcall __udivmodsi4
 1205 045c 2093 0000 		sts zero_to_5_WB,r18
 1206 0460 3093 0000 		sts zero_to_5_WB+1,r19
 1207 0464 4093 0000 		sts zero_to_5_WB+2,r20
 1208 0468 5093 0000 		sts zero_to_5_WB+3,r21
 1209 046c 00C0      		rjmp .L43
 1210               	.L42:
 1211               	.LBE24:
 413:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1213               	.LM151:
 1214 046e 99E8      		ldi r25,lo8(137)
 1215 0470 C916      		cp r12,r25
 1216 0472 D104      		cpc r13,__zero_reg__
 1217 0474 E104      		cpc r14,__zero_reg__
 1218 0476 F104      		cpc r15,__zero_reg__
 1219 0478 00F0      		brlo .L44
 413:main.c        **** 	else if (lambda>LAMBDA_MAX){zero_to_5_WB = 255;}
 1221               	.LM152:
 1222 047a 8FEF      		ldi r24,lo8(255)
 1223 047c 90E0      		ldi r25,hi8(255)
 1224 047e A0E0      		ldi r26,hlo8(255)
 1225 0480 B0E0      		ldi r27,hhi8(255)
 1226 0482 8093 0000 		sts zero_to_5_WB,r24
 1227 0486 9093 0000 		sts zero_to_5_WB+1,r25
 1228 048a A093 0000 		sts zero_to_5_WB+2,r26
 1229 048e B093 0000 		sts zero_to_5_WB+3,r27
 1230 0492 00C0      		rjmp .L43
 1231               	.L44:
 414:main.c        **** 	else {zero_to_5_WB = 0;}
 1233               	.LM153:
 1234 0494 1092 0000 		sts zero_to_5_WB,__zero_reg__
 1235 0498 1092 0000 		sts zero_to_5_WB+1,__zero_reg__
 1236 049c 1092 0000 		sts zero_to_5_WB+2,__zero_reg__
 1237 04a0 1092 0000 		sts zero_to_5_WB+3,__zero_reg__
 1238               	.L43:
 415:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 1240               	.LM154:
 1241 04a4 8091 0000 		lds r24,zero_to_5_WB
 1242 04a8 83BD      		out 67-32,r24
 416:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 1244               	.LM155:
 1245 04aa 4091 0000 		lds r20,charspot
 1246 04ae 8091 0000 		lds r24,zero_to_5_WB
 1247 04b2 9091 0000 		lds r25,zero_to_5_WB+1
 1248 04b6 60E0      		ldi r22,lo8(0)
 1249 04b8 00D0      		rcall put_in_string
 1250 04ba 8093 0000 		sts charspot,r24
 419:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 1252               	.LM156:
 1253 04be 00D0      		rcall PID_heater
 421:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 1255               	.LM157:
 1256 04c0 8091 0000 		lds r24,charspot
 1257 04c4 00D0      		rcall spitout
 1258 04c6 8093 0000 		sts charspot,r24
 1259               	/* epilogue start */
 422:main.c        **** }
 1261               	.LM158:
 1262 04ca E096      		adiw r28,48
 1263 04cc 0FB6      		in __tmp_reg__,__SREG__
 1264 04ce F894      		cli
 1265 04d0 DEBF      		out __SP_H__,r29
 1266 04d2 0FBE      		out __SREG__,__tmp_reg__
 1267 04d4 CDBF      		out __SP_L__,r28
 1268 04d6 DF91      		pop r29
 1269 04d8 CF91      		pop r28
 1270 04da 1F91      		pop r17
 1271 04dc 0F91      		pop r16
 1272 04de FF90      		pop r15
 1273 04e0 EF90      		pop r14
 1274 04e2 DF90      		pop r13
 1275 04e4 CF90      		pop r12
 1276 04e6 BF90      		pop r11
 1277 04e8 AF90      		pop r10
 1278 04ea 0895      		ret
 1287               	.Lscope12:
 1289               	.global	__vector_14
 1291               	__vector_14:
 134:main.c        **** {
 1293               	.LM159:
 1294               	.LFBB13:
 1295 04ec 1F92      		push r1
 1296 04ee 0F92      		push r0
 1297 04f0 0FB6      		in r0,__SREG__
 1298 04f2 0F92      		push r0
 1299 04f4 1124      		clr __zero_reg__
 1300 04f6 2F93      		push r18
 1301 04f8 3F93      		push r19
 1302 04fa 4F93      		push r20
 1303 04fc 5F93      		push r21
 1304 04fe 6F93      		push r22
 1305 0500 7F93      		push r23
 1306 0502 8F93      		push r24
 1307 0504 9F93      		push r25
 1308 0506 AF93      		push r26
 1309 0508 BF93      		push r27
 1310 050a EF93      		push r30
 1311 050c FF93      		push r31
 1312               	/* prologue: Signal */
 1313               	/* frame size = 0 */
 1314               	/* stack size = 15 */
 1315               	.L__stack_usage = 15
 135:main.c        **** ADC_data = readadc();
 1317               	.LM160:
 1318 050e 00D0      		rcall readadc
 1319 0510 9093 0000 		sts ADC_data+1,r25
 1320 0514 8093 0000 		sts ADC_data,r24
 137:main.c        **** if (ADC_flag == 7)//
 1322               	.LM161:
 1323 0518 8091 0000 		lds r24,ADC_flag
 1324 051c 8730      		cpi r24,lo8(7)
 1325 051e 01F4      		brne .L49
 139:main.c        **** 	four();
 1327               	.LM162:
 1328 0520 00D0      		rcall four
 1329 0522 00C0      		rjmp .L48
 1330               	.L49:
 141:main.c        **** else if (ADC_flag == 2)
 1332               	.LM163:
 1333 0524 8091 0000 		lds r24,ADC_flag
 1334 0528 8230      		cpi r24,lo8(2)
 1335 052a 01F4      		brne .L51
 143:main.c        **** 	six_1();
 1337               	.LM164:
 1338 052c 00D0      		rcall six_1
 1339 052e 00C0      		rjmp .L48
 1340               	.L51:
 145:main.c        **** else if (ADC_flag == 8)
 1342               	.LM165:
 1343 0530 8091 0000 		lds r24,ADC_flag
 1344 0534 8830      		cpi r24,lo8(8)
 1345 0536 01F4      		brne .L52
 147:main.c        **** 	six_2();
 1347               	.LM166:
 1348 0538 00D0      		rcall six_2
 1349 053a 00C0      		rjmp .L48
 1350               	.L52:
 149:main.c        **** else if (ADC_flag == 9)
 1352               	.LM167:
 1353 053c 8091 0000 		lds r24,ADC_flag
 1354 0540 8930      		cpi r24,lo8(9)
 1355 0542 01F4      		brne .L53
 151:main.c        **** 	six_3();
 1357               	.LM168:
 1358 0544 00D0      		rcall six_3
 1359 0546 00C0      		rjmp .L48
 1360               	.L53:
 154:main.c        **** else if (ADC_flag == 3)//nurnst
 1362               	.LM169:
 1363 0548 8091 0000 		lds r24,ADC_flag
 1364 054c 8330      		cpi r24,lo8(3)
 1365 054e 01F4      		brne .L54
 156:main.c        **** 	seven();
 1367               	.LM170:
 1368 0550 00D0      		rcall seven
 1369 0552 00C0      		rjmp .L48
 1370               	.L54:
 158:main.c        **** else if (ADC_flag == 4)//nurnst+DC and calculations
 1372               	.LM171:
 1373 0554 8091 0000 		lds r24,ADC_flag
 1374 0558 8430      		cpi r24,lo8(4)
 1375 055a 01F4      		brne .L55
 160:main.c        **** 	eight();
 1377               	.LM172:
 1378 055c 00D0      		rcall eight
 1379 055e 00C0      		rjmp .L48
 1380               	.L55:
 165:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 1382               	.LM173:
 1383 0560 00D0      		rcall readadc
 1384 0562 9093 0000 		sts ADC_data+1,r25
 1385 0566 8093 0000 		sts ADC_data,r24
 1386               	.L48:
 1387               	/* epilogue start */
 167:main.c        **** }
 1389               	.LM174:
 1390 056a FF91      		pop r31
 1391 056c EF91      		pop r30
 1392 056e BF91      		pop r27
 1393 0570 AF91      		pop r26
 1394 0572 9F91      		pop r25
 1395 0574 8F91      		pop r24
 1396 0576 7F91      		pop r23
 1397 0578 6F91      		pop r22
 1398 057a 5F91      		pop r21
 1399 057c 4F91      		pop r20
 1400 057e 3F91      		pop r19
 1401 0580 2F91      		pop r18
 1402 0582 0F90      		pop r0
 1403 0584 0FBE      		out __SREG__,r0
 1404 0586 0F90      		pop r0
 1405 0588 1F90      		pop r1
 1406 058a 1895      		reti
 1408               	.Lscope13:
 1409               		.comm pidData_pump,18,1
 1410               		.comm pidData_temp,18,1
 1411               		.comm pidCounter,1,1
 1412               	.global	rampcounter
 1413               	.global	rampcounter
 1414               		.section .bss
 1417               	rampcounter:
 1418 0000 00        		.skip 1,0
 1419               	.global	charspot
 1420               	.global	charspot
 1423               	charspot:
 1424 0001 00        		.skip 1,0
 1425               		.comm ADC_flag,1,1
 1426               		.comm its_off,1,1
 1427               	.global	ramp_flag
 1428               	.global	ramp_flag
 1431               	ramp_flag:
 1432 0002 00        		.skip 1,0
 1433               		.comm zero_to_5_WB,4,1
 1434               		.comm measured_temperature,2,1
 1435               	.global	IpumpVolts
 1436               	.global	IpumpVolts
 1439               	IpumpVolts:
 1440 0003 0000      		.skip 2,0
 1441               	.global	DC_val
 1442               	.global	DC_val
 1445               	DC_val:
 1446 0005 0000      		.skip 2,0
 1447               	.global	pump
 1448               	.global	pump
 1451               	pump:
 1452 0007 0000      		.skip 2,0
 1453               	.global	nurnst
 1454               	.global	nurnst
 1457               	nurnst:
 1458 0009 0000      		.skip 2,0
 1459               		.comm ADC_data,2,1
 1460               		.comm heat_power,1,1
 1461               		.comm box_data,12,1
 1462               	.global	ipramp
 1463               	.global	ipramp
 1466               	ipramp:
 1467 000b 00        		.skip 1,0
 1468               	.global	IpCount
 1469               	.global	IpCount
 1472               	IpCount:
 1473 000c 0000 0000 		.skip 4,0
 1474               		.comm serialout,50,1
 1495               		.text
 1497               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccYPlH6d.s:2      *ABS*:0000003f __SREG__
     /tmp/ccYPlH6d.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccYPlH6d.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccYPlH6d.s:5      *ABS*:00000034 __CCP__
     /tmp/ccYPlH6d.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccYPlH6d.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccYPlH6d.s:127    .text.startup:00000000 main
                            *COM*:00000012 pidData_temp
                            *COM*:00000012 pidData_pump
                            *COM*:00000001 heat_power
     /tmp/ccYPlH6d.s:1431   .bss:00000002 ramp_flag
     /tmp/ccYPlH6d.s:298    .text:00000000 do_things
                            *COM*:00000001 ADC_flag
     /tmp/ccYPlH6d.s:347    .text:0000001e __vector_9
                            *COM*:00000001 its_off
     /tmp/ccYPlH6d.s:450    .text:00000090 four
     /tmp/ccYPlH6d.s:478    .text:0000009e six_1
                            *COM*:00000002 ADC_data
     /tmp/ccYPlH6d.s:1451   .bss:00000007 pump
     /tmp/ccYPlH6d.s:508    .text:000000b8 six_2
     /tmp/ccYPlH6d.s:542    .text:000000de six_3
     /tmp/ccYPlH6d.s:1423   .bss:00000001 charspot
     /tmp/ccYPlH6d.s:592    .text:0000011c seven
     /tmp/ccYPlH6d.s:1457   .bss:00000009 nurnst
     /tmp/ccYPlH6d.s:635    .text:00000148 readadc
     /tmp/ccYPlH6d.s:671    .text:00000158 PID_heater
                            *COM*:00000002 measured_temperature
     /tmp/ccYPlH6d.s:726    .text:00000192 PID_pump
     /tmp/ccYPlH6d.s:1472   .bss:0000000c IpCount
     /tmp/ccYPlH6d.s:1466   .bss:0000000b ipramp
     /tmp/ccYPlH6d.s:872    .text:0000023a eight
     /tmp/ccYPlH6d.s:1445   .bss:00000005 DC_val
                            *COM*:0000000c box_data
                            *COM*:00000004 zero_to_5_WB
     /tmp/ccYPlH6d.s:1291   .text:000004ec __vector_14
                            *COM*:00000001 pidCounter
     /tmp/ccYPlH6d.s:1417   .bss:00000000 rampcounter
     /tmp/ccYPlH6d.s:1439   .bss:00000003 IpumpVolts
                            *COM*:00000032 serialout

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
setup_timer1
setup_timer2
pid_Init
adc_init
timer0init
uart_putst
uart_put16dec
uart_putch
__udivmodhi4
put_in_string
pid_Controller
__mulsi3
__udivmodsi4
spitout
