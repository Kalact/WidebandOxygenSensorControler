   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  86               		.data
  87               	.LC0:
  88 0000 7261 6D70 		.string	"ramp temp\n"
  88      2074 656D 
  88      700A 00
  89               		.text
  91               	.global	main
  93               	main:
   1:main.c        **** 
   2:main.c        **** /////////////---------------------------------///////////////////
   3:main.c        **** // 
   4:main.c        **** // www.waltech.com
   5:main.c        **** //
   6:main.c        **** /////////////---------------------------------/////////////////
   7:main.c        **** /*
   8:main.c        ****  * TO DO:  
   9:main.c        ****  * 	make led do something more?
  10:main.c        ****  */
  11:main.c        **** 
  12:main.c        **** //Includes here:
  13:main.c        **** 
  14:main.c        **** #include <avr/interrupt.h>
  15:main.c        **** #include <stdlib.h>
  16:main.c        **** #include <string.h>
  17:main.c        **** #include <util/delay.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include "pid.h"
  20:main.c        **** #include "stdint.h"
  21:main.c        **** #include "initilize_hardware.h"
  22:main.c        **** #include "dataout.h"
  23:main.c        **** //#define F_CPU 4000000UL
  24:main.c        **** //(in make file)
  25:main.c        **** #define BAUD 9600UL
  26:main.c        **** #define UBRRVAL (F_CPU/(BAUD*16)-1)
  27:main.c        **** 
  28:main.c        **** #define LOWER_NB 95 //lower value for start of narrow band curve.  
  29:main.c        **** #define MAXPUMP_I 196 // maximum current value for pump (leanest). 
  30:main.c        **** #define MINPUMP_I 50 // minimum current value for pump.  
  31:main.c        **** //NOTE (based on manual pump power settings)
  32:main.c        **** // Above max, virt gnd is pushed up. 
  33:main.c        **** // Nothing happens below min.
  34:main.c        **** // 0 current is at 116
  35:main.c        **** #define TARGET_NERNST 724 // lambda=1 value for nurnst, target for pump pid 
  36:main.c        **** #define TARGET_TEMP 237 
  37:main.c        **** #define P_temp    450
  38:main.c        **** #define I_temp    5
  39:main.c        **** #define D_temp    1
  40:main.c        **** 
  41:main.c        **** #define P_pump    15
  42:main.c        **** #define I_pump    74
  43:main.c        **** #define D_pump    2
  44:main.c        **** 
  45:main.c        **** //in pid.h, changed scalevalue to 1 since parampeters are now integers: K * 128
  46:main.c        **** 
  47:main.c        **** uint8_t heat_power;//global value fed to timer 0 for heater pwm
  48:main.c        **** uint16_t ADC_data;//read the ADC into this
  49:main.c        **** 
  50:main.c        **** uint16_t lambda = 0;// value read from adc2 for the nernst cell w/o DC
  51:main.c        **** uint16_t pump = 0;//measured voltage at pump
  52:main.c        **** uint16_t DC_val = 0;//value read from adc2 for the nernst cell w/DC
  53:main.c        **** 
  54:main.c        **** int16_t IpumpVolts=0;//difference from above proportional to current flowing to pump.
  55:main.c        **** uint16_t measured_temperature;//measured temperature value. also known as Ri
  56:main.c        **** uint32_t zero_to_5_WB;//value applier to timer2 to make DAC output
  57:main.c        **** 
  58:main.c        **** uint8_t ramp_flag=0;// flag gets set once the startup temperature ramp is done
  59:main.c        **** uint8_t its_off;//flag to keep track of the heater pwm state
  60:main.c        **** volatile uint8_t ADC_flag;//keeps track in the ADC interrupt 
  61:main.c        **** volatile uint8_t charspot=0;//keeps track of the position of the numbers going into the string
  62:main.c        **** volatile uint8_t rampcounter=0;//test couter
  63:main.c        **** 
  64:main.c        **** ////////////////////////////////////////////////////////////////////////
  65:main.c        **** //for PID:
  66:main.c        **** uint8_t pidCounter; //True when PID control loop should run one time
  67:main.c        **** struct PID_DATA pidData_temp; //termperature PID structure of vars
  68:main.c        **** struct PID_DATA pidData_pump; //pump PID structure of vars
  69:main.c        **** ////////////////////////////////////////////////////////////////////////
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        **** const uint8_t  Narro_curve[] PROGMEM= //256 values. How to get: OCR2=pgm_read_byte(&fiveVout[pump])
  73:main.c        **** {
  74:main.c        **** 0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  75:main.c        **** 0x0B,0x0B,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x09,0x09,0x09,0x08,0x08,0x08,0x07,0x07,
  76:main.c        **** 0x05,0x05,0x04,0x04,0x04,0x03,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
  77:main.c        **** 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
  78:main.c        **** };
  79:main.c        **** /////function prototypes/////
  80:main.c        **** uint16_t readadc(void);
  81:main.c        **** 
  82:main.c        **** void do_things(void);
  83:main.c        **** void two(void);
  84:main.c        **** void three(void);
  85:main.c        **** void four(void);
  86:main.c        **** void six_1(void);
  87:main.c        **** void six_2(void);
  88:main.c        **** void six_3(void);
  89:main.c        **** void seven(void);
  90:main.c        **** void eight(void);
  91:main.c        **** 
  92:main.c        **** void PID_pump(void);
  93:main.c        **** void PID_heater(void);
  94:main.c        **** void RtwoR_out(void);
  95:main.c        **** 
  96:main.c        **** 
  97:main.c        **** ////Interrupt Service Routines
  98:main.c        **** ISR(ADC_vect)
  99:main.c        **** {
 100:main.c        **** ADC_data = readadc();
 101:main.c        **** 
 102:main.c        **** if (ADC_flag == 7)//
 103:main.c        **** {
 104:main.c        **** 	four();
 105:main.c        **** }	
 106:main.c        **** else if (ADC_flag == 2)
 107:main.c        **** {
 108:main.c        **** 	six_1();
 109:main.c        **** }
 110:main.c        **** else if (ADC_flag == 8)
 111:main.c        **** {
 112:main.c        **** 	six_2();
 113:main.c        **** }
 114:main.c        **** else if (ADC_flag == 9)
 115:main.c        **** {
 116:main.c        **** 	six_3();
 117:main.c        **** }	
 118:main.c        **** 
 119:main.c        **** else if (ADC_flag == 3)//lambda
 120:main.c        **** {
 121:main.c        **** 	seven();
 122:main.c        **** }
 123:main.c        **** else if (ADC_flag == 4)//lambda+DC and calculations
 124:main.c        **** {
 125:main.c        **** 	eight();
 126:main.c        **** }
 127:main.c        **** 	else
 128:main.c        **** 	
 129:main.c        **** 	{
 130:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 131:main.c        **** 	}
 132:main.c        **** }
 133:main.c        **** ISR(TIMER0_OVF_vect)
 134:main.c        **** {		
 135:main.c        **** 	if (its_off==1)//pulse is off
 136:main.c        **** 	 {
 137:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 138:main.c        **** 		 its_off = 0;
 139:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 140:main.c        **** 		 if (newtimerval < 128)
 141:main.c        **** 		 {
 142:main.c        **** 			do_things();
 143:main.c        **** 		 }
 144:main.c        **** 		 TCNT0 = newtimerval;	 
 145:main.c        **** 	 }
 146:main.c        **** 	 else//pulse is on
 147:main.c        **** 	 {
 148:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 149:main.c        **** 		 its_off = 1; 
 150:main.c        **** 		 uint8_t newtimerval= (heat_power);
 151:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 152:main.c        **** 		 if (newtimerval < 128)
 153:main.c        **** 		 {
 154:main.c        **** 			do_things();
 155:main.c        **** 		 }
 156:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 157:main.c        **** 	 }
 158:main.c        **** 
 159:main.c        **** }
 160:main.c        **** 
 161:main.c        **** //////////////////////////////vvvvvvvvvvvvvvv MAIN  vvvvvvvvvvvvvvvvvvvvv//////////////////////////
 162:main.c        **** int main()
 163:main.c        **** {
  95               	.LM0:
  96               	.LFBB1:
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
 164:main.c        **** //set up all the pins as inputs and outputs
 165:main.c        **** /* 
 166:main.c        ****  * 	PC5 //outputs for R2R DAC
 167:main.c        ****  * 	PC4
 168:main.c        ****  * 	PC3
 169:main.c        ****  *  PB5  
 170:main.c        ****  *  PB4
 171:main.c        ****  * 	PB0
 172:main.c        ****  * 
 173:main.c        ****  *  PD4  LED
 174:main.c        ****  * 
 175:main.c        ****  * Nernst DC connection: PB2
 176:main.c        ****  * nch mosfet for heater: PD5
 177:main.c        ****  * 
 178:main.c        ****  * PB1 = pump power OC1A timer out
 179:main.c        ****  * PB3 = output voltage OC2 timer output
 180:main.c        ****  *   //ADC:
 181:main.c        ****  * nernst V: 	adc2
 182:main.c        ****  * pump			adc0
 183:main.c        ****  *
 184:main.c        ****  */ 
 185:main.c        **** DDRC |= _BV(5)| _BV(4) | _BV(3);//six bit dac
 102               	.LM1:
 103 0000 84B3      		in r24,52-32
 104 0002 8863      		ori r24,lo8(56)
 105 0004 84BB      		out 52-32,r24
 186:main.c        **** DDRB |= _BV(5)| _BV(4) | _BV(0);//six bit dac
 107               	.LM2:
 108 0006 87B3      		in r24,55-32
 109 0008 8163      		ori r24,lo8(49)
 110 000a 87BB      		out 55-32,r24
 187:main.c        **** DDRD |= _BV(4);//LED
 112               	.LM3:
 113 000c 8C9A      		sbi 49-32,4
 188:main.c        **** 
 189:main.c        **** DDRD |= ( _BV(5));// mosfet for heater
 115               	.LM4:
 116 000e 8D9A      		sbi 49-32,5
 190:main.c        **** DDRB |= _BV(2);// dc for temperature measurment
 118               	.LM5:
 119 0010 BA9A      		sbi 55-32,2
 191:main.c        **** ////setup uart:////
 192:main.c        **** cli();//  disable interrupts until things are set up
 121               	.LM6:
 122               	/* #APP */
 123               	 ;  192 "main.c" 1
 124 0012 F894      		cli
 125               	 ;  0 "" 2
 193:main.c        **** 	//init uart
 194:main.c        ****     /* set baud rate */
 195:main.c        ****    	UBRRH = (UBRRVAL >> 8);
 127               	.LM7:
 128               	/* #NOAPP */
 129 0014 10BC      		out 64-32,__zero_reg__
 196:main.c        ****    	UBRRL = (UBRRVAL & 0xff);
 131               	.LM8:
 132 0016 89E1      		ldi r24,lo8(25)
 133 0018 89B9      		out 41-32,r24
 197:main.c        ****     /* set frame format: 8 bit, no parity, 1 bit */
 198:main.c        ****     UCSRC |=  (1 << URSEL | 1 << UCSZ1 | 1 << UCSZ0);
 135               	.LM9:
 136 001a 80B5      		in r24,64-32
 137 001c 8668      		ori r24,lo8(-122)
 138 001e 80BD      		out 64-32,r24
 199:main.c        ****     UCSRB |= (1 << RXEN | 1 << TXEN | 1 << RXCIE);//enable receive, transmit, and receive complete 
 140               	.LM10:
 141 0020 8AB1      		in r24,42-32
 142 0022 8869      		ori r24,lo8(-104)
 143 0024 8AB9      		out 42-32,r24
 200:main.c        **** 
 201:main.c        **** //disable uart input, avoid Rx buffer overrun:
 202:main.c        **** UCSRB &= ~(1 << RXEN);
 145               	.LM11:
 146 0026 5498      		cbi 42-32,4
 203:main.c        **** UCSRB &= ~(1 << RXCIE);
 148               	.LM12:
 149 0028 5798      		cbi 42-32,7
 204:main.c        **** 
 205:main.c        **** setup_timer1();// pump control current dac on OC1A  
 151               	.LM13:
 152 002a 00D0      		rcall setup_timer1
 206:main.c        **** setup_timer2();//output 0-5v on OC2  
 154               	.LM14:
 155 002c 00D0      		rcall setup_timer2
 207:main.c        **** 	
 208:main.c        **** pid_Init(P_temp, I_temp, D_temp, &pidData_temp);//set up PID structure for temperature
 157               	.LM15:
 158 002e 82EC      		ldi r24,lo8(450)
 159 0030 91E0      		ldi r25,hi8(450)
 160 0032 65E0      		ldi r22,lo8(5)
 161 0034 70E0      		ldi r23,hi8(5)
 162 0036 41E0      		ldi r20,lo8(1)
 163 0038 50E0      		ldi r21,hi8(1)
 164 003a 20E0      		ldi r18,lo8(pidData_temp)
 165 003c 30E0      		ldi r19,hi8(pidData_temp)
 166 003e 00D0      		rcall pid_Init
 209:main.c        **** pid_Init(P_pump, I_pump, D_pump, &pidData_pump);//set up PID structure for nernst
 168               	.LM16:
 169 0040 8FE0      		ldi r24,lo8(15)
 170 0042 90E0      		ldi r25,hi8(15)
 171 0044 6AE4      		ldi r22,lo8(74)
 172 0046 70E0      		ldi r23,hi8(74)
 173 0048 42E0      		ldi r20,lo8(2)
 174 004a 50E0      		ldi r21,hi8(2)
 175 004c 20E0      		ldi r18,lo8(pidData_pump)
 176 004e 30E0      		ldi r19,hi8(pidData_pump)
 177 0050 00D0      		rcall pid_Init
 210:main.c        **** sei();//enable interrupts
 179               	.LM17:
 180               	/* #APP */
 181               	 ;  210 "main.c" 1
 182 0052 7894      		sei
 183               	 ;  0 "" 2
 211:main.c        **** adc_init();
 185               	.LM18:
 186               	/* #NOAPP */
 187 0054 00D0      		rcall adc_init
 212:main.c        **** // ramp up heat:
 213:main.c        **** heat_power = 130;//initial time
 189               	.LM19:
 190 0056 82E8      		ldi r24,lo8(-126)
 191 0058 8093 0000 		sts heat_power,r24
 214:main.c        **** timer0init();
 193               	.LM20:
 194 005c 00D0      		rcall timer0init
 215:main.c        **** PORTD |= _BV(4);//LED on
 196               	.LM21:
 197 005e 949A      		sbi 50-32,4
 216:main.c        **** uart_putst("ramp temp\n");
 199               	.LM22:
 200 0060 80E0      		ldi r24,lo8(.LC0)
 201 0062 90E0      		ldi r25,hi8(.LC0)
 202 0064 00D0      		rcall uart_putst
 217:main.c        **** while (heat_power<200)
 204               	.LM23:
 205 0066 00C0      		rjmp .L2
 206               	.L3:
 218:main.c        **** {
 219:main.c        **** heat_power++;
 208               	.LM24:
 209 0068 8F5F      		subi r24,lo8(-(1))
 210 006a 8093 0000 		sts heat_power,r24
 211               	.LBB6:
 212               	.LBB7:
 214               	.Ltext1:
   1:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 216               	.LM25:
 217 006e 2FEB      		 ldi r18,lo8(119999)
 218 0070 34ED      	    ldi r19,hi8(119999)
 219 0072 41E0      	    ldi r20,hlo8(119999)
 220 0074 2150      	    1:subi r18,1
 221 0076 3040      	    sbci r19,0
 222 0078 4040      	    sbci r20,0
 223 007a 01F4      	    brne 1b
 224 007c 00C0      		rjmp .
 225 007e 0000      		nop
 226               	.LBE7:
 227               	.LBE6:
 229               	.Ltext2:
 220:main.c        **** _delay_ms(150);
 221:main.c        **** uart_put16dec(heat_power);
 231               	.LM26:
 232 0080 90E0      		ldi r25,lo8(0)
 233 0082 00D0      		rcall uart_put16dec
 222:main.c        **** uart_putch(',');
 235               	.LM27:
 236 0084 8CE2      		ldi r24,lo8(44)
 237 0086 00D0      		rcall uart_putch
 223:main.c        **** uart_putch(' ');
 239               	.LM28:
 240 0088 80E2      		ldi r24,lo8(32)
 241 008a 00D0      		rcall uart_putch
 242               	.L2:
 217:main.c        **** while (heat_power<200)
 244               	.LM29:
 245 008c 8091 0000 		lds r24,heat_power
 246 0090 883C      		cpi r24,lo8(-56)
 247 0092 00F0      		brlo .L3
 224:main.c        **** }
 225:main.c        **** uart_putch('\n');
 249               	.LM30:
 250 0094 8AE0      		ldi r24,lo8(10)
 251 0096 00D0      		rcall uart_putch
 226:main.c        **** ramp_flag=1;
 253               	.LM31:
 254 0098 81E0      		ldi r24,lo8(1)
 255 009a 8093 0000 		sts ramp_flag,r24
 256               	.L4:
 257 009e 00C0      		rjmp .L4
 259               	.Lscope1:
 261               	.global	do_things
 263               	do_things:
 227:main.c        **** ///////////////////////
 228:main.c        **** while(1)
 229:main.c        **** 	{
 230:main.c        **** //most stuff handled in timer0 interrupt
 231:main.c        **** //Suggested: use a state machine, just read ADC data in the interrupt, and poll a flag to see if it
 232:main.c        **** 	}
 233:main.c        **** return 0;
 234:main.c        **** }
 235:main.c        **** //// end of main
 236:main.c        **** ///////////////////////////////////////////////////////// 
 237:main.c        **** //////vvvvvvvvvvvvvv functions vvvvvvvvvvvvvvvvv/////////
 238:main.c        **** /////////////////////////////////////////////////////////
 239:main.c        **** 
 240:main.c        **** void do_things(void)//do first adc
 241:main.c        **** {  
 265               	.LM32:
 266               	.LFBB2:
 267               	/* prologue: function */
 268               	/* frame size = 0 */
 269               	/* stack size = 0 */
 270               	.L__stack_usage = 0
 242:main.c        **** 	if (ramp_flag == 1)
 272               	.LM33:
 273 00a0 8091 0000 		lds r24,ramp_flag
 274 00a4 8130      		cpi r24,lo8(1)
 275 00a6 01F4      		brne .L5
 276               	.LBB8:
 277               	.LBB9:
 279               	.Ltext3:
 165:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 281               	.LM34:
 282 00a8 82E4      		 ldi r24,lo8(66)
 283 00aa 8A95      	    1:dec r24
 284 00ac 01F4      	    brne 1b
 285 00ae 00C0      		rjmp .
 286               	.LBE9:
 287               	.LBE8:
 289               	.Ltext4:
 243:main.c        **** 	{
 244:main.c        **** 	_delay_us(50);//maybe let things settle?
 245:main.c        **** 	ADC_flag = 7;//sets to run function after conversion
 291               	.LM35:
 292 00b0 87E0      		ldi r24,lo8(7)
 293 00b2 8093 0000 		sts ADC_flag,r24
 246:main.c        **** 	ADMUX =(192 + 1);//V refrence plus mux (192 => 2.5v vref; 64 => avcc vref)				
 295               	.LM36:
 296 00b6 81EC      		ldi r24,lo8(-63)
 297 00b8 87B9      		out 39-32,r24
 247:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion 
 299               	.LM37:
 300 00ba 369A      		sbi 38-32,6
 301               	.L5:
 302 00bc 0895      		ret
 304               	.Lscope2:
 306               	.global	__vector_9
 308               	__vector_9:
 134:main.c        **** {		
 310               	.LM38:
 311               	.LFBB3:
 312 00be 1F92      		push __zero_reg__
 313 00c0 0F92      		push r0
 314 00c2 0FB6      		in r0,__SREG__
 315 00c4 0F92      		push r0
 316 00c6 1124      		clr __zero_reg__
 317 00c8 2F93      		push r18
 318 00ca 3F93      		push r19
 319 00cc 4F93      		push r20
 320 00ce 5F93      		push r21
 321 00d0 6F93      		push r22
 322 00d2 7F93      		push r23
 323 00d4 8F93      		push r24
 324 00d6 9F93      		push r25
 325 00d8 AF93      		push r26
 326 00da BF93      		push r27
 327 00dc CF93      		push r28
 328 00de EF93      		push r30
 329 00e0 FF93      		push r31
 330               	/* prologue: Signal */
 331               	/* frame size = 0 */
 332               	/* stack size = 16 */
 333               	.L__stack_usage = 16
 135:main.c        **** 	if (its_off==1)//pulse is off
 335               	.LM39:
 336 00e2 8091 0000 		lds r24,its_off
 337 00e6 C091 0000 		lds r28,heat_power
 338 00ea 8130      		cpi r24,lo8(1)
 339 00ec 01F4      		brne .L8
 340               	.LBB10:
 137:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 342               	.LM40:
 343 00ee 959A      		sbi 50-32,5
 138:main.c        **** 		 its_off = 0;
 345               	.LM41:
 346 00f0 1092 0000 		sts its_off,__zero_reg__
 139:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 348               	.LM42:
 349 00f4 C095      		com r28
 350 00f6 00C0      		rjmp .L14
 351               	.L8:
 352               	.LBE10:
 353               	.LBB11:
 148:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 355               	.LM43:
 356 00f8 9598      		cbi 50-32,5
 149:main.c        **** 		 its_off = 1; 
 358               	.LM44:
 359 00fa 81E0      		ldi r24,lo8(1)
 360 00fc 8093 0000 		sts its_off,r24
 151:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 362               	.LM45:
 363 0100 C2BF      		out 82-32,r28
 364               	.L14:
 152:main.c        **** 		 if (newtimerval < 128)
 366               	.LM46:
 367 0102 C7FF      		sbrs r28,7
 154:main.c        **** 			do_things();
 369               	.LM47:
 370 0104 00D0      		rcall do_things
 371               	.L11:
 156:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 373               	.LM48:
 374 0106 C2BF      		out 82-32,r28
 375               	/* epilogue start */
 376               	.LBE11:
 159:main.c        **** }
 378               	.LM49:
 379 0108 FF91      		pop r31
 380 010a EF91      		pop r30
 381 010c CF91      		pop r28
 382 010e BF91      		pop r27
 383 0110 AF91      		pop r26
 384 0112 9F91      		pop r25
 385 0114 8F91      		pop r24
 386 0116 7F91      		pop r23
 387 0118 6F91      		pop r22
 388 011a 5F91      		pop r21
 389 011c 4F91      		pop r20
 390 011e 3F91      		pop r19
 391 0120 2F91      		pop r18
 392 0122 0F90      		pop r0
 393 0124 0FBE      		out __SREG__,r0
 394 0126 0F90      		pop r0
 395 0128 1F90      		pop __zero_reg__
 396 012a 1895      		reti
 401               	.Lscope3:
 403               	.global	four
 405               	four:
 248:main.c        **** 	}	
 249:main.c        **** }
 250:main.c        **** void four(void)//record aux adc 1, mux for pump current
 251:main.c        **** {
 407               	.LM50:
 408               	.LFBB4:
 409               	/* prologue: function */
 410               	/* frame size = 0 */
 411               	/* stack size = 0 */
 412               	.L__stack_usage = 0
 252:main.c        **** 	charspot = put_in_string(ADC_data,'\0',charspot);//puts data in big string 
 414               	.LM51:
 415 012c 4091 0000 		lds r20,charspot
 416 0130 8091 0000 		lds r24,ADC_data
 417 0134 9091 0000 		lds r25,ADC_data+1
 418 0138 60E0      		ldi r22,lo8(0)
 419 013a 00D0      		rcall put_in_string
 420 013c 8093 0000 		sts charspot,r24
 253:main.c        **** 	ADC_flag = 2;
 422               	.LM52:
 423 0140 82E0      		ldi r24,lo8(2)
 424 0142 8093 0000 		sts ADC_flag,r24
 254:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 426               	.LM53:
 427 0146 80EC      		ldi r24,lo8(-64)
 428 0148 87B9      		out 39-32,r24
 255:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 430               	.LM54:
 431 014a 369A      		sbi 38-32,6
 432               	/* epilogue start */
 256:main.c        **** }	
 434               	.LM55:
 435 014c 0895      		ret
 437               	.Lscope4:
 439               	.global	six_1
 441               	six_1:
 257:main.c        **** 
 258:main.c        **** void six_1(void)//measures pump current 1/3 sample
 259:main.c        **** {	
 443               	.LM56:
 444               	.LFBB5:
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 0 */
 448               	.L__stack_usage = 0
 260:main.c        **** 	pump = ADC_data;
 450               	.LM57:
 451 014e 8091 0000 		lds r24,ADC_data
 452 0152 9091 0000 		lds r25,ADC_data+1
 453 0156 9093 0000 		sts pump+1,r25
 454 015a 8093 0000 		sts pump,r24
 261:main.c        **** 	ADC_flag = 8;	
 456               	.LM58:
 457 015e 88E0      		ldi r24,lo8(8)
 458 0160 8093 0000 		sts ADC_flag,r24
 262:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 460               	.LM59:
 461 0164 369A      		sbi 38-32,6
 462               	/* epilogue start */
 263:main.c        **** }
 464               	.LM60:
 465 0166 0895      		ret
 467               	.Lscope5:
 469               	.global	six_2
 471               	six_2:
 264:main.c        **** 
 265:main.c        **** void six_2(void)//measures pump current 2/3
 266:main.c        **** {	
 473               	.LM61:
 474               	.LFBB6:
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 0 */
 478               	.L__stack_usage = 0
 267:main.c        **** 	pump = pump + ADC_data;
 480               	.LM62:
 481 0168 8091 0000 		lds r24,pump
 482 016c 9091 0000 		lds r25,pump+1
 483 0170 2091 0000 		lds r18,ADC_data
 484 0174 3091 0000 		lds r19,ADC_data+1
 485 0178 820F      		add r24,r18
 486 017a 931F      		adc r25,r19
 487 017c 9093 0000 		sts pump+1,r25
 488 0180 8093 0000 		sts pump,r24
 268:main.c        **** 	ADC_flag = 9;	
 490               	.LM63:
 491 0184 89E0      		ldi r24,lo8(9)
 492 0186 8093 0000 		sts ADC_flag,r24
 269:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 494               	.LM64:
 495 018a 369A      		sbi 38-32,6
 496               	/* epilogue start */
 270:main.c        **** }
 498               	.LM65:
 499 018c 0895      		ret
 501               	.Lscope6:
 503               	.global	six_3
 505               	six_3:
 271:main.c        **** 
 272:main.c        **** void six_3(void)//measures pump current 3/3
 273:main.c        **** {	
 507               	.LM66:
 508               	.LFBB7:
 509               	/* prologue: function */
 510               	/* frame size = 0 */
 511               	/* stack size = 0 */
 512               	.L__stack_usage = 0
 274:main.c        **** 	pump = pump + ADC_data;
 514               	.LM67:
 515 018e 8091 0000 		lds r24,ADC_data
 516 0192 9091 0000 		lds r25,ADC_data+1
 517 0196 2091 0000 		lds r18,pump
 518 019a 3091 0000 		lds r19,pump+1
 519 019e 820F      		add r24,r18
 520 01a0 931F      		adc r25,r19
 275:main.c        **** 	pump = pump/3;
 522               	.LM68:
 523 01a2 63E0      		ldi r22,lo8(3)
 524 01a4 70E0      		ldi r23,hi8(3)
 525 01a6 00D0      		rcall __udivmodhi4
 526 01a8 6093 0000 		sts pump,r22
 527 01ac 7093 0000 		sts pump+1,r23
 276:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 529               	.LM69:
 530 01b0 4091 0000 		lds r20,charspot
 531 01b4 CB01      		movw r24,r22
 532 01b6 60E0      		ldi r22,lo8(0)
 533 01b8 00D0      		rcall put_in_string
 534 01ba 8093 0000 		sts charspot,r24
 277:main.c        **** 	ADC_flag = 3;	
 536               	.LM70:
 537 01be 83E0      		ldi r24,lo8(3)
 538 01c0 8093 0000 		sts ADC_flag,r24
 278:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 540               	.LM71:
 541 01c4 82EC      		ldi r24,lo8(-62)
 542 01c6 87B9      		out 39-32,r24
 279:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 544               	.LM72:
 545 01c8 369A      		sbi 38-32,6
 546               	/* epilogue start */
 280:main.c        **** }
 548               	.LM73:
 549 01ca 0895      		ret
 551               	.Lscope7:
 553               	.global	seven
 555               	seven:
 281:main.c        **** 
 282:main.c        **** void seven(void)//measure nurnst 
 283:main.c        **** {
 557               	.LM74:
 558               	.LFBB8:
 559               	/* prologue: function */
 560               	/* frame size = 0 */
 561               	/* stack size = 0 */
 562               	.L__stack_usage = 0
 284:main.c        **** 	lambda = ADC_data;
 564               	.LM75:
 565 01cc 8091 0000 		lds r24,ADC_data
 566 01d0 9091 0000 		lds r25,ADC_data+1
 567 01d4 9093 0000 		sts lambda+1,r25
 568 01d8 8093 0000 		sts lambda,r24
 285:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 570               	.LM76:
 571 01dc 4091 0000 		lds r20,charspot
 572 01e0 60E0      		ldi r22,lo8(0)
 573 01e2 00D0      		rcall put_in_string
 574 01e4 8093 0000 		sts charspot,r24
 286:main.c        **** 	ADC_flag = 4;
 576               	.LM77:
 577 01e8 84E0      		ldi r24,lo8(4)
 578 01ea 8093 0000 		sts ADC_flag,r24
 287:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 580               	.LM78:
 581 01ee 82EC      		ldi r24,lo8(-62)
 582 01f0 87B9      		out 39-32,r24
 288:main.c        **** 	PORTB |= _BV(2);//DC on
 584               	.LM79:
 585 01f2 C29A      		sbi 56-32,2
 289:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 587               	.LM80:
 588 01f4 369A      		sbi 38-32,6
 589               	/* epilogue start */
 290:main.c        **** }
 591               	.LM81:
 592 01f6 0895      		ret
 594               	.Lscope8:
 596               	.global	readadc
 598               	readadc:
 291:main.c        **** 
 292:main.c        **** void eight(void)
 293:main.c        **** {
 294:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 295:main.c        **** 	DC_val = ADC_data;
 296:main.c        **** //	charspot = put_in_string(DC_val,'d',charspot);//puts data in big string
 297:main.c        **** 	ADC_flag = 0;	
 298:main.c        **** 	////do calculations and PIDs
 299:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 300:main.c        **** 	//done in PID_pump//charspot = put_in_string(measured_temperature,'f',charspot);
 301:main.c        **** 	measured_temperature = (DC_val - lambda);
 302:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 303:main.c        **** 		{
 304:main.c        **** 		measured_temperature = (255 - measured_temperature);
 305:main.c        **** 		}
 306:main.c        **** 	else
 307:main.c        **** 		{
 308:main.c        **** 		measured_temperature =0;
 309:main.c        **** 		}
 310:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 311:main.c        **** 		{
 312:main.c        **** 		PORTD &=~ _BV(4);//LED off
 313:main.c        **** 		}
 314:main.c        **** 	else
 315:main.c        **** 		{
 316:main.c        **** 		PORTD |= _BV(4);//LED on
 317:main.c        **** 		}
 318:main.c        **** 	//calculate 0-5v output from Look Up Table:
 319:main.c        **** 	struct two_col{
 320:main.c        **** 		uint16_t x;
 321:main.c        **** 		uint32_t y;
 322:main.c        **** 	}; 
 323:main.c        **** 	struct two_col out_volts[]={	//table columns: pump, zero_to_5_WB (pump current ADC value, DAC valu
 324:main.c        **** 		{0,0},
 325:main.c        **** 		{100, 10}, 
 326:main.c        **** 		{200, 20},
 327:main.c        **** 		{300, 30},
 328:main.c        **** 		{400, 40},
 329:main.c        **** 		{500, 50},
 330:main.c        **** 		{600, 70},
 331:main.c        **** 		{700, 110},
 332:main.c        **** 		{800, 140},
 333:main.c        **** 		{900, 180},
 334:main.c        **** 		{1000, 200},
 335:main.c        **** 		{1024, 255},
 336:main.c        **** 		};
 337:main.c        **** 	
 338:main.c        **** 	uint8_t n = 12;//number of rows in table
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 340:main.c        **** 	{
 341:main.c        **** 		if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 342:main.c        **** 		{
 343:main.c        **** 			uint16_t diffx = pump - out_volts[i].x; //difference between the pump value and the x value in t
 344:main.c        **** 			uint16_t diffn = out_volts[i+1].x - out_volts[i].x;//spacing between the values in the LOT
 345:main.c        **** 			zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output 
 346:main.c        **** 		}
 347:main.c        **** 	}
 348:main.c        **** 	//out of range check:
 349:main.c        **** 	if (pump<out_volts[0].x)//smaller than the lowest value in LOT
 350:main.c        **** 	{
 351:main.c        **** 		zero_to_5_WB = 0;
 352:main.c        **** 	}
 353:main.c        **** 	if (pump>out_volts[n-1].x)//larger than the highest value in the LOT
 354:main.c        **** 	{
 355:main.c        **** 		zero_to_5_WB = 254;
 356:main.c        **** 	}
 357:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 358:main.c        **** 	RtwoR_out(); //set six bit DAC outout for narrow
 359:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 360:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 361:main.c        **** 
 362:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 363:main.c        **** //	charspot = put_in_string(heat_power,'h',charspot);//puts data in big string
 364:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 365:main.c        **** }
 366:main.c        **** 	
 367:main.c        **** uint16_t readadc(void)
 368:main.c        **** {
 600               	.LM82:
 601               	.LFBB9:
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 0 */
 605               	.L__stack_usage = 0
 369:main.c        **** 	uint8_t adcDataL = ADCL;
 607               	.LM83:
 608 01f8 24B1      		in r18,36-32
 370:main.c        ****     uint8_t adcDataH = ADCH;
 610               	.LM84:
 611 01fa 35B1      		in r19,37-32
 371:main.c        ****     uint16_t adcData = 0;
 372:main.c        ****     adcData = adcData | adcDataH;
 373:main.c        ****     adcData = adcData << 8;//left shift 8 spots
 613               	.LM85:
 614 01fc 932F      		mov r25,r19
 615 01fe 80E0      		ldi r24,lo8(0)
 374:main.c        ****     adcData = adcData | adcDataL;
 617               	.LM86:
 618 0200 30E0      		ldi r19,lo8(0)
 619 0202 282B      		or r18,r24
 620 0204 392B      		or r19,r25
 375:main.c        ****     return adcData;
 376:main.c        **** }
 622               	.LM87:
 623 0206 C901      		movw r24,r18
 624               	/* epilogue start */
 625 0208 0895      		ret
 631               	.Lscope9:
 633               	.global	PID_heater
 635               	PID_heater:
 377:main.c        **** 
 378:main.c        **** void PID_heater(void)
 379:main.c        **** {
 637               	.LM88:
 638               	.LFBB10:
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 380:main.c        **** 	int32_t calculated = pid_Controller(TARGET_TEMP, measured_temperature, &pidData_temp);  // for tem
 644               	.LM89:
 645 020a 6091 0000 		lds r22,measured_temperature
 646 020e 7091 0000 		lds r23,measured_temperature+1
 647 0212 8DEE      		ldi r24,lo8(237)
 648 0214 90E0      		ldi r25,hi8(237)
 649 0216 40E0      		ldi r20,lo8(pidData_temp)
 650 0218 50E0      		ldi r21,hi8(pidData_temp)
 651 021a 00D0      		rcall pid_Controller
 652 021c AA27      		clr r26
 653 021e 97FD      		sbrc r25,7
 654 0220 A095      		com r26
 655 0222 BA2F      		mov r27,r26
 381:main.c        **** 
 382:main.c        **** 	if ((calculated) > 255 )
 657               	.LM90:
 658 0224 8F3F      		cpi r24,lo8(255)
 659 0226 9105      		cpc r25,__zero_reg__
 660 0228 A105      		cpc r26,__zero_reg__
 661 022a B105      		cpc r27,__zero_reg__
 662 022c 01F0      		breq .L22
 663 022e 04F0      		brlt .L22
 383:main.c        **** 	{
 384:main.c        **** 		heat_power = 255 ;
 665               	.LM91:
 666 0230 8FEF      		ldi r24,lo8(-1)
 667 0232 00C0      		rjmp .L24
 668               	.L22:
 385:main.c        **** 	}
 386:main.c        **** 	else if ((calculated) < 0 )
 670               	.LM92:
 671 0234 B7FF      		sbrs r27,7
 672 0236 00C0      		rjmp .L24
 387:main.c        **** 	{
 388:main.c        **** 		heat_power = 0 ;
 674               	.LM93:
 675 0238 1092 0000 		sts heat_power,__zero_reg__
 676 023c 0895      		ret
 677               	.L24:
 389:main.c        **** 	}
 390:main.c        **** 	else
 391:main.c        **** 	{
 392:main.c        **** 		heat_power =(calculated);
 679               	.LM94:
 680 023e 8093 0000 		sts heat_power,r24
 681 0242 0895      		ret
 686               	.Lscope10:
 688               	.global	PID_pump
 690               	PID_pump:
 393:main.c        **** 	}
 394:main.c        **** 
 395:main.c        **** }
 396:main.c        **** 
 397:main.c        **** void PID_pump(void)
 398:main.c        **** {
 692               	.LM95:
 693               	.LFBB11:
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 0 */
 697               	.L__stack_usage = 0
 399:main.c        **** int32_t calculated =  ( pid_Controller(TARGET_NERNST, lambda, &pidData_pump) );  // PID
 699               	.LM96:
 700 0244 6091 0000 		lds r22,lambda
 701 0248 7091 0000 		lds r23,lambda+1
 702 024c 84ED      		ldi r24,lo8(724)
 703 024e 92E0      		ldi r25,hi8(724)
 704 0250 40E0      		ldi r20,lo8(pidData_pump)
 705 0252 50E0      		ldi r21,hi8(pidData_pump)
 706 0254 00D0      		rcall pid_Controller
 707 0256 9C01      		movw r18,r24
 708 0258 B901      		movw r22,r18
 709 025a 8827      		clr r24
 710 025c 77FD      		sbrc r23,7
 711 025e 8095      		com r24
 712 0260 982F      		mov r25,r24
 400:main.c        **** calculated = (calculated/4) + 116;//116 is zero current.
 714               	.LM97:
 715 0262 24E0      		ldi r18,lo8(4)
 716 0264 30E0      		ldi r19,hi8(4)
 717 0266 40E0      		ldi r20,hlo8(4)
 718 0268 50E0      		ldi r21,hhi8(4)
 719 026a 00D0      		rcall __divmodsi4
 720 026c 2C58      		subi r18,lo8(-(116))
 721 026e 3F4F      		sbci r19,hi8(-(116))
 722 0270 4F4F      		sbci r20,hlo8(-(116))
 723 0272 5F4F      		sbci r21,hhi8(-(116))
 401:main.c        **** if ((calculated) > MAXPUMP_I)
 725               	.LM98:
 726 0274 253C      		cpi r18,lo8(197)
 727 0276 3105      		cpc r19,__zero_reg__
 728 0278 4105      		cpc r20,__zero_reg__
 729 027a 5105      		cpc r21,__zero_reg__
 730 027c 04F0      		brlt .L26
 402:main.c        **** 	{
 403:main.c        **** 		OCR1A = MAXPUMP_I;
 732               	.LM99:
 733 027e 84EC      		ldi r24,lo8(196)
 734 0280 90E0      		ldi r25,hi8(196)
 735 0282 00C0      		rjmp .L29
 736               	.L26:
 404:main.c        **** 	}
 405:main.c        **** else if ((calculated) < MINPUMP_I)
 738               	.LM100:
 739 0284 2233      		cpi r18,lo8(50)
 740 0286 3105      		cpc r19,__zero_reg__
 741 0288 4105      		cpc r20,__zero_reg__
 742 028a 5105      		cpc r21,__zero_reg__
 743 028c 04F4      		brge .L28
 406:main.c        **** 	{
 407:main.c        **** 		OCR1A = MINPUMP_I;
 745               	.LM101:
 746 028e 82E3      		ldi r24,lo8(50)
 747 0290 90E0      		ldi r25,hi8(50)
 748               	.L29:
 749 0292 9BBD      		out 74+1-32,r25
 750 0294 8ABD      		out 74-32,r24
 751 0296 00C0      		rjmp .L27
 752               	.L28:
 408:main.c        **** 	}
 409:main.c        **** 	else
 410:main.c        **** 	{
 411:main.c        **** 		OCR1A =(calculated);
 754               	.LM102:
 755 0298 3BBD      		out 74+1-32,r19
 756 029a 2ABD      		out 74-32,r18
 757               	.L27:
 412:main.c        **** 	}
 413:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string	
 759               	.LM103:
 760 029c 8AB5      		in r24,74-32
 761 029e 9BB5      		in r25,74+1-32
 762 02a0 4091 0000 		lds r20,charspot
 763 02a4 60E0      		ldi r22,lo8(0)
 764 02a6 00D0      		rcall put_in_string
 765 02a8 8093 0000 		sts charspot,r24
 766               	/* epilogue start */
 414:main.c        **** 
 415:main.c        **** }
 768               	.LM104:
 769 02ac 0895      		ret
 771               	.Lscope11:
 773               	.global	RtwoR_out
 775               	RtwoR_out:
 416:main.c        **** 
 417:main.c        **** void RtwoR_out(void)
 418:main.c        **** {
 777               	.LM105:
 778               	.LFBB12:
 779 02ae DF93      		push r29
 780 02b0 CF93      		push r28
 781 02b2 0F92      		push __tmp_reg__
 782 02b4 CDB7      		in r28,__SP_L__
 783 02b6 DEB7      		in r29,__SP_H__
 784               	/* prologue: function */
 785               	/* frame size = 1 */
 786               	/* stack size = 3 */
 787               	.L__stack_usage = 3
 419:main.c        **** 	uint8_t pin_assign;//value to be applied to 6bit dac R2R ladder
 420:main.c        **** 	if (zero_to_5_WB >= LOWER_NB && zero_to_5_WB <= LOWER_NB+64)//check if in range for NB
 789               	.LM106:
 790 02b8 8091 0000 		lds r24,zero_to_5_WB
 791 02bc 9091 0000 		lds r25,zero_to_5_WB+1
 792 02c0 A091 0000 		lds r26,zero_to_5_WB+2
 793 02c4 B091 0000 		lds r27,zero_to_5_WB+3
 794 02c8 9C01      		movw r18,r24
 795 02ca AD01      		movw r20,r26
 796 02cc 2F55      		subi r18,lo8(-(-95))
 797 02ce 3040      		sbci r19,hi8(-(-95))
 798 02d0 4040      		sbci r20,hlo8(-(-95))
 799 02d2 5040      		sbci r21,hhi8(-(-95))
 800 02d4 2134      		cpi r18,lo8(65)
 801 02d6 3105      		cpc r19,__zero_reg__
 802 02d8 4105      		cpc r20,__zero_reg__
 803 02da 5105      		cpc r21,__zero_reg__
 804 02dc 00F4      		brsh .L31
 805               	.LBB12:
 421:main.c        **** 	{
 422:main.c        **** 		uint8_t i= zero_to_5_WB - LOWER_NB;// set i to offset of zero_to_5_WB
 807               	.LM107:
 808 02de 8F55      		subi r24,lo8(-(-95))
 809               	.LBB13:
 423:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[i]);//get value out of lookup table		
 811               	.LM108:
 812 02e0 E82F      		mov r30,r24
 813 02e2 F0E0      		ldi r31,lo8(0)
 814 02e4 E050      		subi r30,lo8(-(Narro_curve))
 815 02e6 F040      		sbci r31,hi8(-(Narro_curve))
 816               	/* #APP */
 817               	 ;  423 "main.c" 1
 818 02e8 E491      		lpm r30, Z
 819               		
 820               	 ;  0 "" 2
 821               	/* #NOAPP */
 822 02ea 00C0      		rjmp .L46
 823               	.L31:
 824               	.LBE13:
 825               	.LBE12:
 424:main.c        **** 	}
 425:main.c        **** 	else if (zero_to_5_WB < LOWER_NB)
 827               	.LM109:
 828 02ec 8F35      		cpi r24,lo8(95)
 829 02ee 9105      		cpc r25,__zero_reg__
 830 02f0 A105      		cpc r26,__zero_reg__
 831 02f2 B105      		cpc r27,__zero_reg__
 832 02f4 00F4      		brsh .L33
 833               	.LBB14:
 426:main.c        **** 	{
 427:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[0]);//set six bit to minimum in table
 835               	.LM110:
 836 02f6 E0E0      		ldi r30,lo8(Narro_curve)
 837 02f8 F0E0      		ldi r31,hi8(Narro_curve)
 838               	/* #APP */
 839               	 ;  427 "main.c" 1
 840 02fa E491      		lpm r30, Z
 841               		
 842               	 ;  0 "" 2
 843               	/* #NOAPP */
 844 02fc 00C0      		rjmp .L46
 845               	.L33:
 846               	.LBE14:
 847               	.LBB15:
 428:main.c        **** 	}
 429:main.c        **** 	else 
 430:main.c        **** 	{
 431:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[63]);//set six bit to max in table
 849               	.LM111:
 850 02fe E0E0      		ldi r30,lo8(Narro_curve+63)
 851 0300 F0E0      		ldi r31,hi8(Narro_curve+63)
 852               	/* #APP */
 853               	 ;  431 "main.c" 1
 854 0302 E491      		lpm r30, Z
 855               		
 856               	 ;  0 "" 2
 857               	/* #NOAPP */
 858               	.L46:
 859               	.LBE15:
 860 0304 E983      		std Y+1,r30
 432:main.c        **** 	}
 433:main.c        **** 	//check each bit 0 to 5 of pin_assign and apply to actual pins of R2R ladder:			
 434:main.c        **** 	if bit_is_set(pin_assign,0)
 862               	.LM112:
 863 0306 FE01      		movw r30,r28
 864 0308 3196      		adiw r30,1
 865 030a 8981      		ldd r24,Y+1
 866 030c 80FF      		sbrs r24,0
 867 030e 00C0      		rjmp .L34
 435:main.c        **** 	{PORTC |= _BV(5);}
 869               	.LM113:
 870 0310 AD9A      		sbi 53-32,5
 871 0312 00C0      		rjmp .L35
 872               	.L34:
 436:main.c        **** 	else {PORTC &=~ _BV(5);}
 874               	.LM114:
 875 0314 AD98      		cbi 53-32,5
 876               	.L35:
 437:main.c        **** 	if bit_is_set(pin_assign,1)
 878               	.LM115:
 879 0316 8081      		ld r24,Z
 880 0318 81FF      		sbrs r24,1
 881 031a 00C0      		rjmp .L36
 438:main.c        **** 	{PORTC |= _BV(4);}
 883               	.LM116:
 884 031c AC9A      		sbi 53-32,4
 885 031e 00C0      		rjmp .L37
 886               	.L36:
 439:main.c        **** 	else {PORTC &=~ _BV(4);}
 888               	.LM117:
 889 0320 AC98      		cbi 53-32,4
 890               	.L37:
 440:main.c        **** 	if bit_is_set(pin_assign,2)
 892               	.LM118:
 893 0322 8081      		ld r24,Z
 894 0324 82FF      		sbrs r24,2
 895 0326 00C0      		rjmp .L38
 441:main.c        **** 	{PORTC |= _BV(3);}
 897               	.LM119:
 898 0328 AB9A      		sbi 53-32,3
 899 032a 00C0      		rjmp .L39
 900               	.L38:
 442:main.c        **** 	else {PORTC &=~ _BV(3);}
 902               	.LM120:
 903 032c AB98      		cbi 53-32,3
 904               	.L39:
 443:main.c        **** 	if bit_is_set(pin_assign,3)
 906               	.LM121:
 907 032e 8081      		ld r24,Z
 908 0330 83FF      		sbrs r24,3
 909 0332 00C0      		rjmp .L40
 444:main.c        **** 	{PORTB |= _BV(5);}
 911               	.LM122:
 912 0334 C59A      		sbi 56-32,5
 913 0336 00C0      		rjmp .L41
 914               	.L40:
 445:main.c        **** 	else {PORTB &=~ _BV(5);}
 916               	.LM123:
 917 0338 C598      		cbi 56-32,5
 918               	.L41:
 446:main.c        **** 	if bit_is_set(pin_assign,4)
 920               	.LM124:
 921 033a 8081      		ld r24,Z
 922 033c 84FF      		sbrs r24,4
 923 033e 00C0      		rjmp .L42
 447:main.c        **** 	{PORTB |= _BV(4);}
 925               	.LM125:
 926 0340 C49A      		sbi 56-32,4
 927 0342 00C0      		rjmp .L43
 928               	.L42:
 448:main.c        **** 	else {PORTB &=~ _BV(4);}
 930               	.LM126:
 931 0344 C498      		cbi 56-32,4
 932               	.L43:
 449:main.c        **** 	if bit_is_set(pin_assign,5)
 934               	.LM127:
 935 0346 8081      		ld r24,Z
 936 0348 85FF      		sbrs r24,5
 937 034a 00C0      		rjmp .L44
 450:main.c        **** 	{PORTB |= _BV(0);}
 939               	.LM128:
 940 034c C09A      		sbi 56-32,0
 941 034e 00C0      		rjmp .L30
 942               	.L44:
 451:main.c        **** 	else {PORTB &=~ _BV(0);}
 944               	.LM129:
 945 0350 C098      		cbi 56-32,0
 946               	.L30:
 947               	/* epilogue start */
 452:main.c        **** }
 949               	.LM130:
 950 0352 0F90      		pop __tmp_reg__
 951 0354 CF91      		pop r28
 952 0356 DF91      		pop r29
 953 0358 0895      		ret
 958               	.Lscope12:
 960               	.global	eight
 962               	eight:
 293:main.c        **** {
 964               	.LM131:
 965               	.LFBB13:
 966 035a 4F92      		push r4
 967 035c 5F92      		push r5
 968 035e 6F92      		push r6
 969 0360 7F92      		push r7
 970 0362 8F92      		push r8
 971 0364 9F92      		push r9
 972 0366 AF92      		push r10
 973 0368 BF92      		push r11
 974 036a CF92      		push r12
 975 036c DF92      		push r13
 976 036e EF92      		push r14
 977 0370 FF92      		push r15
 978 0372 1F93      		push r17
 979 0374 DF93      		push r29
 980 0376 CF93      		push r28
 981 0378 CDB7      		in r28,__SP_L__
 982 037a DEB7      		in r29,__SP_H__
 983 037c C854      		subi r28,lo8(-(-72))
 984 037e D040      		sbci r29,hi8(-(-72))
 985 0380 0FB6      		in __tmp_reg__,__SREG__
 986 0382 F894      		cli
 987 0384 DEBF      		out __SP_H__,r29
 988 0386 0FBE      		out __SREG__,__tmp_reg__
 989 0388 CDBF      		out __SP_L__,r28
 990               	/* prologue: function */
 991               	/* frame size = 72 */
 992               	/* stack size = 87 */
 993               	.L__stack_usage = 87
 294:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 995               	.LM132:
 996 038a C298      		cbi 56-32,2
 295:main.c        **** 	DC_val = ADC_data;
 998               	.LM133:
 999 038c 8091 0000 		lds r24,ADC_data
 1000 0390 9091 0000 		lds r25,ADC_data+1
 1001 0394 9093 0000 		sts DC_val+1,r25
 1002 0398 8093 0000 		sts DC_val,r24
 297:main.c        **** 	ADC_flag = 0;	
 1004               	.LM134:
 1005 039c 1092 0000 		sts ADC_flag,__zero_reg__
 299:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 1007               	.LM135:
 1008 03a0 00D0      		rcall PID_pump
 301:main.c        **** 	measured_temperature = (DC_val - lambda);
 1010               	.LM136:
 1011 03a2 8091 0000 		lds r24,DC_val
 1012 03a6 9091 0000 		lds r25,DC_val+1
 1013 03aa 2091 0000 		lds r18,lambda
 1014 03ae 3091 0000 		lds r19,lambda+1
 1015 03b2 821B      		sub r24,r18
 1016 03b4 930B      		sbc r25,r19
 302:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 1018               	.LM137:
 1019 03b6 8F3F      		cpi r24,255
 1020 03b8 9105      		cpc r25,__zero_reg__
 1021 03ba 01F0      		breq .+2
 1022 03bc 00F4      		brsh .L48
 304:main.c        **** 		measured_temperature = (255 - measured_temperature);
 1024               	.LM138:
 1025 03be 2FEF      		ldi r18,lo8(255)
 1026 03c0 30E0      		ldi r19,hi8(255)
 1027 03c2 281B      		sub r18,r24
 1028 03c4 390B      		sbc r19,r25
 1029 03c6 3093 0000 		sts measured_temperature+1,r19
 1030 03ca 2093 0000 		sts measured_temperature,r18
 1031 03ce 00C0      		rjmp .L49
 1032               	.L48:
 308:main.c        **** 		measured_temperature =0;
 1034               	.LM139:
 1035 03d0 1092 0000 		sts measured_temperature+1,__zero_reg__
 1036 03d4 1092 0000 		sts measured_temperature,__zero_reg__
 1037               	.L49:
 310:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 1039               	.LM140:
 1040 03d8 8091 0000 		lds r24,measured_temperature
 1041 03dc 9091 0000 		lds r25,measured_temperature+1
 1042 03e0 895E      		subi r24,lo8(-(-233))
 1043 03e2 9040      		sbci r25,hi8(-(-233))
 1044 03e4 8930      		cpi r24,9
 1045 03e6 9105      		cpc r25,__zero_reg__
 1046 03e8 00F4      		brsh .L50
 312:main.c        **** 		PORTD &=~ _BV(4);//LED off
 1048               	.LM141:
 1049 03ea 9498      		cbi 50-32,4
 1050 03ec 00C0      		rjmp .L51
 1051               	.L50:
 316:main.c        **** 		PORTD |= _BV(4);//LED on
 1053               	.LM142:
 1054 03ee 949A      		sbi 50-32,4
 1055               	.L51:
 323:main.c        **** 	struct two_col out_volts[]={	//table columns: pump, zero_to_5_WB (pump current ADC value, DAC valu
 1057               	.LM143:
 1058 03f0 DE01      		movw r26,r28
 1059 03f2 1196      		adiw r26,1
 1060 03f4 E0E0      		ldi r30,lo8(C.18.2970)
 1061 03f6 F0E0      		ldi r31,hi8(C.18.2970)
 1062 03f8 88E4      		ldi r24,lo8(72)
 1063               	.L52:
 1064 03fa 0190      		ld r0,Z+
 1065 03fc 0D92      		st X+,r0
 1066 03fe 8150      		subi r24,lo8(-(-1))
 1067 0400 01F4      		brne .L52
 1068               	.LBB16:
 341:main.c        **** 		if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1070               	.LM144:
 1071 0402 C090 0000 		lds r12,pump
 1072 0406 D090 0000 		lds r13,pump+1
 1073 040a 2091 0000 		lds r18,zero_to_5_WB
 1074 040e 3091 0000 		lds r19,zero_to_5_WB+1
 1075 0412 4091 0000 		lds r20,zero_to_5_WB+2
 1076 0416 5091 0000 		lds r21,zero_to_5_WB+3
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1078               	.LM145:
 1079 041a 10E0      		ldi r17,lo8(0)
 341:main.c        **** 		if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1081               	.LM146:
 1082 041c 2E01      		movw r4,r28
 1083 041e 0894      		sec
 1084 0420 411C      		adc r4,__zero_reg__
 1085 0422 511C      		adc r5,__zero_reg__
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1087               	.LM147:
 1088 0424 00C0      		rjmp .L53
 1089               	.L55:
 341:main.c        **** 		if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1091               	.LM148:
 1092 0426 DC01      		movw r26,r24
 1093 0428 AA0F      		lsl r26
 1094 042a BB1F      		rol r27
 1095 042c A80F      		add r26,r24
 1096 042e B91F      		adc r27,r25
 1097 0430 AA0F      		lsl r26
 1098 0432 BB1F      		rol r27
 1099 0434 A40D      		add r26,r4
 1100 0436 B51D      		adc r27,r5
 1101 0438 ED90      		ld r14,X+
 1102 043a FC90      		ld r15,X
 1103 043c 1197      		sbiw r26,1
 1104 043e CE14      		cp r12,r14
 1105 0440 DF04      		cpc r13,r15
 1106 0442 00F0      		brlo .L54
 341:main.c        **** 		if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1108               	.LM149:
 1109 0444 0196      		adiw r24,1
 1110 0446 FC01      		movw r30,r24
 1111 0448 EE0F      		lsl r30
 1112 044a FF1F      		rol r31
 1113 044c E80F      		add r30,r24
 1114 044e F91F      		adc r31,r25
 1115 0450 EE0F      		lsl r30
 1116 0452 FF1F      		rol r31
 1117 0454 E40D      		add r30,r4
 1118 0456 F51D      		adc r31,r5
 1119 0458 A080      		ld r10,Z
 1120 045a B180      		ldd r11,Z+1
 1121 045c AC14      		cp r10,r12
 1122 045e BD04      		cpc r11,r13
 1123 0460 00F0      		brlo .L54
 1124               	.LBB17:
 345:main.c        **** 			zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output 
 1126               	.LM150:
 1127 0462 1296      		adiw r26,2
 1128 0464 6D90      		ld r6,X+
 1129 0466 7D90      		ld r7,X+
 1130 0468 8D90      		ld r8,X+
 1131 046a 9C90      		ld r9,X
 1132 046c 1597      		sbiw r26,2+3
 343:main.c        **** 			uint16_t diffx = pump - out_volts[i].x; //difference between the pump value and the x value in t
 1134               	.LM151:
 1135 046e B601      		movw r22,r12
 1136 0470 6E19      		sub r22,r14
 1137 0472 7F09      		sbc r23,r15
 345:main.c        **** 			zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output 
 1139               	.LM152:
 1140 0474 80E0      		ldi r24,lo8(0)
 1141 0476 90E0      		ldi r25,hi8(0)
 1142 0478 2281      		ldd r18,Z+2
 1143 047a 3381      		ldd r19,Z+3
 1144 047c 4481      		ldd r20,Z+4
 1145 047e 5581      		ldd r21,Z+5
 1146 0480 2619      		sub r18,r6
 1147 0482 3709      		sbc r19,r7
 1148 0484 4809      		sbc r20,r8
 1149 0486 5909      		sbc r21,r9
 1150 0488 00D0      		rcall __mulsi3
 344:main.c        **** 			uint16_t diffn = out_volts[i+1].x - out_volts[i].x;//spacing between the values in the LOT
 1152               	.LM153:
 1153 048a AE18      		sub r10,r14
 1154 048c BF08      		sbc r11,r15
 345:main.c        **** 			zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output 
 1156               	.LM154:
 1157 048e 9501      		movw r18,r10
 1158 0490 40E0      		ldi r20,lo8(0)
 1159 0492 50E0      		ldi r21,hi8(0)
 1160 0494 00D0      		rcall __udivmodsi4
 1161 0496 260D      		add r18,r6
 1162 0498 371D      		adc r19,r7
 1163 049a 481D      		adc r20,r8
 1164 049c 591D      		adc r21,r9
 1165               	.L54:
 1166               	.LBE17:
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1168               	.LM155:
 1169 049e 1F5F      		subi r17,lo8(-(1))
 1170               	.L53:
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1172               	.LM156:
 1173 04a0 812F      		mov r24,r17
 1174 04a2 90E0      		ldi r25,lo8(0)
 1175 04a4 1B30      		cpi r17,lo8(11)
 1176 04a6 01F0      		breq .+2
 1177 04a8 00C0      		rjmp .L55
 339:main.c        **** 	for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1179               	.LM157:
 1180 04aa 2093 0000 		sts zero_to_5_WB,r18
 1181 04ae 3093 0000 		sts zero_to_5_WB+1,r19
 1182 04b2 4093 0000 		sts zero_to_5_WB+2,r20
 1183 04b6 5093 0000 		sts zero_to_5_WB+3,r21
 1184               	.LBE16:
 349:main.c        **** 	if (pump<out_volts[0].x)//smaller than the lowest value in LOT
 1186               	.LM158:
 1187 04ba 8091 0000 		lds r24,pump
 1188 04be 9091 0000 		lds r25,pump+1
 1189 04c2 2981      		ldd r18,Y+1
 1190 04c4 3A81      		ldd r19,Y+2
 1191 04c6 8217      		cp r24,r18
 1192 04c8 9307      		cpc r25,r19
 1193 04ca 00F4      		brsh .L56
 351:main.c        **** 		zero_to_5_WB = 0;
 1195               	.LM159:
 1196 04cc 1092 0000 		sts zero_to_5_WB,__zero_reg__
 1197 04d0 1092 0000 		sts zero_to_5_WB+1,__zero_reg__
 1198 04d4 1092 0000 		sts zero_to_5_WB+2,__zero_reg__
 1199 04d8 1092 0000 		sts zero_to_5_WB+3,__zero_reg__
 1200               	.L56:
 353:main.c        **** 	if (pump>out_volts[n-1].x)//larger than the highest value in the LOT
 1202               	.LM160:
 1203 04dc FE01      		movw r30,r28
 1204 04de ED5B      		subi r30,lo8(-(67))
 1205 04e0 FF4F      		sbci r31,hi8(-(67))
 1206 04e2 2081      		ld r18,Z
 1207 04e4 3181      		ldd r19,Z+1
 1208 04e6 2817      		cp r18,r24
 1209 04e8 3907      		cpc r19,r25
 1210 04ea 00F4      		brsh .L57
 355:main.c        **** 		zero_to_5_WB = 254;
 1212               	.LM161:
 1213 04ec 8EEF      		ldi r24,lo8(254)
 1214 04ee 90E0      		ldi r25,hi8(254)
 1215 04f0 A0E0      		ldi r26,hlo8(254)
 1216 04f2 B0E0      		ldi r27,hhi8(254)
 1217 04f4 8093 0000 		sts zero_to_5_WB,r24
 1218 04f8 9093 0000 		sts zero_to_5_WB+1,r25
 1219 04fc A093 0000 		sts zero_to_5_WB+2,r26
 1220 0500 B093 0000 		sts zero_to_5_WB+3,r27
 1221               	.L57:
 357:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 1223               	.LM162:
 1224 0504 8091 0000 		lds r24,zero_to_5_WB
 1225 0508 83BD      		out 67-32,r24
 358:main.c        **** 	RtwoR_out(); //set six bit DAC outout for narrow
 1227               	.LM163:
 1228 050a 00D0      		rcall RtwoR_out
 359:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 1230               	.LM164:
 1231 050c 4091 0000 		lds r20,charspot
 1232 0510 8091 0000 		lds r24,zero_to_5_WB
 1233 0514 9091 0000 		lds r25,zero_to_5_WB+1
 1234 0518 60E0      		ldi r22,lo8(0)
 1235 051a 00D0      		rcall put_in_string
 1236 051c 8093 0000 		sts charspot,r24
 360:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 1238               	.LM165:
 1239 0520 4091 0000 		lds r20,charspot
 1240 0524 8091 0000 		lds r24,measured_temperature
 1241 0528 9091 0000 		lds r25,measured_temperature+1
 1242 052c 60E0      		ldi r22,lo8(0)
 1243 052e 00D0      		rcall put_in_string
 1244 0530 8093 0000 		sts charspot,r24
 362:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 1246               	.LM166:
 1247 0534 00D0      		rcall PID_heater
 364:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 1249               	.LM167:
 1250 0536 8091 0000 		lds r24,charspot
 1251 053a 00D0      		rcall spitout
 1252 053c 8093 0000 		sts charspot,r24
 1253               	/* epilogue start */
 365:main.c        **** }
 1255               	.LM168:
 1256 0540 C85B      		subi r28,lo8(-(72))
 1257 0542 DF4F      		sbci r29,hi8(-(72))
 1258 0544 0FB6      		in __tmp_reg__,__SREG__
 1259 0546 F894      		cli
 1260 0548 DEBF      		out __SP_H__,r29
 1261 054a 0FBE      		out __SREG__,__tmp_reg__
 1262 054c CDBF      		out __SP_L__,r28
 1263 054e CF91      		pop r28
 1264 0550 DF91      		pop r29
 1265 0552 1F91      		pop r17
 1266 0554 FF90      		pop r15
 1267 0556 EF90      		pop r14
 1268 0558 DF90      		pop r13
 1269 055a CF90      		pop r12
 1270 055c BF90      		pop r11
 1271 055e AF90      		pop r10
 1272 0560 9F90      		pop r9
 1273 0562 8F90      		pop r8
 1274 0564 7F90      		pop r7
 1275 0566 6F90      		pop r6
 1276 0568 5F90      		pop r5
 1277 056a 4F90      		pop r4
 1278 056c 0895      		ret
 1286               	.Lscope13:
 1288               	.global	__vector_14
 1290               	__vector_14:
  99:main.c        **** {
 1292               	.LM169:
 1293               	.LFBB14:
 1294 056e 1F92      		push __zero_reg__
 1295 0570 0F92      		push r0
 1296 0572 0FB6      		in r0,__SREG__
 1297 0574 0F92      		push r0
 1298 0576 1124      		clr __zero_reg__
 1299 0578 2F93      		push r18
 1300 057a 3F93      		push r19
 1301 057c 4F93      		push r20
 1302 057e 5F93      		push r21
 1303 0580 6F93      		push r22
 1304 0582 7F93      		push r23
 1305 0584 8F93      		push r24
 1306 0586 9F93      		push r25
 1307 0588 AF93      		push r26
 1308 058a BF93      		push r27
 1309 058c EF93      		push r30
 1310 058e FF93      		push r31
 1311               	/* prologue: Signal */
 1312               	/* frame size = 0 */
 1313               	/* stack size = 15 */
 1314               	.L__stack_usage = 15
 100:main.c        **** ADC_data = readadc();
 1316               	.LM170:
 1317 0590 00D0      		rcall readadc
 1318 0592 9093 0000 		sts ADC_data+1,r25
 1319 0596 8093 0000 		sts ADC_data,r24
 102:main.c        **** if (ADC_flag == 7)//
 1321               	.LM171:
 1322 059a 8091 0000 		lds r24,ADC_flag
 1323 059e 8730      		cpi r24,lo8(7)
 1324 05a0 01F4      		brne .L60
 104:main.c        **** 	four();
 1326               	.LM172:
 1327 05a2 00D0      		rcall four
 1328 05a4 00C0      		rjmp .L59
 1329               	.L60:
 106:main.c        **** else if (ADC_flag == 2)
 1331               	.LM173:
 1332 05a6 8091 0000 		lds r24,ADC_flag
 1333 05aa 8230      		cpi r24,lo8(2)
 1334 05ac 01F4      		brne .L62
 108:main.c        **** 	six_1();
 1336               	.LM174:
 1337 05ae 00D0      		rcall six_1
 1338 05b0 00C0      		rjmp .L59
 1339               	.L62:
 110:main.c        **** else if (ADC_flag == 8)
 1341               	.LM175:
 1342 05b2 8091 0000 		lds r24,ADC_flag
 1343 05b6 8830      		cpi r24,lo8(8)
 1344 05b8 01F4      		brne .L63
 112:main.c        **** 	six_2();
 1346               	.LM176:
 1347 05ba 00D0      		rcall six_2
 1348 05bc 00C0      		rjmp .L59
 1349               	.L63:
 114:main.c        **** else if (ADC_flag == 9)
 1351               	.LM177:
 1352 05be 8091 0000 		lds r24,ADC_flag
 1353 05c2 8930      		cpi r24,lo8(9)
 1354 05c4 01F4      		brne .L64
 116:main.c        **** 	six_3();
 1356               	.LM178:
 1357 05c6 00D0      		rcall six_3
 1358 05c8 00C0      		rjmp .L59
 1359               	.L64:
 119:main.c        **** else if (ADC_flag == 3)//lambda
 1361               	.LM179:
 1362 05ca 8091 0000 		lds r24,ADC_flag
 1363 05ce 8330      		cpi r24,lo8(3)
 1364 05d0 01F4      		brne .L65
 121:main.c        **** 	seven();
 1366               	.LM180:
 1367 05d2 00D0      		rcall seven
 1368 05d4 00C0      		rjmp .L59
 1369               	.L65:
 123:main.c        **** else if (ADC_flag == 4)//lambda+DC and calculations
 1371               	.LM181:
 1372 05d6 8091 0000 		lds r24,ADC_flag
 1373 05da 8430      		cpi r24,lo8(4)
 1374 05dc 01F4      		brne .L66
 125:main.c        **** 	eight();
 1376               	.LM182:
 1377 05de 00D0      		rcall eight
 1378 05e0 00C0      		rjmp .L59
 1379               	.L66:
 130:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 1381               	.LM183:
 1382 05e2 00D0      		rcall readadc
 1383 05e4 9093 0000 		sts ADC_data+1,r25
 1384 05e8 8093 0000 		sts ADC_data,r24
 1385               	.L59:
 1386               	/* epilogue start */
 132:main.c        **** }
 1388               	.LM184:
 1389 05ec FF91      		pop r31
 1390 05ee EF91      		pop r30
 1391 05f0 BF91      		pop r27
 1392 05f2 AF91      		pop r26
 1393 05f4 9F91      		pop r25
 1394 05f6 8F91      		pop r24
 1395 05f8 7F91      		pop r23
 1396 05fa 6F91      		pop r22
 1397 05fc 5F91      		pop r21
 1398 05fe 4F91      		pop r20
 1399 0600 3F91      		pop r19
 1400 0602 2F91      		pop r18
 1401 0604 0F90      		pop r0
 1402 0606 0FBE      		out __SREG__,r0
 1403 0608 0F90      		pop r0
 1404 060a 1F90      		pop __zero_reg__
 1405 060c 1895      		reti
 1407               	.Lscope14:
 1408               	.global	lambda
 1409               	.global	lambda
 1410               		.section .bss
 1413               	lambda:
 1414 0000 0000      		.skip 2,0
 1415               	.global	pump
 1416               	.global	pump
 1419               	pump:
 1420 0002 0000      		.skip 2,0
 1421               	.global	DC_val
 1422               	.global	DC_val
 1425               	DC_val:
 1426 0004 0000      		.skip 2,0
 1427               	.global	IpumpVolts
 1428               	.global	IpumpVolts
 1431               	IpumpVolts:
 1432 0006 0000      		.skip 2,0
 1433               	.global	ramp_flag
 1434               	.global	ramp_flag
 1437               	ramp_flag:
 1438 0008 00        		.skip 1,0
 1439               	.global	charspot
 1440               	.global	charspot
 1443               	charspot:
 1444 0009 00        		.skip 1,0
 1445               	.global	rampcounter
 1446               	.global	rampcounter
 1449               	rampcounter:
 1450 000a 00        		.skip 1,0
 1451               	.global	Narro_curve
 1452               		.section	.progmem.data,"a",@progbits
 1455               	Narro_curve:
 1456 0000 0B        		.byte	11
 1457 0001 0B        		.byte	11
 1458 0002 0B        		.byte	11
 1459 0003 0B        		.byte	11
 1460 0004 0B        		.byte	11
 1461 0005 0B        		.byte	11
 1462 0006 0B        		.byte	11
 1463 0007 0B        		.byte	11
 1464 0008 0B        		.byte	11
 1465 0009 0B        		.byte	11
 1466 000a 0B        		.byte	11
 1467 000b 0B        		.byte	11
 1468 000c 0B        		.byte	11
 1469 000d 0B        		.byte	11
 1470 000e 0B        		.byte	11
 1471 000f 0B        		.byte	11
 1472 0010 0B        		.byte	11
 1473 0011 0B        		.byte	11
 1474 0012 0A        		.byte	10
 1475 0013 0A        		.byte	10
 1476 0014 0A        		.byte	10
 1477 0015 0A        		.byte	10
 1478 0016 0A        		.byte	10
 1479 0017 0A        		.byte	10
 1480 0018 09        		.byte	9
 1481 0019 09        		.byte	9
 1482 001a 09        		.byte	9
 1483 001b 08        		.byte	8
 1484 001c 08        		.byte	8
 1485 001d 08        		.byte	8
 1486 001e 07        		.byte	7
 1487 001f 07        		.byte	7
 1488 0020 05        		.byte	5
 1489 0021 05        		.byte	5
 1490 0022 04        		.byte	4
 1491 0023 04        		.byte	4
 1492 0024 04        		.byte	4
 1493 0025 03        		.byte	3
 1494 0026 03        		.byte	3
 1495 0027 03        		.byte	3
 1496 0028 02        		.byte	2
 1497 0029 02        		.byte	2
 1498 002a 02        		.byte	2
 1499 002b 02        		.byte	2
 1500 002c 02        		.byte	2
 1501 002d 02        		.byte	2
 1502 002e 01        		.byte	1
 1503 002f 01        		.byte	1
 1504 0030 01        		.byte	1
 1505 0031 01        		.byte	1
 1506 0032 01        		.byte	1
 1507 0033 01        		.byte	1
 1508 0034 01        		.byte	1
 1509 0035 01        		.byte	1
 1510 0036 01        		.byte	1
 1511 0037 01        		.byte	1
 1512 0038 01        		.byte	1
 1513 0039 01        		.byte	1
 1514 003a 01        		.byte	1
 1515 003b 01        		.byte	1
 1516 003c 01        		.byte	1
 1517 003d 01        		.byte	1
 1518 003e 01        		.byte	1
 1519 003f 01        		.byte	1
 1520               		.comm serialout,50,1
 1521               		.comm heat_power,1,1
 1522               		.comm ADC_data,2,1
 1523               		.comm measured_temperature,2,1
 1524               		.comm zero_to_5_WB,4,1
 1525               		.comm its_off,1,1
 1526               		.comm ADC_flag,1,1
 1527               		.comm pidCounter,1,1
 1528               		.comm pidData_temp,18,1
 1529               		.comm pidData_pump,18,1
 1530               		.data
 1533               	C.18.2970:
 1534 000b 0000      		.word	0
 1535 000d 00        		.byte	0
 1536 000e 00        		.byte	0
 1537 000f 00        		.byte	0
 1538 0010 00        		.byte	0
 1539 0011 6400      		.word	100
 1540 0013 0A        		.byte	10
 1541 0014 00        		.byte	0
 1542 0015 00        		.byte	0
 1543 0016 00        		.byte	0
 1544 0017 C800      		.word	200
 1545 0019 14        		.byte	20
 1546 001a 00        		.byte	0
 1547 001b 00        		.byte	0
 1548 001c 00        		.byte	0
 1549 001d 2C01      		.word	300
 1550 001f 1E        		.byte	30
 1551 0020 00        		.byte	0
 1552 0021 00        		.byte	0
 1553 0022 00        		.byte	0
 1554 0023 9001      		.word	400
 1555 0025 28        		.byte	40
 1556 0026 00        		.byte	0
 1557 0027 00        		.byte	0
 1558 0028 00        		.byte	0
 1559 0029 F401      		.word	500
 1560 002b 32        		.byte	50
 1561 002c 00        		.byte	0
 1562 002d 00        		.byte	0
 1563 002e 00        		.byte	0
 1564 002f 5802      		.word	600
 1565 0031 46        		.byte	70
 1566 0032 00        		.byte	0
 1567 0033 00        		.byte	0
 1568 0034 00        		.byte	0
 1569 0035 BC02      		.word	700
 1570 0037 6E        		.byte	110
 1571 0038 00        		.byte	0
 1572 0039 00        		.byte	0
 1573 003a 00        		.byte	0
 1574 003b 2003      		.word	800
 1575 003d 8C        		.byte	-116
 1576 003e 00        		.byte	0
 1577 003f 00        		.byte	0
 1578 0040 00        		.byte	0
 1579 0041 8403      		.word	900
 1580 0043 B4        		.byte	-76
 1581 0044 00        		.byte	0
 1582 0045 00        		.byte	0
 1583 0046 00        		.byte	0
 1584 0047 E803      		.word	1000
 1585 0049 C8        		.byte	-56
 1586 004a 00        		.byte	0
 1587 004b 00        		.byte	0
 1588 004c 00        		.byte	0
 1589 004d 0004      		.word	1024
 1590 004f FF        		.byte	-1
 1591 0050 00        		.byte	0
 1592 0051 00        		.byte	0
 1593 0052 00        		.byte	0
 1612               		.text
 1614               	.Letext0:
 1615               	.global __do_copy_data
 1616               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccziiVVY.s:2      *ABS*:0000003f __SREG__
     /tmp/ccziiVVY.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccziiVVY.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccziiVVY.s:5      *ABS*:00000034 __CCP__
     /tmp/ccziiVVY.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccziiVVY.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccziiVVY.s:93     .text:00000000 main
                            *COM*:00000012 pidData_temp
                            *COM*:00000012 pidData_pump
                            *COM*:00000001 heat_power
     /tmp/ccziiVVY.s:1437   .bss:00000008 ramp_flag
     /tmp/ccziiVVY.s:263    .text:000000a0 do_things
                            *COM*:00000001 ADC_flag
     /tmp/ccziiVVY.s:308    .text:000000be __vector_9
                            *COM*:00000001 its_off
     /tmp/ccziiVVY.s:405    .text:0000012c four
     /tmp/ccziiVVY.s:1443   .bss:00000009 charspot
                            *COM*:00000002 ADC_data
     /tmp/ccziiVVY.s:441    .text:0000014e six_1
     /tmp/ccziiVVY.s:1419   .bss:00000002 pump
     /tmp/ccziiVVY.s:471    .text:00000168 six_2
     /tmp/ccziiVVY.s:505    .text:0000018e six_3
     /tmp/ccziiVVY.s:555    .text:000001cc seven
     /tmp/ccziiVVY.s:1413   .bss:00000000 lambda
     /tmp/ccziiVVY.s:598    .text:000001f8 readadc
     /tmp/ccziiVVY.s:635    .text:0000020a PID_heater
                            *COM*:00000002 measured_temperature
     /tmp/ccziiVVY.s:690    .text:00000244 PID_pump
     /tmp/ccziiVVY.s:775    .text:000002ae RtwoR_out
                            *COM*:00000004 zero_to_5_WB
     /tmp/ccziiVVY.s:1455   .progmem.data:00000000 Narro_curve
     /tmp/ccziiVVY.s:962    .text:0000035a eight
     /tmp/ccziiVVY.s:1425   .bss:00000004 DC_val
     /tmp/ccziiVVY.s:1533   .data:0000000b C.18.2970
     /tmp/ccziiVVY.s:1290   .text:0000056e __vector_14
     /tmp/ccziiVVY.s:1431   .bss:00000006 IpumpVolts
     /tmp/ccziiVVY.s:1449   .bss:0000000a rampcounter
                            *COM*:00000032 serialout
                            *COM*:00000001 pidCounter

UNDEFINED SYMBOLS
setup_timer1
setup_timer2
pid_Init
adc_init
timer0init
uart_putst
uart_put16dec
uart_putch
put_in_string
__udivmodhi4
pid_Controller
__divmodsi4
__mulsi3
__udivmodsi4
spitout
__do_copy_data
__do_clear_bss
