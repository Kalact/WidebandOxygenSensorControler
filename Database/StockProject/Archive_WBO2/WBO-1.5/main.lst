   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  86               		.data
  87               	.LC0:
  88 0000 7261 6D70 		.string	"ramp temp\n"
  88      2074 656D 
  88      700A 00
  89               		.text
  91               	.global	main
  93               	main:
   1:main.c        **** 
   2:main.c        **** /////////////---------------------------------///////////////////
   3:main.c        **** // 
   4:main.c        **** // www.waltech.com
   5:main.c        **** //
   6:main.c        **** /////////////---------------------------------/////////////////
   7:main.c        **** /*
   8:main.c        ****  * TO DO:  
   9:main.c        ****  * 	make led do something more?
  10:main.c        ****  */
  11:main.c        **** 
  12:main.c        **** //Includes here:
  13:main.c        **** 
  14:main.c        **** #include <avr/interrupt.h>
  15:main.c        **** #include <stdlib.h>
  16:main.c        **** #include <string.h>
  17:main.c        **** #include <util/delay.h>
  18:main.c        **** #include <avr/pgmspace.h>
  19:main.c        **** #include "pid.h"
  20:main.c        **** #include "stdint.h"
  21:main.c        **** #include "initilize_hardware.h"
  22:main.c        **** #include "dataout.h"
  23:main.c        **** //#define F_CPU 4000000UL
  24:main.c        **** //(in make file)
  25:main.c        **** #define BAUD 9600UL
  26:main.c        **** #define UBRRVAL (F_CPU/(BAUD*16)-1)
  27:main.c        **** 
  28:main.c        **** #define LOWER_NB 95 //lower value for start of narrow band curve.  
  29:main.c        **** #define MAXPUMP_I 196 // maximum current value for pump (leanest). 
  30:main.c        **** #define MINPUMP_I 50 // minimum current value for pump.  
  31:main.c        **** //NOTE (based on manual pump power settings)
  32:main.c        **** // Above max, virt gnd is pushed up. 
  33:main.c        **** // Nothing happens below min.
  34:main.c        **** // 0 current is at 116
  35:main.c        **** #define TARGET_NERNST 724 // lambda=1 value for nurnst, target for pump pid 
  36:main.c        **** #define TARGET_TEMP 237 
  37:main.c        **** #define P_temp    450
  38:main.c        **** #define I_temp    5
  39:main.c        **** #define D_temp    1
  40:main.c        **** 
  41:main.c        **** #define P_pump    15
  42:main.c        **** #define I_pump    74
  43:main.c        **** #define D_pump    2
  44:main.c        **** 
  45:main.c        **** //in pid.h, changed scalevalue to 1 since parampeters are now integers: K * 128
  46:main.c        **** 
  47:main.c        **** uint8_t heat_power;//global value fed to timer 0 for heater pwm
  48:main.c        **** uint16_t ADC_data;//read the ADC into this
  49:main.c        **** 
  50:main.c        **** uint16_t lambda = 0;// value read from adc2 for the nernst cell w/o DC
  51:main.c        **** uint16_t pump = 0;//measured voltage at pump
  52:main.c        **** uint16_t DC_val = 0;//value read from adc2 for the nernst cell w/DC
  53:main.c        **** 
  54:main.c        **** int16_t IpumpVolts=0;//difference from above proportional to current flowing to pump.
  55:main.c        **** uint16_t measured_temperature;//measured temperature value. also known as Ri
  56:main.c        **** uint32_t zero_to_5_WB;//value applier to timer2 to make DAC output
  57:main.c        **** 
  58:main.c        **** uint8_t ramp_flag=0;// flag gets set once the startup temperature ramp is done
  59:main.c        **** uint8_t its_off;//flag to keep track of the heater pwm state
  60:main.c        **** volatile uint8_t ADC_flag;//keeps track in the ADC interrupt 
  61:main.c        **** volatile uint8_t charspot=0;//keeps track of the position of the numbers going into the string
  62:main.c        **** volatile uint8_t rampcounter=0;//test couter
  63:main.c        **** 
  64:main.c        **** ////////////////////////////////////////////////////////////////////////
  65:main.c        **** //for PID:
  66:main.c        **** uint8_t pidCounter; //True when PID control loop should run one time
  67:main.c        **** struct PID_DATA pidData_temp; //termperature PID structure of vars
  68:main.c        **** struct PID_DATA pidData_pump; //pump PID structure of vars
  69:main.c        **** ////////////////////////////////////////////////////////////////////////
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        **** const uint8_t  Narro_curve[] PROGMEM= //256 values. How to get: OCR2=pgm_read_byte(&fiveVout[pump])
  73:main.c        **** {
  74:main.c        **** 0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,0x0B,
  75:main.c        **** 0x0B,0x0B,0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,0x09,0x09,0x09,0x08,0x08,0x08,0x07,0x07,
  76:main.c        **** 0x05,0x05,0x04,0x04,0x04,0x03,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x01,
  77:main.c        **** 0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
  78:main.c        **** };
  79:main.c        **** /////function prototypes/////
  80:main.c        **** uint16_t readadc(void);
  81:main.c        **** 
  82:main.c        **** void do_things(void);
  83:main.c        **** void two(void);
  84:main.c        **** void three(void);
  85:main.c        **** void four(void);
  86:main.c        **** void six_1(void);
  87:main.c        **** void six_2(void);
  88:main.c        **** void six_3(void);
  89:main.c        **** void seven(void);
  90:main.c        **** void eight(void);
  91:main.c        **** 
  92:main.c        **** void PID_pump(void);
  93:main.c        **** void PID_heater(void);
  94:main.c        **** void RtwoR_out(void);
  95:main.c        **** 
  96:main.c        **** 
  97:main.c        **** ////Interrupt Service Routines
  98:main.c        **** ISR(ADC_vect)
  99:main.c        **** {
 100:main.c        **** ADC_data = readadc();
 101:main.c        **** 
 102:main.c        **** if (ADC_flag == 7)//
 103:main.c        **** {
 104:main.c        **** 	four();
 105:main.c        **** }	
 106:main.c        **** else if (ADC_flag == 2)
 107:main.c        **** {
 108:main.c        **** 	six_1();
 109:main.c        **** }
 110:main.c        **** else if (ADC_flag == 8)
 111:main.c        **** {
 112:main.c        **** 	six_2();
 113:main.c        **** }
 114:main.c        **** else if (ADC_flag == 9)
 115:main.c        **** {
 116:main.c        **** 	six_3();
 117:main.c        **** }	
 118:main.c        **** 
 119:main.c        **** else if (ADC_flag == 3)//lambda
 120:main.c        **** {
 121:main.c        **** 	seven();
 122:main.c        **** }
 123:main.c        **** else if (ADC_flag == 4)//lambda+DC and calculations
 124:main.c        **** {
 125:main.c        **** 	eight();
 126:main.c        **** }
 127:main.c        **** 	else
 128:main.c        **** 	
 129:main.c        **** 	{
 130:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 131:main.c        **** 	}
 132:main.c        **** }
 133:main.c        **** ISR(TIMER0_OVF_vect)
 134:main.c        **** {		
 135:main.c        **** 	if (its_off==1)//pulse is off
 136:main.c        **** 	 {
 137:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 138:main.c        **** 		 its_off = 0;
 139:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 140:main.c        **** 		 if (newtimerval < 128)
 141:main.c        **** 		 {
 142:main.c        **** 			do_things();
 143:main.c        **** 		 }
 144:main.c        **** 		 TCNT0 = newtimerval;	 
 145:main.c        **** 	 }
 146:main.c        **** 	 else//pulse is on
 147:main.c        **** 	 {
 148:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 149:main.c        **** 		 its_off = 1; 
 150:main.c        **** 		 uint8_t newtimerval= (heat_power);
 151:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 152:main.c        **** 		 if (newtimerval < 128)
 153:main.c        **** 		 {
 154:main.c        **** 			do_things();
 155:main.c        **** 		 }
 156:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 157:main.c        **** 	 }
 158:main.c        **** 
 159:main.c        **** }
 160:main.c        **** 
 161:main.c        **** //////////////////////////////vvvvvvvvvvvvvvv MAIN  vvvvvvvvvvvvvvvvvvvvv//////////////////////////
 162:main.c        **** int main()
 163:main.c        **** {
  95               	.LM0:
  96               	.LFBB1:
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
 164:main.c        **** //set up all the pins as inputs and outputs
 165:main.c        **** /* 
 166:main.c        ****  * 	PC5 //outputs for R2R DAC
 167:main.c        ****  * 	PC4
 168:main.c        ****  * 	PC3
 169:main.c        ****  *  PB5  
 170:main.c        ****  *  PB4
 171:main.c        ****  * 	PB0
 172:main.c        ****  * 
 173:main.c        ****  *  PD4  LED
 174:main.c        ****  * 
 175:main.c        ****  * Nernst DC connection: PB2
 176:main.c        ****  * nch mosfet for heater: PD5
 177:main.c        ****  * 
 178:main.c        ****  * PB1 = pump power OC1A timer out
 179:main.c        ****  * PB3 = output voltage OC2 timer output
 180:main.c        ****  *   //ADC:
 181:main.c        ****  * nernst V: 	adc2
 182:main.c        ****  * pump			adc0
 183:main.c        ****  *
 184:main.c        ****  */ 
 185:main.c        **** DDRC |= _BV(5)| _BV(4) | _BV(3);//six bit dac
 102               	.LM1:
 103 0000 84B3      		in r24,52-32
 104 0002 8863      		ori r24,lo8(56)
 105 0004 84BB      		out 52-32,r24
 186:main.c        **** DDRB |= _BV(5)| _BV(4) | _BV(0);//six bit dac
 107               	.LM2:
 108 0006 87B3      		in r24,55-32
 109 0008 8163      		ori r24,lo8(49)
 110 000a 87BB      		out 55-32,r24
 187:main.c        **** DDRD |= _BV(4);//LED
 112               	.LM3:
 113 000c 8C9A      		sbi 49-32,4
 188:main.c        **** 
 189:main.c        **** DDRD |= ( _BV(5));// mosfet for heater
 115               	.LM4:
 116 000e 8D9A      		sbi 49-32,5
 190:main.c        **** DDRB |= _BV(2);// dc for temperature measurment
 118               	.LM5:
 119 0010 BA9A      		sbi 55-32,2
 191:main.c        **** ////setup uart:////
 192:main.c        **** cli();//  disable interrupts until things are set up
 121               	.LM6:
 122               	/* #APP */
 123               	 ;  192 "main.c" 1
 124 0012 F894      		cli
 125               	 ;  0 "" 2
 193:main.c        **** 	//init uart
 194:main.c        ****     /* set baud rate */
 195:main.c        ****    	UBRRH = (UBRRVAL >> 8);
 127               	.LM7:
 128               	/* #NOAPP */
 129 0014 10BC      		out 64-32,__zero_reg__
 196:main.c        ****    	UBRRL = (UBRRVAL & 0xff);
 131               	.LM8:
 132 0016 89E1      		ldi r24,lo8(25)
 133 0018 89B9      		out 41-32,r24
 197:main.c        ****     /* set frame format: 8 bit, no parity, 1 bit */
 198:main.c        ****     UCSRC |=  (1 << URSEL | 1 << UCSZ1 | 1 << UCSZ0);
 135               	.LM9:
 136 001a 80B5      		in r24,64-32
 137 001c 8668      		ori r24,lo8(-122)
 138 001e 80BD      		out 64-32,r24
 199:main.c        ****     UCSRB |= (1 << RXEN | 1 << TXEN | 1 << RXCIE);//enable receive, transmit, and receive complete 
 140               	.LM10:
 141 0020 8AB1      		in r24,42-32
 142 0022 8869      		ori r24,lo8(-104)
 143 0024 8AB9      		out 42-32,r24
 200:main.c        **** 
 201:main.c        **** //disable uart input, avoid Rx buffer overrun:
 202:main.c        **** UCSRB &= ~(1 << RXEN);
 145               	.LM11:
 146 0026 5498      		cbi 42-32,4
 203:main.c        **** UCSRB &= ~(1 << RXCIE);
 148               	.LM12:
 149 0028 5798      		cbi 42-32,7
 204:main.c        **** 
 205:main.c        **** setup_timer1();// pump control current dac on OC1A  
 151               	.LM13:
 152 002a 00D0      		rcall setup_timer1
 206:main.c        **** setup_timer2();//output 0-5v on OC2  
 154               	.LM14:
 155 002c 00D0      		rcall setup_timer2
 207:main.c        **** 	
 208:main.c        **** pid_Init(P_temp, I_temp, D_temp, &pidData_temp);//set up PID structure for temperature
 157               	.LM15:
 158 002e 82EC      		ldi r24,lo8(450)
 159 0030 91E0      		ldi r25,hi8(450)
 160 0032 65E0      		ldi r22,lo8(5)
 161 0034 70E0      		ldi r23,hi8(5)
 162 0036 41E0      		ldi r20,lo8(1)
 163 0038 50E0      		ldi r21,hi8(1)
 164 003a 20E0      		ldi r18,lo8(pidData_temp)
 165 003c 30E0      		ldi r19,hi8(pidData_temp)
 166 003e 00D0      		rcall pid_Init
 209:main.c        **** pid_Init(P_pump, I_pump, D_pump, &pidData_pump);//set up PID structure for nernst
 168               	.LM16:
 169 0040 8FE0      		ldi r24,lo8(15)
 170 0042 90E0      		ldi r25,hi8(15)
 171 0044 6AE4      		ldi r22,lo8(74)
 172 0046 70E0      		ldi r23,hi8(74)
 173 0048 42E0      		ldi r20,lo8(2)
 174 004a 50E0      		ldi r21,hi8(2)
 175 004c 20E0      		ldi r18,lo8(pidData_pump)
 176 004e 30E0      		ldi r19,hi8(pidData_pump)
 177 0050 00D0      		rcall pid_Init
 210:main.c        **** sei();//enable interrupts
 179               	.LM17:
 180               	/* #APP */
 181               	 ;  210 "main.c" 1
 182 0052 7894      		sei
 183               	 ;  0 "" 2
 211:main.c        **** adc_init();
 185               	.LM18:
 186               	/* #NOAPP */
 187 0054 00D0      		rcall adc_init
 212:main.c        **** // ramp up heat:
 213:main.c        **** heat_power = 130;//initial time
 189               	.LM19:
 190 0056 82E8      		ldi r24,lo8(-126)
 191 0058 8093 0000 		sts heat_power,r24
 214:main.c        **** timer0init();
 193               	.LM20:
 194 005c 00D0      		rcall timer0init
 215:main.c        **** PORTD |= _BV(4);//LED on
 196               	.LM21:
 197 005e 949A      		sbi 50-32,4
 216:main.c        **** uart_putst("ramp temp\n");
 199               	.LM22:
 200 0060 80E0      		ldi r24,lo8(.LC0)
 201 0062 90E0      		ldi r25,hi8(.LC0)
 202 0064 00D0      		rcall uart_putst
 217:main.c        **** while (heat_power<200)
 204               	.LM23:
 205 0066 00C0      		rjmp .L2
 206               	.L3:
 218:main.c        **** {
 219:main.c        **** heat_power++;
 208               	.LM24:
 209 0068 8F5F      		subi r24,lo8(-(1))
 210 006a 8093 0000 		sts heat_power,r24
 211               	.LBB6:
 212               	.LBB7:
 214               	.Ltext1:
   1:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
   6:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
   9:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  12:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  17:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  21:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  33:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  35:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  38:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  42:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  46:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  54:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  59:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  68:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  77:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  81:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** */
  82:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  83:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  88:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  94:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
  98:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 104:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 107:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 109:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 112:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 114:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 120:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 125:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 129:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 132:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 140:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** void
 142:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** {
 144:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 153:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 156:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 159:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 164:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 216               	.LM25:
 217 006e 2FEB      		 ldi r18,lo8(119999)
 218 0070 34ED      	    ldi r19,hi8(119999)
 219 0072 41E0      	    ldi r20,hlo8(119999)
 220 0074 2150      	    1:subi r18,1
 221 0076 3040      	    sbci r19,0
 222 0078 4040      	    sbci r20,0
 223 007a 01F4      	    brne 1b
 224 007c 00C0      		rjmp .
 225 007e 0000      		nop
 226               	.LBE7:
 227               	.LBE6:
 229               	.Ltext2:
 220:main.c        **** _delay_ms(150);
 221:main.c        **** uart_put16dec(heat_power);
 231               	.LM26:
 232 0080 90E0      		ldi r25,lo8(0)
 233 0082 00D0      		rcall uart_put16dec
 222:main.c        **** uart_putch(',');
 235               	.LM27:
 236 0084 8CE2      		ldi r24,lo8(44)
 237 0086 00D0      		rcall uart_putch
 223:main.c        **** uart_putch(' ');
 239               	.LM28:
 240 0088 80E2      		ldi r24,lo8(32)
 241 008a 00D0      		rcall uart_putch
 242               	.L2:
 217:main.c        **** while (heat_power<200)
 244               	.LM29:
 245 008c 8091 0000 		lds r24,heat_power
 246 0090 883C      		cpi r24,lo8(-56)
 247 0092 00F0      		brlo .L3
 224:main.c        **** }
 225:main.c        **** uart_putch('\n');
 249               	.LM30:
 250 0094 8AE0      		ldi r24,lo8(10)
 251 0096 00D0      		rcall uart_putch
 226:main.c        **** ramp_flag=1;
 253               	.LM31:
 254 0098 81E0      		ldi r24,lo8(1)
 255 009a 8093 0000 		sts ramp_flag,r24
 256               	.L4:
 257 009e 00C0      		rjmp .L4
 259               	.Lscope1:
 261               	.global	do_things
 263               	do_things:
 227:main.c        **** ///////////////////////
 228:main.c        **** while(1)
 229:main.c        **** 	{
 230:main.c        **** //most stuff handled in timer0 interrupt
 231:main.c        **** //Suggested: use a state machine, just read ADC data in the interrupt, and poll a flag to see if it
 232:main.c        **** 	}
 233:main.c        **** return 0;
 234:main.c        **** }
 235:main.c        **** //// end of main
 236:main.c        **** ///////////////////////////////////////////////////////// 
 237:main.c        **** //////vvvvvvvvvvvvvv functions vvvvvvvvvvvvvvvvv/////////
 238:main.c        **** /////////////////////////////////////////////////////////
 239:main.c        **** 
 240:main.c        **** void do_things(void)//do first adc
 241:main.c        **** {  
 265               	.LM32:
 266               	.LFBB2:
 267               	/* prologue: function */
 268               	/* frame size = 0 */
 269               	/* stack size = 0 */
 270               	.L__stack_usage = 0
 242:main.c        **** 	if (ramp_flag == 1)
 272               	.LM33:
 273 00a0 8091 0000 		lds r24,ramp_flag
 274 00a4 8130      		cpi r24,lo8(1)
 275 00a6 01F4      		brne .L5
 276               	.LBB8:
 277               	.LBB9:
 279               	.Ltext3:
 165:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 166:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** }
 187:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 188:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 191:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 193:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 196:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 198:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 202:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   
 207:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 211:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  
 214:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 222:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** void
 224:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** {
 226:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 235:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 238:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 241:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 
 246:/usr/local/avr/lib/gcc/avr/4.5.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 281               	.LM34:
 282 00a8 82E4      		 ldi r24,lo8(66)
 283 00aa 8A95      	    1:dec r24
 284 00ac 01F4      	    brne 1b
 285 00ae 00C0      		rjmp .
 286               	.LBE9:
 287               	.LBE8:
 289               	.Ltext4:
 243:main.c        **** 	{
 244:main.c        **** 	_delay_us(50);//maybe let things settle?
 245:main.c        **** 	ADC_flag = 7;//sets to run function after conversion
 291               	.LM35:
 292 00b0 87E0      		ldi r24,lo8(7)
 293 00b2 8093 0000 		sts ADC_flag,r24
 246:main.c        **** 	ADMUX =(192 + 1);//V refrence plus mux (192 => 2.5v vref; 64 => avcc vref)				
 295               	.LM36:
 296 00b6 81EC      		ldi r24,lo8(-63)
 297 00b8 87B9      		out 39-32,r24
 247:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion 
 299               	.LM37:
 300 00ba 369A      		sbi 38-32,6
 301               	.L5:
 302 00bc 0895      		ret
 304               	.Lscope2:
 306               	.global	__vector_9
 308               	__vector_9:
 134:main.c        **** {		
 310               	.LM38:
 311               	.LFBB3:
 312 00be 1F92      		push __zero_reg__
 313 00c0 0F92      		push r0
 314 00c2 0FB6      		in r0,__SREG__
 315 00c4 0F92      		push r0
 316 00c6 1124      		clr __zero_reg__
 317 00c8 2F93      		push r18
 318 00ca 3F93      		push r19
 319 00cc 4F93      		push r20
 320 00ce 5F93      		push r21
 321 00d0 6F93      		push r22
 322 00d2 7F93      		push r23
 323 00d4 8F93      		push r24
 324 00d6 9F93      		push r25
 325 00d8 AF93      		push r26
 326 00da BF93      		push r27
 327 00dc CF93      		push r28
 328 00de EF93      		push r30
 329 00e0 FF93      		push r31
 330               	/* prologue: Signal */
 331               	/* frame size = 0 */
 332               	/* stack size = 16 */
 333               	.L__stack_usage = 16
 135:main.c        **** 	if (its_off==1)//pulse is off
 335               	.LM39:
 336 00e2 8091 0000 		lds r24,its_off
 337 00e6 C091 0000 		lds r28,heat_power
 338 00ea 8130      		cpi r24,lo8(1)
 339 00ec 01F4      		brne .L8
 340               	.LBB10:
 137:main.c        **** 		 PORTD |= _BV(5);//turn pin on
 342               	.LM40:
 343 00ee 959A      		sbi 50-32,5
 138:main.c        **** 		 its_off = 0;
 345               	.LM41:
 346 00f0 1092 0000 		sts its_off,__zero_reg__
 139:main.c        **** 		 uint8_t newtimerval= (255-heat_power);
 348               	.LM42:
 349 00f4 C095      		com r28
 350 00f6 00C0      		rjmp .L14
 351               	.L8:
 352               	.LBE10:
 353               	.LBB11:
 148:main.c        **** 		 PORTD &=~ _BV(5);//turn pin off
 355               	.LM43:
 356 00f8 9598      		cbi 50-32,5
 149:main.c        **** 		 its_off = 1; 
 358               	.LM44:
 359 00fa 81E0      		ldi r24,lo8(1)
 360 00fc 8093 0000 		sts its_off,r24
 151:main.c        **** 		 TCNT0 = newtimerval;//heat_power setting into TCNTO
 362               	.LM45:
 363 0100 C2BF      		out 82-32,r28
 364               	.L14:
 152:main.c        **** 		 if (newtimerval < 128)
 366               	.LM46:
 367 0102 C7FF      		sbrs r28,7
 154:main.c        **** 			do_things();
 369               	.LM47:
 370 0104 00D0      		rcall do_things
 371               	.L11:
 156:main.c        **** 		 TCNT0 = (newtimerval);//heat_power setting into TCNTO
 373               	.LM48:
 374 0106 C2BF      		out 82-32,r28
 375               	/* epilogue start */
 376               	.LBE11:
 159:main.c        **** }
 378               	.LM49:
 379 0108 FF91      		pop r31
 380 010a EF91      		pop r30
 381 010c CF91      		pop r28
 382 010e BF91      		pop r27
 383 0110 AF91      		pop r26
 384 0112 9F91      		pop r25
 385 0114 8F91      		pop r24
 386 0116 7F91      		pop r23
 387 0118 6F91      		pop r22
 388 011a 5F91      		pop r21
 389 011c 4F91      		pop r20
 390 011e 3F91      		pop r19
 391 0120 2F91      		pop r18
 392 0122 0F90      		pop r0
 393 0124 0FBE      		out __SREG__,r0
 394 0126 0F90      		pop r0
 395 0128 1F90      		pop __zero_reg__
 396 012a 1895      		reti
 401               	.Lscope3:
 403               	.global	four
 405               	four:
 248:main.c        **** 	}	
 249:main.c        **** }
 250:main.c        **** void four(void)//record aux adc 1, mux for pump current
 251:main.c        **** {
 407               	.LM50:
 408               	.LFBB4:
 409               	/* prologue: function */
 410               	/* frame size = 0 */
 411               	/* stack size = 0 */
 412               	.L__stack_usage = 0
 252:main.c        **** 	charspot = put_in_string(ADC_data,'\0',charspot);//puts data in big string 
 414               	.LM51:
 415 012c 4091 0000 		lds r20,charspot
 416 0130 8091 0000 		lds r24,ADC_data
 417 0134 9091 0000 		lds r25,ADC_data+1
 418 0138 60E0      		ldi r22,lo8(0)
 419 013a 00D0      		rcall put_in_string
 420 013c 8093 0000 		sts charspot,r24
 253:main.c        **** 	ADC_flag = 2;
 422               	.LM52:
 423 0140 82E0      		ldi r24,lo8(2)
 424 0142 8093 0000 		sts ADC_flag,r24
 254:main.c        **** 	ADMUX =(192 + 0);//V refrence plus mux (pump)			
 426               	.LM53:
 427 0146 80EC      		ldi r24,lo8(-64)
 428 0148 87B9      		out 39-32,r24
 255:main.c        **** 	ADCSRA |= _BV(ADSC);// starts  conversion
 430               	.LM54:
 431 014a 369A      		sbi 38-32,6
 432               	/* epilogue start */
 256:main.c        **** }	
 434               	.LM55:
 435 014c 0895      		ret
 437               	.Lscope4:
 439               	.global	six_1
 441               	six_1:
 257:main.c        **** 
 258:main.c        **** void six_1(void)//measures pump current 1/3 sample
 259:main.c        **** {	
 443               	.LM56:
 444               	.LFBB5:
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 0 */
 448               	.L__stack_usage = 0
 260:main.c        **** 	pump = ADC_data;
 450               	.LM57:
 451 014e 8091 0000 		lds r24,ADC_data
 452 0152 9091 0000 		lds r25,ADC_data+1
 453 0156 9093 0000 		sts pump+1,r25
 454 015a 8093 0000 		sts pump,r24
 261:main.c        **** 	ADC_flag = 8;	
 456               	.LM58:
 457 015e 88E0      		ldi r24,lo8(8)
 458 0160 8093 0000 		sts ADC_flag,r24
 262:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 460               	.LM59:
 461 0164 369A      		sbi 38-32,6
 462               	/* epilogue start */
 263:main.c        **** }
 464               	.LM60:
 465 0166 0895      		ret
 467               	.Lscope5:
 469               	.global	six_2
 471               	six_2:
 264:main.c        **** 
 265:main.c        **** void six_2(void)//measures pump current 2/3
 266:main.c        **** {	
 473               	.LM61:
 474               	.LFBB6:
 475               	/* prologue: function */
 476               	/* frame size = 0 */
 477               	/* stack size = 0 */
 478               	.L__stack_usage = 0
 267:main.c        **** 	pump = pump + ADC_data;
 480               	.LM62:
 481 0168 8091 0000 		lds r24,pump
 482 016c 9091 0000 		lds r25,pump+1
 483 0170 2091 0000 		lds r18,ADC_data
 484 0174 3091 0000 		lds r19,ADC_data+1
 485 0178 820F      		add r24,r18
 486 017a 931F      		adc r25,r19
 487 017c 9093 0000 		sts pump+1,r25
 488 0180 8093 0000 		sts pump,r24
 268:main.c        **** 	ADC_flag = 9;	
 490               	.LM63:
 491 0184 89E0      		ldi r24,lo8(9)
 492 0186 8093 0000 		sts ADC_flag,r24
 269:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 494               	.LM64:
 495 018a 369A      		sbi 38-32,6
 496               	/* epilogue start */
 270:main.c        **** }
 498               	.LM65:
 499 018c 0895      		ret
 501               	.Lscope6:
 503               	.global	six_3
 505               	six_3:
 271:main.c        **** 
 272:main.c        **** void six_3(void)//measures pump current 3/3
 273:main.c        **** {	
 507               	.LM66:
 508               	.LFBB7:
 509               	/* prologue: function */
 510               	/* frame size = 0 */
 511               	/* stack size = 0 */
 512               	.L__stack_usage = 0
 274:main.c        **** 	pump = pump + ADC_data;
 514               	.LM67:
 515 018e 8091 0000 		lds r24,ADC_data
 516 0192 9091 0000 		lds r25,ADC_data+1
 517 0196 2091 0000 		lds r18,pump
 518 019a 3091 0000 		lds r19,pump+1
 519 019e 820F      		add r24,r18
 520 01a0 931F      		adc r25,r19
 275:main.c        **** 	pump = pump/3;
 522               	.LM68:
 523 01a2 63E0      		ldi r22,lo8(3)
 524 01a4 70E0      		ldi r23,hi8(3)
 525 01a6 00D0      		rcall __udivmodhi4
 526 01a8 6093 0000 		sts pump,r22
 527 01ac 7093 0000 		sts pump+1,r23
 276:main.c        **** 	charspot = put_in_string(pump,'\0',charspot);//puts data in big string and sends back new char spo
 529               	.LM69:
 530 01b0 4091 0000 		lds r20,charspot
 531 01b4 CB01      		movw r24,r22
 532 01b6 60E0      		ldi r22,lo8(0)
 533 01b8 00D0      		rcall put_in_string
 534 01ba 8093 0000 		sts charspot,r24
 277:main.c        **** 	ADC_flag = 3;	
 536               	.LM70:
 537 01be 83E0      		ldi r24,lo8(3)
 538 01c0 8093 0000 		sts ADC_flag,r24
 278:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 540               	.LM71:
 541 01c4 82EC      		ldi r24,lo8(-62)
 542 01c6 87B9      		out 39-32,r24
 279:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  next conversion		
 544               	.LM72:
 545 01c8 369A      		sbi 38-32,6
 546               	/* epilogue start */
 280:main.c        **** }
 548               	.LM73:
 549 01ca 0895      		ret
 551               	.Lscope7:
 553               	.global	seven
 555               	seven:
 281:main.c        **** 
 282:main.c        **** void seven(void)//measure nurnst 
 283:main.c        **** {
 557               	.LM74:
 558               	.LFBB8:
 559               	/* prologue: function */
 560               	/* frame size = 0 */
 561               	/* stack size = 0 */
 562               	.L__stack_usage = 0
 284:main.c        **** 	lambda = ADC_data;
 564               	.LM75:
 565 01cc 8091 0000 		lds r24,ADC_data
 566 01d0 9091 0000 		lds r25,ADC_data+1
 567 01d4 9093 0000 		sts lambda+1,r25
 568 01d8 8093 0000 		sts lambda,r24
 285:main.c        **** 	charspot = put_in_string(lambda,'\0',charspot);//puts data in big string
 570               	.LM76:
 571 01dc 4091 0000 		lds r20,charspot
 572 01e0 60E0      		ldi r22,lo8(0)
 573 01e2 00D0      		rcall put_in_string
 574 01e4 8093 0000 		sts charspot,r24
 286:main.c        **** 	ADC_flag = 4;
 576               	.LM77:
 577 01e8 84E0      		ldi r24,lo8(4)
 578 01ea 8093 0000 		sts ADC_flag,r24
 287:main.c        **** 	ADMUX =(192 + 2);//V refrence plus mux channel//use 192 for internal 2.5v ref//use 64 for avcc as 
 580               	.LM78:
 581 01ee 82EC      		ldi r24,lo8(-62)
 582 01f0 87B9      		out 39-32,r24
 288:main.c        **** 	PORTB |= _BV(2);//DC on
 584               	.LM79:
 585 01f2 C29A      		sbi 56-32,2
 289:main.c        **** 	ADCSRA |= (1<<ADSC);// starts  conversion	
 587               	.LM80:
 588 01f4 369A      		sbi 38-32,6
 589               	/* epilogue start */
 290:main.c        **** }
 591               	.LM81:
 592 01f6 0895      		ret
 594               	.Lscope8:
 596               	.global	readadc
 598               	readadc:
 291:main.c        **** 
 292:main.c        **** void eight(void)
 293:main.c        **** {
 294:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 295:main.c        **** 	DC_val = ADC_data;
 296:main.c        **** //	charspot = put_in_string(DC_val,'d',charspot);//puts data in big string
 297:main.c        **** 	ADC_flag = 0;	
 298:main.c        **** 	////do calculations and PIDs
 299:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 300:main.c        **** 	//done in PID_pump//charspot = put_in_string(measured_temperature,'f',charspot);
 301:main.c        **** 	measured_temperature = (DC_val - lambda);
 302:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 303:main.c        **** 		{
 304:main.c        **** 		measured_temperature = (255 - measured_temperature);
 305:main.c        **** 		}
 306:main.c        **** 	else
 307:main.c        **** 		{
 308:main.c        **** 		measured_temperature =0;
 309:main.c        **** 		}
 310:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 311:main.c        **** 		{
 312:main.c        **** 		PORTD &=~ _BV(4);//LED off
 313:main.c        **** 		}
 314:main.c        **** 	else
 315:main.c        **** 		{
 316:main.c        **** 		PORTD |= _BV(4);//LED on
 317:main.c        **** 		}
 318:main.c        **** 	//calculate 0-5v output from Look Up Table:
 319:main.c        **** 	struct two_col{
 320:main.c        **** 		uint16_t x;
 321:main.c        **** 		uint32_t y;
 322:main.c        **** 	}; 
 323:main.c        **** 	struct two_col out_volts[]={	//table columns: pump, zero_to_5_WB (pump current ADC value, DAC valu
 324:main.c        **** 		{400,0},
 325:main.c        **** 		{425, 10}, 
 326:main.c        **** 		{450, 20},
 327:main.c        **** 		{475, 30},
 328:main.c        **** 		{500, 40},
 329:main.c        **** 		{525, 50},
 330:main.c        **** 		{550, 70},
 331:main.c        **** 		{575, 110},
 332:main.c        **** 		{600, 140},
 333:main.c        **** 		{625, 180},
 334:main.c        **** 		{650, 200},
 335:main.c        **** 		{720, 254},
 336:main.c        **** 		};
 337:main.c        **** 	uint8_t n = 12;//number of rows in table	
 338:main.c        **** 	//out of range check:
 339:main.c        **** 	if (pump<out_volts[0].x)//smaller than the lowest value in LOT
 340:main.c        **** 	{
 341:main.c        **** 		zero_to_5_WB = 0;
 342:main.c        **** 	}
 343:main.c        **** 	else if (pump>out_volts[n-1].x)//larger than the highest value in the LOT
 344:main.c        **** 	{
 345:main.c        **** 		zero_to_5_WB = 254;
 346:main.c        **** 	}
 347:main.c        **** 	else//in range, lookup in table, interpolate
 348:main.c        **** 	{
 349:main.c        **** 		
 350:main.c        **** 		for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 351:main.c        **** 		{
 352:main.c        **** 			if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 353:main.c        **** 			{
 354:main.c        **** 				uint16_t diffx = pump - out_volts[i].x; //difference between the pump value and the x value in 
 355:main.c        **** 				uint16_t diffn = out_volts[i+1].x - out_volts[i].x;//spacing between the values in the LOT
 356:main.c        **** 				zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output
 357:main.c        **** 			}
 358:main.c        **** 		}
 359:main.c        **** 	}
 360:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 361:main.c        **** 	RtwoR_out(); //set six bit DAC outout for narrow
 362:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 363:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 364:main.c        **** 
 365:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 366:main.c        **** //	charspot = put_in_string(heat_power,'h',charspot);//puts data in big string
 367:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 368:main.c        **** }
 369:main.c        **** 	
 370:main.c        **** uint16_t readadc(void)
 371:main.c        **** {
 600               	.LM82:
 601               	.LFBB9:
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 0 */
 605               	.L__stack_usage = 0
 372:main.c        **** 	uint8_t adcDataL = ADCL;
 607               	.LM83:
 608 01f8 24B1      		in r18,36-32
 373:main.c        ****     uint8_t adcDataH = ADCH;
 610               	.LM84:
 611 01fa 35B1      		in r19,37-32
 374:main.c        ****     uint16_t adcData = 0;
 375:main.c        ****     adcData = adcData | adcDataH;
 376:main.c        ****     adcData = adcData << 8;//left shift 8 spots
 613               	.LM85:
 614 01fc 932F      		mov r25,r19
 615 01fe 80E0      		ldi r24,lo8(0)
 377:main.c        ****     adcData = adcData | adcDataL;
 617               	.LM86:
 618 0200 30E0      		ldi r19,lo8(0)
 619 0202 282B      		or r18,r24
 620 0204 392B      		or r19,r25
 378:main.c        ****     return adcData;
 379:main.c        **** }
 622               	.LM87:
 623 0206 C901      		movw r24,r18
 624               	/* epilogue start */
 625 0208 0895      		ret
 631               	.Lscope9:
 633               	.global	PID_heater
 635               	PID_heater:
 380:main.c        **** 
 381:main.c        **** void PID_heater(void)
 382:main.c        **** {
 637               	.LM88:
 638               	.LFBB10:
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 383:main.c        **** 	int32_t calculated = pid_Controller(TARGET_TEMP, measured_temperature, &pidData_temp);  // for tem
 644               	.LM89:
 645 020a 6091 0000 		lds r22,measured_temperature
 646 020e 7091 0000 		lds r23,measured_temperature+1
 647 0212 8DEE      		ldi r24,lo8(237)
 648 0214 90E0      		ldi r25,hi8(237)
 649 0216 40E0      		ldi r20,lo8(pidData_temp)
 650 0218 50E0      		ldi r21,hi8(pidData_temp)
 651 021a 00D0      		rcall pid_Controller
 652 021c AA27      		clr r26
 653 021e 97FD      		sbrc r25,7
 654 0220 A095      		com r26
 655 0222 BA2F      		mov r27,r26
 384:main.c        **** 
 385:main.c        **** 	if ((calculated) > 255 )
 657               	.LM90:
 658 0224 8F3F      		cpi r24,lo8(255)
 659 0226 9105      		cpc r25,__zero_reg__
 660 0228 A105      		cpc r26,__zero_reg__
 661 022a B105      		cpc r27,__zero_reg__
 662 022c 01F0      		breq .L22
 663 022e 04F0      		brlt .L22
 386:main.c        **** 	{
 387:main.c        **** 		heat_power = 255 ;
 665               	.LM91:
 666 0230 8FEF      		ldi r24,lo8(-1)
 667 0232 00C0      		rjmp .L24
 668               	.L22:
 388:main.c        **** 	}
 389:main.c        **** 	else if ((calculated) < 0 )
 670               	.LM92:
 671 0234 B7FF      		sbrs r27,7
 672 0236 00C0      		rjmp .L24
 390:main.c        **** 	{
 391:main.c        **** 		heat_power = 0 ;
 674               	.LM93:
 675 0238 1092 0000 		sts heat_power,__zero_reg__
 676 023c 0895      		ret
 677               	.L24:
 392:main.c        **** 	}
 393:main.c        **** 	else
 394:main.c        **** 	{
 395:main.c        **** 		heat_power =(calculated);
 679               	.LM94:
 680 023e 8093 0000 		sts heat_power,r24
 681 0242 0895      		ret
 686               	.Lscope10:
 688               	.global	PID_pump
 690               	PID_pump:
 396:main.c        **** 	}
 397:main.c        **** 
 398:main.c        **** }
 399:main.c        **** 
 400:main.c        **** void PID_pump(void)
 401:main.c        **** {
 692               	.LM95:
 693               	.LFBB11:
 694               	/* prologue: function */
 695               	/* frame size = 0 */
 696               	/* stack size = 0 */
 697               	.L__stack_usage = 0
 402:main.c        **** int32_t calculated =  ( pid_Controller(TARGET_NERNST, lambda, &pidData_pump) );  // PID
 699               	.LM96:
 700 0244 6091 0000 		lds r22,lambda
 701 0248 7091 0000 		lds r23,lambda+1
 702 024c 84ED      		ldi r24,lo8(724)
 703 024e 92E0      		ldi r25,hi8(724)
 704 0250 40E0      		ldi r20,lo8(pidData_pump)
 705 0252 50E0      		ldi r21,hi8(pidData_pump)
 706 0254 00D0      		rcall pid_Controller
 707 0256 9C01      		movw r18,r24
 708 0258 B901      		movw r22,r18
 709 025a 8827      		clr r24
 710 025c 77FD      		sbrc r23,7
 711 025e 8095      		com r24
 712 0260 982F      		mov r25,r24
 403:main.c        **** calculated = (calculated/4) + 116;//116 is zero current.
 714               	.LM97:
 715 0262 24E0      		ldi r18,lo8(4)
 716 0264 30E0      		ldi r19,hi8(4)
 717 0266 40E0      		ldi r20,hlo8(4)
 718 0268 50E0      		ldi r21,hhi8(4)
 719 026a 00D0      		rcall __divmodsi4
 720 026c 2C58      		subi r18,lo8(-(116))
 721 026e 3F4F      		sbci r19,hi8(-(116))
 722 0270 4F4F      		sbci r20,hlo8(-(116))
 723 0272 5F4F      		sbci r21,hhi8(-(116))
 404:main.c        **** if ((calculated) > MAXPUMP_I)
 725               	.LM98:
 726 0274 253C      		cpi r18,lo8(197)
 727 0276 3105      		cpc r19,__zero_reg__
 728 0278 4105      		cpc r20,__zero_reg__
 729 027a 5105      		cpc r21,__zero_reg__
 730 027c 04F0      		brlt .L26
 405:main.c        **** 	{
 406:main.c        **** 		OCR1A = MAXPUMP_I;
 732               	.LM99:
 733 027e 84EC      		ldi r24,lo8(196)
 734 0280 90E0      		ldi r25,hi8(196)
 735 0282 00C0      		rjmp .L29
 736               	.L26:
 407:main.c        **** 	}
 408:main.c        **** else if ((calculated) < MINPUMP_I)
 738               	.LM100:
 739 0284 2233      		cpi r18,lo8(50)
 740 0286 3105      		cpc r19,__zero_reg__
 741 0288 4105      		cpc r20,__zero_reg__
 742 028a 5105      		cpc r21,__zero_reg__
 743 028c 04F4      		brge .L28
 409:main.c        **** 	{
 410:main.c        **** 		OCR1A = MINPUMP_I;
 745               	.LM101:
 746 028e 82E3      		ldi r24,lo8(50)
 747 0290 90E0      		ldi r25,hi8(50)
 748               	.L29:
 749 0292 9BBD      		out 74+1-32,r25
 750 0294 8ABD      		out 74-32,r24
 751 0296 00C0      		rjmp .L27
 752               	.L28:
 411:main.c        **** 	}
 412:main.c        **** 	else
 413:main.c        **** 	{
 414:main.c        **** 		OCR1A =(calculated);
 754               	.LM102:
 755 0298 3BBD      		out 74+1-32,r19
 756 029a 2ABD      		out 74-32,r18
 757               	.L27:
 415:main.c        **** 	}
 416:main.c        **** 	charspot = put_in_string(OCR1A,'\0',charspot);//puts data in big string	
 759               	.LM103:
 760 029c 8AB5      		in r24,74-32
 761 029e 9BB5      		in r25,74+1-32
 762 02a0 4091 0000 		lds r20,charspot
 763 02a4 60E0      		ldi r22,lo8(0)
 764 02a6 00D0      		rcall put_in_string
 765 02a8 8093 0000 		sts charspot,r24
 766               	/* epilogue start */
 417:main.c        **** 
 418:main.c        **** }
 768               	.LM104:
 769 02ac 0895      		ret
 771               	.Lscope11:
 773               	.global	RtwoR_out
 775               	RtwoR_out:
 419:main.c        **** 
 420:main.c        **** void RtwoR_out(void)
 421:main.c        **** {
 777               	.LM105:
 778               	.LFBB12:
 779 02ae DF93      		push r29
 780 02b0 CF93      		push r28
 781 02b2 0F92      		push __tmp_reg__
 782 02b4 CDB7      		in r28,__SP_L__
 783 02b6 DEB7      		in r29,__SP_H__
 784               	/* prologue: function */
 785               	/* frame size = 1 */
 786               	/* stack size = 3 */
 787               	.L__stack_usage = 3
 422:main.c        **** 	uint8_t pin_assign;//value to be applied to 6bit dac R2R ladder
 423:main.c        **** 	if (zero_to_5_WB >= LOWER_NB && zero_to_5_WB <= LOWER_NB+64)//check if in range for NB
 789               	.LM106:
 790 02b8 8091 0000 		lds r24,zero_to_5_WB
 791 02bc 9091 0000 		lds r25,zero_to_5_WB+1
 792 02c0 A091 0000 		lds r26,zero_to_5_WB+2
 793 02c4 B091 0000 		lds r27,zero_to_5_WB+3
 794 02c8 9C01      		movw r18,r24
 795 02ca AD01      		movw r20,r26
 796 02cc 2F55      		subi r18,lo8(-(-95))
 797 02ce 3040      		sbci r19,hi8(-(-95))
 798 02d0 4040      		sbci r20,hlo8(-(-95))
 799 02d2 5040      		sbci r21,hhi8(-(-95))
 800 02d4 2134      		cpi r18,lo8(65)
 801 02d6 3105      		cpc r19,__zero_reg__
 802 02d8 4105      		cpc r20,__zero_reg__
 803 02da 5105      		cpc r21,__zero_reg__
 804 02dc 00F4      		brsh .L31
 805               	.LBB12:
 424:main.c        **** 	{
 425:main.c        **** 		uint8_t i= zero_to_5_WB - LOWER_NB;// set i to offset of zero_to_5_WB
 807               	.LM107:
 808 02de 8F55      		subi r24,lo8(-(-95))
 809               	.LBB13:
 426:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[i]);//get value out of lookup table		
 811               	.LM108:
 812 02e0 E82F      		mov r30,r24
 813 02e2 F0E0      		ldi r31,lo8(0)
 814 02e4 E050      		subi r30,lo8(-(Narro_curve))
 815 02e6 F040      		sbci r31,hi8(-(Narro_curve))
 816               	/* #APP */
 817               	 ;  426 "main.c" 1
 818 02e8 E491      		lpm r30, Z
 819               		
 820               	 ;  0 "" 2
 821               	/* #NOAPP */
 822 02ea 00C0      		rjmp .L46
 823               	.L31:
 824               	.LBE13:
 825               	.LBE12:
 427:main.c        **** 	}
 428:main.c        **** 	else if (zero_to_5_WB < LOWER_NB)
 827               	.LM109:
 828 02ec 8F35      		cpi r24,lo8(95)
 829 02ee 9105      		cpc r25,__zero_reg__
 830 02f0 A105      		cpc r26,__zero_reg__
 831 02f2 B105      		cpc r27,__zero_reg__
 832 02f4 00F4      		brsh .L33
 833               	.LBB14:
 429:main.c        **** 	{
 430:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[0]);//set six bit to minimum in table
 835               	.LM110:
 836 02f6 E0E0      		ldi r30,lo8(Narro_curve)
 837 02f8 F0E0      		ldi r31,hi8(Narro_curve)
 838               	/* #APP */
 839               	 ;  430 "main.c" 1
 840 02fa E491      		lpm r30, Z
 841               		
 842               	 ;  0 "" 2
 843               	/* #NOAPP */
 844 02fc 00C0      		rjmp .L46
 845               	.L33:
 846               	.LBE14:
 847               	.LBB15:
 431:main.c        **** 	}
 432:main.c        **** 	else 
 433:main.c        **** 	{
 434:main.c        **** 		pin_assign = pgm_read_byte(&Narro_curve[63]);//set six bit to max in table
 849               	.LM111:
 850 02fe E0E0      		ldi r30,lo8(Narro_curve+63)
 851 0300 F0E0      		ldi r31,hi8(Narro_curve+63)
 852               	/* #APP */
 853               	 ;  434 "main.c" 1
 854 0302 E491      		lpm r30, Z
 855               		
 856               	 ;  0 "" 2
 857               	/* #NOAPP */
 858               	.L46:
 859               	.LBE15:
 860 0304 E983      		std Y+1,r30
 435:main.c        **** 	}
 436:main.c        **** 	//check each bit 0 to 5 of pin_assign and apply to actual pins of R2R ladder:			
 437:main.c        **** 	if bit_is_set(pin_assign,0)
 862               	.LM112:
 863 0306 FE01      		movw r30,r28
 864 0308 3196      		adiw r30,1
 865 030a 8981      		ldd r24,Y+1
 866 030c 80FF      		sbrs r24,0
 867 030e 00C0      		rjmp .L34
 438:main.c        **** 	{PORTC |= _BV(5);}
 869               	.LM113:
 870 0310 AD9A      		sbi 53-32,5
 871 0312 00C0      		rjmp .L35
 872               	.L34:
 439:main.c        **** 	else {PORTC &=~ _BV(5);}
 874               	.LM114:
 875 0314 AD98      		cbi 53-32,5
 876               	.L35:
 440:main.c        **** 	if bit_is_set(pin_assign,1)
 878               	.LM115:
 879 0316 8081      		ld r24,Z
 880 0318 81FF      		sbrs r24,1
 881 031a 00C0      		rjmp .L36
 441:main.c        **** 	{PORTC |= _BV(4);}
 883               	.LM116:
 884 031c AC9A      		sbi 53-32,4
 885 031e 00C0      		rjmp .L37
 886               	.L36:
 442:main.c        **** 	else {PORTC &=~ _BV(4);}
 888               	.LM117:
 889 0320 AC98      		cbi 53-32,4
 890               	.L37:
 443:main.c        **** 	if bit_is_set(pin_assign,2)
 892               	.LM118:
 893 0322 8081      		ld r24,Z
 894 0324 82FF      		sbrs r24,2
 895 0326 00C0      		rjmp .L38
 444:main.c        **** 	{PORTC |= _BV(3);}
 897               	.LM119:
 898 0328 AB9A      		sbi 53-32,3
 899 032a 00C0      		rjmp .L39
 900               	.L38:
 445:main.c        **** 	else {PORTC &=~ _BV(3);}
 902               	.LM120:
 903 032c AB98      		cbi 53-32,3
 904               	.L39:
 446:main.c        **** 	if bit_is_set(pin_assign,3)
 906               	.LM121:
 907 032e 8081      		ld r24,Z
 908 0330 83FF      		sbrs r24,3
 909 0332 00C0      		rjmp .L40
 447:main.c        **** 	{PORTB |= _BV(5);}
 911               	.LM122:
 912 0334 C59A      		sbi 56-32,5
 913 0336 00C0      		rjmp .L41
 914               	.L40:
 448:main.c        **** 	else {PORTB &=~ _BV(5);}
 916               	.LM123:
 917 0338 C598      		cbi 56-32,5
 918               	.L41:
 449:main.c        **** 	if bit_is_set(pin_assign,4)
 920               	.LM124:
 921 033a 8081      		ld r24,Z
 922 033c 84FF      		sbrs r24,4
 923 033e 00C0      		rjmp .L42
 450:main.c        **** 	{PORTB |= _BV(4);}
 925               	.LM125:
 926 0340 C49A      		sbi 56-32,4
 927 0342 00C0      		rjmp .L43
 928               	.L42:
 451:main.c        **** 	else {PORTB &=~ _BV(4);}
 930               	.LM126:
 931 0344 C498      		cbi 56-32,4
 932               	.L43:
 452:main.c        **** 	if bit_is_set(pin_assign,5)
 934               	.LM127:
 935 0346 8081      		ld r24,Z
 936 0348 85FF      		sbrs r24,5
 937 034a 00C0      		rjmp .L44
 453:main.c        **** 	{PORTB |= _BV(0);}
 939               	.LM128:
 940 034c C09A      		sbi 56-32,0
 941 034e 00C0      		rjmp .L30
 942               	.L44:
 454:main.c        **** 	else {PORTB &=~ _BV(0);}
 944               	.LM129:
 945 0350 C098      		cbi 56-32,0
 946               	.L30:
 947               	/* epilogue start */
 455:main.c        **** }
 949               	.LM130:
 950 0352 0F90      		pop __tmp_reg__
 951 0354 CF91      		pop r28
 952 0356 DF91      		pop r29
 953 0358 0895      		ret
 958               	.Lscope12:
 960               	.global	eight
 962               	eight:
 293:main.c        **** {
 964               	.LM131:
 965               	.LFBB13:
 966 035a 4F92      		push r4
 967 035c 5F92      		push r5
 968 035e 6F92      		push r6
 969 0360 7F92      		push r7
 970 0362 8F92      		push r8
 971 0364 9F92      		push r9
 972 0366 AF92      		push r10
 973 0368 BF92      		push r11
 974 036a CF92      		push r12
 975 036c DF92      		push r13
 976 036e FF92      		push r15
 977 0370 0F93      		push r16
 978 0372 1F93      		push r17
 979 0374 DF93      		push r29
 980 0376 CF93      		push r28
 981 0378 CDB7      		in r28,__SP_L__
 982 037a DEB7      		in r29,__SP_H__
 983 037c C854      		subi r28,lo8(-(-72))
 984 037e D040      		sbci r29,hi8(-(-72))
 985 0380 0FB6      		in __tmp_reg__,__SREG__
 986 0382 F894      		cli
 987 0384 DEBF      		out __SP_H__,r29
 988 0386 0FBE      		out __SREG__,__tmp_reg__
 989 0388 CDBF      		out __SP_L__,r28
 990               	/* prologue: function */
 991               	/* frame size = 72 */
 992               	/* stack size = 87 */
 993               	.L__stack_usage = 87
 294:main.c        **** 	PORTB &=~ _BV(2);//back to lo
 995               	.LM132:
 996 038a C298      		cbi 56-32,2
 295:main.c        **** 	DC_val = ADC_data;
 998               	.LM133:
 999 038c 8091 0000 		lds r24,ADC_data
 1000 0390 9091 0000 		lds r25,ADC_data+1
 1001 0394 9093 0000 		sts DC_val+1,r25
 1002 0398 8093 0000 		sts DC_val,r24
 297:main.c        **** 	ADC_flag = 0;	
 1004               	.LM134:
 1005 039c 1092 0000 		sts ADC_flag,__zero_reg__
 299:main.c        **** 	PID_pump();//run PID on pump and update pump pwm.
 1007               	.LM135:
 1008 03a0 00D0      		rcall PID_pump
 301:main.c        **** 	measured_temperature = (DC_val - lambda);
 1010               	.LM136:
 1011 03a2 8091 0000 		lds r24,DC_val
 1012 03a6 9091 0000 		lds r25,DC_val+1
 1013 03aa 2091 0000 		lds r18,lambda
 1014 03ae 3091 0000 		lds r19,lambda+1
 1015 03b2 821B      		sub r24,r18
 1016 03b4 930B      		sbc r25,r19
 302:main.c        **** 	if (measured_temperature <= 255)//make into (8-bit - 10 bit value) and prevent negatives
 1018               	.LM137:
 1019 03b6 8F3F      		cpi r24,255
 1020 03b8 9105      		cpc r25,__zero_reg__
 1021 03ba 01F0      		breq .+2
 1022 03bc 00F4      		brsh .L48
 304:main.c        **** 		measured_temperature = (255 - measured_temperature);
 1024               	.LM138:
 1025 03be 2FEF      		ldi r18,lo8(255)
 1026 03c0 30E0      		ldi r19,hi8(255)
 1027 03c2 281B      		sub r18,r24
 1028 03c4 390B      		sbc r19,r25
 1029 03c6 3093 0000 		sts measured_temperature+1,r19
 1030 03ca 2093 0000 		sts measured_temperature,r18
 1031 03ce 00C0      		rjmp .L49
 1032               	.L48:
 308:main.c        **** 		measured_temperature =0;
 1034               	.LM139:
 1035 03d0 1092 0000 		sts measured_temperature+1,__zero_reg__
 1036 03d4 1092 0000 		sts measured_temperature,__zero_reg__
 1037               	.L49:
 310:main.c        **** 	if ( (measured_temperature> (TARGET_TEMP-5))&&(measured_temperature<(TARGET_TEMP+5)) )
 1039               	.LM140:
 1040 03d8 8091 0000 		lds r24,measured_temperature
 1041 03dc 9091 0000 		lds r25,measured_temperature+1
 1042 03e0 895E      		subi r24,lo8(-(-233))
 1043 03e2 9040      		sbci r25,hi8(-(-233))
 1044 03e4 8930      		cpi r24,9
 1045 03e6 9105      		cpc r25,__zero_reg__
 1046 03e8 00F4      		brsh .L50
 312:main.c        **** 		PORTD &=~ _BV(4);//LED off
 1048               	.LM141:
 1049 03ea 9498      		cbi 50-32,4
 1050 03ec 00C0      		rjmp .L51
 1051               	.L50:
 316:main.c        **** 		PORTD |= _BV(4);//LED on
 1053               	.LM142:
 1054 03ee 949A      		sbi 50-32,4
 1055               	.L51:
 323:main.c        **** 	struct two_col out_volts[]={	//table columns: pump, zero_to_5_WB (pump current ADC value, DAC valu
 1057               	.LM143:
 1058 03f0 DE01      		movw r26,r28
 1059 03f2 1196      		adiw r26,1
 1060 03f4 E0E0      		ldi r30,lo8(C.18.2970)
 1061 03f6 F0E0      		ldi r31,hi8(C.18.2970)
 1062 03f8 88E4      		ldi r24,lo8(72)
 1063               	.L52:
 1064 03fa 0190      		ld r0,Z+
 1065 03fc 0D92      		st X+,r0
 1066 03fe 8150      		subi r24,lo8(-(-1))
 1067 0400 01F4      		brne .L52
 339:main.c        **** 	if (pump<out_volts[0].x)//smaller than the lowest value in LOT
 1069               	.LM144:
 1070 0402 0091 0000 		lds r16,pump
 1071 0406 1091 0000 		lds r17,pump+1
 1072 040a 8981      		ldd r24,Y+1
 1073 040c 9A81      		ldd r25,Y+2
 1074 040e 0817      		cp r16,r24
 1075 0410 1907      		cpc r17,r25
 1076 0412 00F4      		brsh .L53
 341:main.c        **** 		zero_to_5_WB = 0;
 1078               	.LM145:
 1079 0414 1092 0000 		sts zero_to_5_WB,__zero_reg__
 1080 0418 1092 0000 		sts zero_to_5_WB+1,__zero_reg__
 1081 041c 1092 0000 		sts zero_to_5_WB+2,__zero_reg__
 1082 0420 1092 0000 		sts zero_to_5_WB+3,__zero_reg__
 1083 0424 00C0      		rjmp .L54
 1084               	.L53:
 343:main.c        **** 	else if (pump>out_volts[n-1].x)//larger than the highest value in the LOT
 1086               	.LM146:
 1087 0426 FE01      		movw r30,r28
 1088 0428 ED5B      		subi r30,lo8(-(67))
 1089 042a FF4F      		sbci r31,hi8(-(67))
 1090 042c 8081      		ld r24,Z
 1091 042e 9181      		ldd r25,Z+1
 1092 0430 8017      		cp r24,r16
 1093 0432 9107      		cpc r25,r17
 1094 0434 00F0      		brlo .L55
 1095 0436 2091 0000 		lds r18,zero_to_5_WB
 1096 043a 3091 0000 		lds r19,zero_to_5_WB+1
 1097 043e 4091 0000 		lds r20,zero_to_5_WB+2
 1098 0442 5091 0000 		lds r21,zero_to_5_WB+3
 1099 0446 FF24      		clr r15
 1100               	.LBB16:
 352:main.c        **** 			if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1102               	.LM147:
 1103 0448 2E01      		movw r4,r28
 1104 044a 0894      		sec
 1105 044c 411C      		adc r4,__zero_reg__
 1106 044e 511C      		adc r5,__zero_reg__
 1107 0450 00C0      		rjmp .L56
 1108               	.L55:
 1109               	.LBE16:
 345:main.c        **** 		zero_to_5_WB = 254;
 1111               	.LM148:
 1112 0452 8EEF      		ldi r24,lo8(254)
 1113 0454 90E0      		ldi r25,hi8(254)
 1114 0456 A0E0      		ldi r26,hlo8(254)
 1115 0458 B0E0      		ldi r27,hhi8(254)
 1116 045a 8093 0000 		sts zero_to_5_WB,r24
 1117 045e 9093 0000 		sts zero_to_5_WB+1,r25
 1118 0462 A093 0000 		sts zero_to_5_WB+2,r26
 1119 0466 B093 0000 		sts zero_to_5_WB+3,r27
 1120 046a 00C0      		rjmp .L54
 1121               	.L58:
 1122               	.LBB18:
 352:main.c        **** 			if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1124               	.LM149:
 1125 046c DC01      		movw r26,r24
 1126 046e AA0F      		lsl r26
 1127 0470 BB1F      		rol r27
 1128 0472 A80F      		add r26,r24
 1129 0474 B91F      		adc r27,r25
 1130 0476 AA0F      		lsl r26
 1131 0478 BB1F      		rol r27
 1132 047a A40D      		add r26,r4
 1133 047c B51D      		adc r27,r5
 1134 047e CD90      		ld r12,X+
 1135 0480 DC90      		ld r13,X
 1136 0482 1197      		sbiw r26,1
 1137 0484 0C15      		cp r16,r12
 1138 0486 1D05      		cpc r17,r13
 1139 0488 00F0      		brlo .L57
 352:main.c        **** 			if ( out_volts[i].x <= pump && out_volts[i+1].x >= pump )
 1141               	.LM150:
 1142 048a 0196      		adiw r24,1
 1143 048c FC01      		movw r30,r24
 1144 048e EE0F      		lsl r30
 1145 0490 FF1F      		rol r31
 1146 0492 E80F      		add r30,r24
 1147 0494 F91F      		adc r31,r25
 1148 0496 EE0F      		lsl r30
 1149 0498 FF1F      		rol r31
 1150 049a E40D      		add r30,r4
 1151 049c F51D      		adc r31,r5
 1152 049e A080      		ld r10,Z
 1153 04a0 B180      		ldd r11,Z+1
 1154 04a2 A016      		cp r10,r16
 1155 04a4 B106      		cpc r11,r17
 1156 04a6 00F0      		brlo .L57
 1157               	.LBB17:
 356:main.c        **** 				zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output
 1159               	.LM151:
 1160 04a8 1296      		adiw r26,2
 1161 04aa 6D90      		ld r6,X+
 1162 04ac 7D90      		ld r7,X+
 1163 04ae 8D90      		ld r8,X+
 1164 04b0 9C90      		ld r9,X
 1165 04b2 1597      		sbiw r26,2+3
 354:main.c        **** 				uint16_t diffx = pump - out_volts[i].x; //difference between the pump value and the x value in 
 1167               	.LM152:
 1168 04b4 B801      		movw r22,r16
 1169 04b6 6C19      		sub r22,r12
 1170 04b8 7D09      		sbc r23,r13
 356:main.c        **** 				zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output
 1172               	.LM153:
 1173 04ba 80E0      		ldi r24,lo8(0)
 1174 04bc 90E0      		ldi r25,hi8(0)
 1175 04be 2281      		ldd r18,Z+2
 1176 04c0 3381      		ldd r19,Z+3
 1177 04c2 4481      		ldd r20,Z+4
 1178 04c4 5581      		ldd r21,Z+5
 1179 04c6 2619      		sub r18,r6
 1180 04c8 3709      		sbc r19,r7
 1181 04ca 4809      		sbc r20,r8
 1182 04cc 5909      		sbc r21,r9
 1183 04ce 00D0      		rcall __mulsi3
 355:main.c        **** 				uint16_t diffn = out_volts[i+1].x - out_volts[i].x;//spacing between the values in the LOT
 1185               	.LM154:
 1186 04d0 AC18      		sub r10,r12
 1187 04d2 BD08      		sbc r11,r13
 356:main.c        **** 				zero_to_5_WB = out_volts[i].y + ( out_volts[i+1].y - out_volts[i].y ) * diffx / diffn; //output
 1189               	.LM155:
 1190 04d4 9501      		movw r18,r10
 1191 04d6 40E0      		ldi r20,lo8(0)
 1192 04d8 50E0      		ldi r21,hi8(0)
 1193 04da 00D0      		rcall __udivmodsi4
 1194 04dc 260D      		add r18,r6
 1195 04de 371D      		adc r19,r7
 1196 04e0 481D      		adc r20,r8
 1197 04e2 591D      		adc r21,r9
 1198               	.L57:
 1199               	.LBE17:
 350:main.c        **** 		for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1201               	.LM156:
 1202 04e4 F394      		inc r15
 1203               	.L56:
 350:main.c        **** 		for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1205               	.LM157:
 1206 04e6 8F2D      		mov r24,r15
 1207 04e8 90E0      		ldi r25,lo8(0)
 1208 04ea 6F2D      		mov r22,r15
 1209 04ec 6B30      		cpi r22,lo8(11)
 1210 04ee 01F0      		breq .+2
 1211 04f0 00C0      		rjmp .L58
 350:main.c        **** 		for( uint8_t i = 0; i < n-1; i++ )//loop through table and find value
 1213               	.LM158:
 1214 04f2 2093 0000 		sts zero_to_5_WB,r18
 1215 04f6 3093 0000 		sts zero_to_5_WB+1,r19
 1216 04fa 4093 0000 		sts zero_to_5_WB+2,r20
 1217 04fe 5093 0000 		sts zero_to_5_WB+3,r21
 1218               	.L54:
 1219               	.LBE18:
 360:main.c        **** 	OCR2 = zero_to_5_WB;// set DAC output
 1221               	.LM159:
 1222 0502 8091 0000 		lds r24,zero_to_5_WB
 1223 0506 83BD      		out 67-32,r24
 361:main.c        **** 	RtwoR_out(); //set six bit DAC outout for narrow
 1225               	.LM160:
 1226 0508 00D0      		rcall RtwoR_out
 362:main.c        **** 	charspot = put_in_string(zero_to_5_WB,'\0',charspot);//puts data in big string timer counts passed
 1228               	.LM161:
 1229 050a 4091 0000 		lds r20,charspot
 1230 050e 8091 0000 		lds r24,zero_to_5_WB
 1231 0512 9091 0000 		lds r25,zero_to_5_WB+1
 1232 0516 60E0      		ldi r22,lo8(0)
 1233 0518 00D0      		rcall put_in_string
 1234 051a 8093 0000 		sts charspot,r24
 363:main.c        **** 	charspot = put_in_string(measured_temperature,'\0',charspot);//puts data in big string
 1236               	.LM162:
 1237 051e 4091 0000 		lds r20,charspot
 1238 0522 8091 0000 		lds r24,measured_temperature
 1239 0526 9091 0000 		lds r25,measured_temperature+1
 1240 052a 60E0      		ldi r22,lo8(0)
 1241 052c 00D0      		rcall put_in_string
 1242 052e 8093 0000 		sts charspot,r24
 365:main.c        **** 	PID_heater();//run the pid on the temperature and update timer 0
 1244               	.LM163:
 1245 0532 00D0      		rcall PID_heater
 367:main.c        **** 	charspot=spitout(charspot);//send it all out the uart
 1247               	.LM164:
 1248 0534 8091 0000 		lds r24,charspot
 1249 0538 00D0      		rcall spitout
 1250 053a 8093 0000 		sts charspot,r24
 1251               	/* epilogue start */
 368:main.c        **** }
 1253               	.LM165:
 1254 053e C85B      		subi r28,lo8(-(72))
 1255 0540 DF4F      		sbci r29,hi8(-(72))
 1256 0542 0FB6      		in __tmp_reg__,__SREG__
 1257 0544 F894      		cli
 1258 0546 DEBF      		out __SP_H__,r29
 1259 0548 0FBE      		out __SREG__,__tmp_reg__
 1260 054a CDBF      		out __SP_L__,r28
 1261 054c CF91      		pop r28
 1262 054e DF91      		pop r29
 1263 0550 1F91      		pop r17
 1264 0552 0F91      		pop r16
 1265 0554 FF90      		pop r15
 1266 0556 DF90      		pop r13
 1267 0558 CF90      		pop r12
 1268 055a BF90      		pop r11
 1269 055c AF90      		pop r10
 1270 055e 9F90      		pop r9
 1271 0560 8F90      		pop r8
 1272 0562 7F90      		pop r7
 1273 0564 6F90      		pop r6
 1274 0566 5F90      		pop r5
 1275 0568 4F90      		pop r4
 1276 056a 0895      		ret
 1287               	.Lscope13:
 1289               	.global	__vector_14
 1291               	__vector_14:
  99:main.c        **** {
 1293               	.LM166:
 1294               	.LFBB14:
 1295 056c 1F92      		push __zero_reg__
 1296 056e 0F92      		push r0
 1297 0570 0FB6      		in r0,__SREG__
 1298 0572 0F92      		push r0
 1299 0574 1124      		clr __zero_reg__
 1300 0576 2F93      		push r18
 1301 0578 3F93      		push r19
 1302 057a 4F93      		push r20
 1303 057c 5F93      		push r21
 1304 057e 6F93      		push r22
 1305 0580 7F93      		push r23
 1306 0582 8F93      		push r24
 1307 0584 9F93      		push r25
 1308 0586 AF93      		push r26
 1309 0588 BF93      		push r27
 1310 058a EF93      		push r30
 1311 058c FF93      		push r31
 1312               	/* prologue: Signal */
 1313               	/* frame size = 0 */
 1314               	/* stack size = 15 */
 1315               	.L__stack_usage = 15
 100:main.c        **** ADC_data = readadc();
 1317               	.LM167:
 1318 058e 00D0      		rcall readadc
 1319 0590 9093 0000 		sts ADC_data+1,r25
 1320 0594 8093 0000 		sts ADC_data,r24
 102:main.c        **** if (ADC_flag == 7)//
 1322               	.LM168:
 1323 0598 8091 0000 		lds r24,ADC_flag
 1324 059c 8730      		cpi r24,lo8(7)
 1325 059e 01F4      		brne .L61
 104:main.c        **** 	four();
 1327               	.LM169:
 1328 05a0 00D0      		rcall four
 1329 05a2 00C0      		rjmp .L60
 1330               	.L61:
 106:main.c        **** else if (ADC_flag == 2)
 1332               	.LM170:
 1333 05a4 8091 0000 		lds r24,ADC_flag
 1334 05a8 8230      		cpi r24,lo8(2)
 1335 05aa 01F4      		brne .L63
 108:main.c        **** 	six_1();
 1337               	.LM171:
 1338 05ac 00D0      		rcall six_1
 1339 05ae 00C0      		rjmp .L60
 1340               	.L63:
 110:main.c        **** else if (ADC_flag == 8)
 1342               	.LM172:
 1343 05b0 8091 0000 		lds r24,ADC_flag
 1344 05b4 8830      		cpi r24,lo8(8)
 1345 05b6 01F4      		brne .L64
 112:main.c        **** 	six_2();
 1347               	.LM173:
 1348 05b8 00D0      		rcall six_2
 1349 05ba 00C0      		rjmp .L60
 1350               	.L64:
 114:main.c        **** else if (ADC_flag == 9)
 1352               	.LM174:
 1353 05bc 8091 0000 		lds r24,ADC_flag
 1354 05c0 8930      		cpi r24,lo8(9)
 1355 05c2 01F4      		brne .L65
 116:main.c        **** 	six_3();
 1357               	.LM175:
 1358 05c4 00D0      		rcall six_3
 1359 05c6 00C0      		rjmp .L60
 1360               	.L65:
 119:main.c        **** else if (ADC_flag == 3)//lambda
 1362               	.LM176:
 1363 05c8 8091 0000 		lds r24,ADC_flag
 1364 05cc 8330      		cpi r24,lo8(3)
 1365 05ce 01F4      		brne .L66
 121:main.c        **** 	seven();
 1367               	.LM177:
 1368 05d0 00D0      		rcall seven
 1369 05d2 00C0      		rjmp .L60
 1370               	.L66:
 123:main.c        **** else if (ADC_flag == 4)//lambda+DC and calculations
 1372               	.LM178:
 1373 05d4 8091 0000 		lds r24,ADC_flag
 1374 05d8 8430      		cpi r24,lo8(4)
 1375 05da 01F4      		brne .L67
 125:main.c        **** 	eight();
 1377               	.LM179:
 1378 05dc 00D0      		rcall eight
 1379 05de 00C0      		rjmp .L60
 1380               	.L67:
 130:main.c        **** 		ADC_data = readadc();//make sure adc is read to clear 
 1382               	.LM180:
 1383 05e0 00D0      		rcall readadc
 1384 05e2 9093 0000 		sts ADC_data+1,r25
 1385 05e6 8093 0000 		sts ADC_data,r24
 1386               	.L60:
 1387               	/* epilogue start */
 132:main.c        **** }
 1389               	.LM181:
 1390 05ea FF91      		pop r31
 1391 05ec EF91      		pop r30
 1392 05ee BF91      		pop r27
 1393 05f0 AF91      		pop r26
 1394 05f2 9F91      		pop r25
 1395 05f4 8F91      		pop r24
 1396 05f6 7F91      		pop r23
 1397 05f8 6F91      		pop r22
 1398 05fa 5F91      		pop r21
 1399 05fc 4F91      		pop r20
 1400 05fe 3F91      		pop r19
 1401 0600 2F91      		pop r18
 1402 0602 0F90      		pop r0
 1403 0604 0FBE      		out __SREG__,r0
 1404 0606 0F90      		pop r0
 1405 0608 1F90      		pop __zero_reg__
 1406 060a 1895      		reti
 1408               	.Lscope14:
 1409               	.global	lambda
 1410               	.global	lambda
 1411               		.section .bss
 1414               	lambda:
 1415 0000 0000      		.skip 2,0
 1416               	.global	pump
 1417               	.global	pump
 1420               	pump:
 1421 0002 0000      		.skip 2,0
 1422               	.global	DC_val
 1423               	.global	DC_val
 1426               	DC_val:
 1427 0004 0000      		.skip 2,0
 1428               	.global	IpumpVolts
 1429               	.global	IpumpVolts
 1432               	IpumpVolts:
 1433 0006 0000      		.skip 2,0
 1434               	.global	ramp_flag
 1435               	.global	ramp_flag
 1438               	ramp_flag:
 1439 0008 00        		.skip 1,0
 1440               	.global	charspot
 1441               	.global	charspot
 1444               	charspot:
 1445 0009 00        		.skip 1,0
 1446               	.global	rampcounter
 1447               	.global	rampcounter
 1450               	rampcounter:
 1451 000a 00        		.skip 1,0
 1452               	.global	Narro_curve
 1453               		.section	.progmem.data,"a",@progbits
 1456               	Narro_curve:
 1457 0000 0B        		.byte	11
 1458 0001 0B        		.byte	11
 1459 0002 0B        		.byte	11
 1460 0003 0B        		.byte	11
 1461 0004 0B        		.byte	11
 1462 0005 0B        		.byte	11
 1463 0006 0B        		.byte	11
 1464 0007 0B        		.byte	11
 1465 0008 0B        		.byte	11
 1466 0009 0B        		.byte	11
 1467 000a 0B        		.byte	11
 1468 000b 0B        		.byte	11
 1469 000c 0B        		.byte	11
 1470 000d 0B        		.byte	11
 1471 000e 0B        		.byte	11
 1472 000f 0B        		.byte	11
 1473 0010 0B        		.byte	11
 1474 0011 0B        		.byte	11
 1475 0012 0A        		.byte	10
 1476 0013 0A        		.byte	10
 1477 0014 0A        		.byte	10
 1478 0015 0A        		.byte	10
 1479 0016 0A        		.byte	10
 1480 0017 0A        		.byte	10
 1481 0018 09        		.byte	9
 1482 0019 09        		.byte	9
 1483 001a 09        		.byte	9
 1484 001b 08        		.byte	8
 1485 001c 08        		.byte	8
 1486 001d 08        		.byte	8
 1487 001e 07        		.byte	7
 1488 001f 07        		.byte	7
 1489 0020 05        		.byte	5
 1490 0021 05        		.byte	5
 1491 0022 04        		.byte	4
 1492 0023 04        		.byte	4
 1493 0024 04        		.byte	4
 1494 0025 03        		.byte	3
 1495 0026 03        		.byte	3
 1496 0027 03        		.byte	3
 1497 0028 02        		.byte	2
 1498 0029 02        		.byte	2
 1499 002a 02        		.byte	2
 1500 002b 02        		.byte	2
 1501 002c 02        		.byte	2
 1502 002d 02        		.byte	2
 1503 002e 01        		.byte	1
 1504 002f 01        		.byte	1
 1505 0030 01        		.byte	1
 1506 0031 01        		.byte	1
 1507 0032 01        		.byte	1
 1508 0033 01        		.byte	1
 1509 0034 01        		.byte	1
 1510 0035 01        		.byte	1
 1511 0036 01        		.byte	1
 1512 0037 01        		.byte	1
 1513 0038 01        		.byte	1
 1514 0039 01        		.byte	1
 1515 003a 01        		.byte	1
 1516 003b 01        		.byte	1
 1517 003c 01        		.byte	1
 1518 003d 01        		.byte	1
 1519 003e 01        		.byte	1
 1520 003f 01        		.byte	1
 1521               		.comm serialout,50,1
 1522               		.comm heat_power,1,1
 1523               		.comm ADC_data,2,1
 1524               		.comm measured_temperature,2,1
 1525               		.comm zero_to_5_WB,4,1
 1526               		.comm its_off,1,1
 1527               		.comm ADC_flag,1,1
 1528               		.comm pidCounter,1,1
 1529               		.comm pidData_temp,18,1
 1530               		.comm pidData_pump,18,1
 1531               		.data
 1534               	C.18.2970:
 1535 000b 9001      		.word	400
 1536 000d 00        		.byte	0
 1537 000e 00        		.byte	0
 1538 000f 00        		.byte	0
 1539 0010 00        		.byte	0
 1540 0011 A901      		.word	425
 1541 0013 0A        		.byte	10
 1542 0014 00        		.byte	0
 1543 0015 00        		.byte	0
 1544 0016 00        		.byte	0
 1545 0017 C201      		.word	450
 1546 0019 14        		.byte	20
 1547 001a 00        		.byte	0
 1548 001b 00        		.byte	0
 1549 001c 00        		.byte	0
 1550 001d DB01      		.word	475
 1551 001f 1E        		.byte	30
 1552 0020 00        		.byte	0
 1553 0021 00        		.byte	0
 1554 0022 00        		.byte	0
 1555 0023 F401      		.word	500
 1556 0025 28        		.byte	40
 1557 0026 00        		.byte	0
 1558 0027 00        		.byte	0
 1559 0028 00        		.byte	0
 1560 0029 0D02      		.word	525
 1561 002b 32        		.byte	50
 1562 002c 00        		.byte	0
 1563 002d 00        		.byte	0
 1564 002e 00        		.byte	0
 1565 002f 2602      		.word	550
 1566 0031 46        		.byte	70
 1567 0032 00        		.byte	0
 1568 0033 00        		.byte	0
 1569 0034 00        		.byte	0
 1570 0035 3F02      		.word	575
 1571 0037 6E        		.byte	110
 1572 0038 00        		.byte	0
 1573 0039 00        		.byte	0
 1574 003a 00        		.byte	0
 1575 003b 5802      		.word	600
 1576 003d 8C        		.byte	-116
 1577 003e 00        		.byte	0
 1578 003f 00        		.byte	0
 1579 0040 00        		.byte	0
 1580 0041 7102      		.word	625
 1581 0043 B4        		.byte	-76
 1582 0044 00        		.byte	0
 1583 0045 00        		.byte	0
 1584 0046 00        		.byte	0
 1585 0047 8A02      		.word	650
 1586 0049 C8        		.byte	-56
 1587 004a 00        		.byte	0
 1588 004b 00        		.byte	0
 1589 004c 00        		.byte	0
 1590 004d D002      		.word	720
 1591 004f FE        		.byte	-2
 1592 0050 00        		.byte	0
 1593 0051 00        		.byte	0
 1594 0052 00        		.byte	0
 1613               		.text
 1615               	.Letext0:
 1616               	.global __do_copy_data
 1617               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccKvA1BO.s:2      *ABS*:0000003f __SREG__
     /tmp/ccKvA1BO.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccKvA1BO.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccKvA1BO.s:5      *ABS*:00000034 __CCP__
     /tmp/ccKvA1BO.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccKvA1BO.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccKvA1BO.s:93     .text:00000000 main
                            *COM*:00000012 pidData_temp
                            *COM*:00000012 pidData_pump
                            *COM*:00000001 heat_power
     /tmp/ccKvA1BO.s:1438   .bss:00000008 ramp_flag
     /tmp/ccKvA1BO.s:263    .text:000000a0 do_things
                            *COM*:00000001 ADC_flag
     /tmp/ccKvA1BO.s:308    .text:000000be __vector_9
                            *COM*:00000001 its_off
     /tmp/ccKvA1BO.s:405    .text:0000012c four
     /tmp/ccKvA1BO.s:1444   .bss:00000009 charspot
                            *COM*:00000002 ADC_data
     /tmp/ccKvA1BO.s:441    .text:0000014e six_1
     /tmp/ccKvA1BO.s:1420   .bss:00000002 pump
     /tmp/ccKvA1BO.s:471    .text:00000168 six_2
     /tmp/ccKvA1BO.s:505    .text:0000018e six_3
     /tmp/ccKvA1BO.s:555    .text:000001cc seven
     /tmp/ccKvA1BO.s:1414   .bss:00000000 lambda
     /tmp/ccKvA1BO.s:598    .text:000001f8 readadc
     /tmp/ccKvA1BO.s:635    .text:0000020a PID_heater
                            *COM*:00000002 measured_temperature
     /tmp/ccKvA1BO.s:690    .text:00000244 PID_pump
     /tmp/ccKvA1BO.s:775    .text:000002ae RtwoR_out
                            *COM*:00000004 zero_to_5_WB
     /tmp/ccKvA1BO.s:1456   .progmem.data:00000000 Narro_curve
     /tmp/ccKvA1BO.s:962    .text:0000035a eight
     /tmp/ccKvA1BO.s:1426   .bss:00000004 DC_val
     /tmp/ccKvA1BO.s:1534   .data:0000000b C.18.2970
     /tmp/ccKvA1BO.s:1291   .text:0000056c __vector_14
     /tmp/ccKvA1BO.s:1432   .bss:00000006 IpumpVolts
     /tmp/ccKvA1BO.s:1450   .bss:0000000a rampcounter
                            *COM*:00000032 serialout
                            *COM*:00000001 pidCounter

UNDEFINED SYMBOLS
setup_timer1
setup_timer2
pid_Init
adc_init
timer0init
uart_putst
uart_put16dec
uart_putch
put_in_string
__udivmodhi4
pid_Controller
__divmodsi4
__mulsi3
__udivmodsi4
spitout
__do_copy_data
__do_clear_bss
